<!doctype html>
<html lang="ko">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>영업일지</title>
    <script>
      // Redirect to sales-input.html while preserving query and hash.
      (function(){
        try{
          const q = window.location.search || '';
          const h = window.location.hash || '';
          const target = '/sales-input.html' + q + h;
          // Use replace to avoid polluting history
          window.location.replace(target);
        }catch(e){
          document.addEventListener('DOMContentLoaded', function(){ document.body.innerText = 'Redirect failed: ' + (e && e.message); });
        }
      })();
    </script>
  </head>
  <body>
    <p>Redirecting to <a id="link" href="/sales-input.html">sales-input.html</a> — if you are not redirected automatically, click the link.</p>
  </body>
</html>
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="manifest" href="/manifest.json">
  <meta name="theme-color" content="#1e3c72">
  <title>영업일지 입력</title>
  <script>
    // Load PapaParse only if it's not already present to avoid duplicate loads / race conditions
    (function(){
      try{
        if (window.Papa) return;
        var s = document.createElement('script');
        s.src = 'https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js';
        s.async = false; // keep parsing order deterministic for legacy consumers
        document.head.appendChild(s);
      }catch(e){/* ignore load errors - consumers will handle missing Papa */}
    })();
  </script>
  <style>
    /* Reset & layout */
    body {
      background: #f5f6fa;
      font-family: 'Segoe UI', Arial, sans-serif;
      color: #111;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      -webkit-font-smoothing:antialiased;
      font-size: 16px; /* base size increased for readability */
    }
    h2 { font-size: 2.2rem; margin: 2rem 0 1rem 0; font-weight: 800; color:#0b2b5a }

    form {
      width: 95vw;
      border-radius: 1.2rem;
      box-shadow: 0 10px 30px rgba(14,30,80,0.08);
      padding: 1.6rem 1.8rem;
      margin-bottom: 2rem;
    }

    label { display:block; font-weight:700; margin-top:1rem; color:#333; }

  input, select, textarea { width:100%; padding:0.95rem; border-radius:0.9rem; border:1px solid #d6dbe8; box-sizing:border-box; font-size:1rem; }

    /* subject/activity buttons */
    .subjects { display:flex; flex-wrap:wrap; gap:0.5rem; margin-bottom:1rem; }
  .subject-btn { flex:1 1 45%; min-width:130px; padding:1.05rem; font-size:1.08rem; border-radius:1rem; border:none; background:#e9eefc; color:#12325a; font-weight:800; cursor:pointer }
  .subject-btn.selected { background:#12325a; color:#fff; box-shadow:0 6px 18px rgba(18,50,90,0.14); }

    /* region / school button grid: desktop 3 cols, medium 2, small 1 */
  .btn-grid { display:grid; grid-template-columns: repeat(3, 1fr); gap:0.7rem; margin-top:0.6rem; margin-bottom:1rem; }
  .grid-button { padding:1.05rem 1rem; font-size:1.05rem; border-radius:1rem; border:1px solid #cfd9ff; background:#fff; color:#133257; cursor:pointer; text-align:center; white-space:normal; overflow-wrap:anywhere; word-break:keep-all; min-height:56px; line-height:1.3 }
  .grid-button:hover { background:#f5f7ff; transform:translateY(-2px); box-shadow:0 8px 22px rgba(20,40,80,0.06); }
  .grid-button.selected { background:#0b2b5a; color:#fff; border-color:#071a36; box-shadow:0 12px 30px rgba(11,43,90,0.18); font-weight:900 }

    .btn-submit, .btn-report { width:100%; padding:1.2rem; font-size:1.2rem; border-radius:1rem; border:none; background:#1e3c72; color:#fff; font-weight:700; cursor:pointer }
    .btn-report { background:#ff9800; margin-top:0.5rem }

    /* school metadata card styles (inline and step2) - more prominent */
    #schoolMetaInline, #schoolMeta {
      display:none;
      padding:22px 20px;
      border-radius:14px;
      background:linear-gradient(180deg,#ffffff 0%, #f7f8ff 100%);
      border:1px solid #e2e8ff;
      box-shadow:0 18px 48px rgba(10,28,64,0.12);
      color:#071a2e;
      font-size:16.5px;
      line-height:1.6;
      margin-top:1rem;
      position:relative;
      overflow:visible;
    }
    /* accent stripe on the left (wider for better affordance) */
    #schoolMetaInline::before, #schoolMeta::before {
      content: '';
      position: absolute;
      left: 0;
      top: 8px;
      bottom: 8px;
      width: 10px;
      border-radius: 8px;
      background: linear-gradient(180deg,#556ee8,#6b4bb0);
      box-shadow: 0 4px 14px rgba(80,90,160,0.08);
    }
  #schoolMetaInline h4, #schoolMeta h4 { margin:0 0 .6rem 18px; font-size:19px; color:#06203f; font-weight:900 }
  .grade-rows { display:block; margin-top:12px; }
  /* turn each grade row into two columns: label / values -- values emphasized */
  .grade-row { display:grid; grid-template-columns:120px 1fr; gap:12px; align-items:center; margin:8px 0; }
  .grade-row .grade-label { font-weight:900; color:#0d304f; font-size:15px }
  .grade-row .grade-value { color:#072042; font-size:15px; display:flex; gap:8px; align-items:baseline }
  /* highlight numeric values much larger */
  .grade-row .grade-value span { font-weight:900; color:#0b2b5a; font-size:17px }
  .meta-key { font-weight:900; font-size:15px; color:#092b4a; }
  /* small explanatory text to the right of numbers (학급 / 학생) */
  .grade-row .small-note { color:#4e5b73; font-size:13px; margin-left:6px }
  /* add a compact summary bar at the top of the card for quick scanning */
  .meta-summary { display:flex; gap:14px; margin:8px 12px 6px 12px; }
  .meta-summary .meta-pill { background:#f3f6ff; padding:.45rem .7rem; border-radius:10px; border:1px solid #e0e8ff; color:#082044; font-weight:800; font-size:14px }

  @media (max-width:1000px) { .btn-grid { grid-template-columns: repeat(2,1fr); } }
  /* Keep 3 columns even on narrow screens when used inside APK/webview per request */
  @media (max-width:600px) { h2 { font-size:1.6rem } .btn-grid { grid-template-columns: repeat(3,1fr); } form { padding:1rem } .grid-button { font-size:1.03rem; min-height:64px } }
  /* meeting button styles */
  .meeting-btn { padding:.6rem .8rem; border-radius:.8rem; border:1px solid #d6dbe8; background:#fff; color:#12325a; cursor:pointer; font-weight:800; min-width:110px }
  .meeting-btn.selected { background: linear-gradient(90deg,#6b8bff,#9e60f0); color:#fff; border-color:rgba(0,0,0,0.08); box-shadow:0 10px 26px rgba(60,70,120,0.12); }
  /* subject block index badge */
  .subject-index { display:inline-flex; align-items:center; justify-content:center; width:34px; height:34px; border-radius:50%; background:#eef3ff; color:#12325a; font-weight:800; margin-bottom:8px; border:1px solid #d6dbe8; margin-right:8px }
  .subject-block { position:relative; padding:12px 12px 6px 12px; border-radius:10px; border:1px solid #eef2ff; background:#fff; margin-bottom:10px }
  /* timetable responsiveness */
  .timetable-wrapper { overflow:auto; -webkit-overflow-scrolling:touch; position:relative; }
  table.timetable { border-collapse:collapse; width:100%; font-size:11px; line-height:1.12; }
  /* compact cells to reduce wrapping in timetable; use !important to override inline JS styles */
  .timetable-wrapper table.timetable th,
  .timetable-wrapper table.timetable td { border:1px solid #e6eefc; padding:4px 6px !important; font-size:11px !important; vertical-align:top; }
  /* Force single-line cells: prevent wrapping, show ellipsis when truncated, allow horizontal scroll */
  .timetable-wrapper table.timetable th,
  .timetable-wrapper table.timetable td {
    white-space: nowrap !important;
    overflow: hidden !important;
    text-overflow: ellipsis !important;
    max-width: 260px; /* reasonable cap to help ellipsis; adjust as needed */
  }
  /* For narrow mobile screens, cap width tighter */
  @media (max-width:600px) {
    .timetable-wrapper table.timetable th,
    .timetable-wrapper table.timetable td { max-width: 140px; }
  }
  /* sticky header row and sticky first column (반/학급 or 교시) within the scroll wrapper */
  .timetable-wrapper table.timetable thead th { position:sticky; top:0; background:#f7fbff; z-index:3; }
  .timetable-wrapper table.timetable th:first-child,
  .timetable-wrapper table.timetable td:first-child { position:sticky; left:0; background:#f7fbff; z-index:2; }
  /* ensure the top-left corner cell stays above both header and first column */
  .timetable-wrapper table.timetable thead th:first-child { z-index:4; }
  /* Mobile tweaks: slightly smaller font and tighter padding for narrow screens */
  @media (max-width:600px) {
    .timetable-wrapper table.timetable { font-size:10px; }
    .timetable-wrapper table.timetable th,
    .timetable-wrapper table.timetable td { padding:3px 5px !important; font-size:10px !important; }
    .timetable-wrapper { max-height:60vh; }
  }
  .current-period { background:#ffeaa7 !important; border:1px solid #f1c40f !important; }
  </style>
  <!-- Portrait-lock overlay styles and element -->
  <style id="cmass-landscape-style">
    #cmass-landscape-overlay { position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(8,12,30,0.92); color:#fff; z-index:99999; text-align:center; padding:2rem; -webkit-user-select:none; user-select:none; }
    #cmass-landscape-overlay .card { max-width:420px; background:transparent; }
    #cmass-landscape-overlay h3 { font-size:1.4rem; margin-bottom:0.6rem }
    #cmass-landscape-overlay p { opacity:0.95; line-height:1.4 }
  </style>
  <div id="cmass-landscape-overlay" aria-hidden="true"><div class="card"><h3>세로 모드에서만 사용하세요</h3><p>기기를 세로로 돌려주세요. 화면을 가로로 돌리는 동안 입력이 사라지는 문제를 막기 위해 잠시 사용을 제한합니다.</p>
    <div style="margin-top:12px;text-align:center">
      <button id="cmass-overlay-lock-btn" class="alt-btn" style="padding:10px 14px;border-radius:10px;margin-right:8px">세로로 전환</button>
      <button id="cmass-overlay-retry-btn" class="alt-btn" style="padding:10px 14px;border-radius:10px">다시 시도</button>
      <div style="margin-top:8px;font-size:12px;opacity:0.95;color:#eef">(버튼을 누르면 가능하면 화면을 세로로 고정합니다)</div>
      <div id="cmass-overlay-ios-help" style="margin-top:8px;font-size:13px;opacity:0.95;color:#eef;display:none">
        iOS/Safari에서는 자동 고정이 지원되지 않을 수 있습니다. 기기를 직접 세로로 돌려주시거나, 아래 '다시 시도'를 눌러보세요.
      </div>
    </div>
  </div></div>
  <script>
    (function(){
      // Only show the portrait-lock overlay on mobile-like devices.
      // Desktop users (large screens / non-mobile UA) should not see this overlay.
      function isMobileDevice(){
        try{
          const ua = navigator.userAgent || '';
          const mobileUA = /Mobi|Android|iPhone|iPad|iPod|Windows Phone/i;
          const hasTouch = (navigator.maxTouchPoints && navigator.maxTouchPoints > 0) || ('ontouchstart' in window);
          const narrowScreen = (typeof screen !== 'undefined' && screen.width) ? screen.width <= 1024 : false;
          return mobileUA.test(ua) || (hasTouch && narrowScreen);
        }catch(e){ return false; }
      }
      function updatePortraitOverlay(){ try{
  const overlay = document.getElementById('cmass-landscape-overlay');
  try{ if (sessionStorage && sessionStorage.getItem && sessionStorage.getItem('cmass_overlay_dismissed')){ if (overlay) overlay.style.display = 'none'; return; } }catch(e){}
        const mobile = isMobileDevice();
        // Determine landscape using reliable sources (prefer matchMedia / screen.orientation)
        let isLandscape = false;
        try{
          if (window.matchMedia && window.matchMedia('(orientation: landscape)').matches) isLandscape = true;
          else if (screen && screen.orientation && typeof screen.orientation.type === 'string') isLandscape = screen.orientation.type.indexOf('landscape') === 0;
          else if (typeof screen !== 'undefined' && screen.width && screen.height) isLandscape = screen.width > screen.height;
        }catch(e){ /* fallback below */ }

        // If virtual keyboard is open (visualViewport height much smaller than screen height), avoid showing the overlay
        let keyboardOpen = false;
        try{
          if (window.visualViewport && screen && screen.height){
            const vh = window.visualViewport.height; const sh = screen.height;
            if (vh && sh && (vh < (sh * 0.6))) keyboardOpen = true;
          }
        }catch(e){}

        // show overlay only when device appears to be mobile/touch AND is in landscape AND keyboard is not open
        if (mobile && isLandscape && !keyboardOpen){
          if (overlay) overlay.style.display = 'flex';
          try{ document.documentElement.style.overflow = 'hidden'; }catch(e){}
          try{ if (screen.orientation && screen.orientation.lock) screen.orientation.lock('portrait').catch(()=>{}); }catch(e){}
        }
        else {
          if (overlay) overlay.style.display = 'none';
          try{ document.documentElement.style.overflow = 'auto'; }catch(e){}
        }
      }catch(e){/* ignore */} }
      window.addEventListener('resize', updatePortraitOverlay);
      window.addEventListener('orientationchange', updatePortraitOverlay);
      document.addEventListener('DOMContentLoaded', function(){
          updatePortraitOverlay();
          // show iOS help text when appropriate
          try{
            const isiOS = /iP(hone|od|ad)/i.test(navigator.userAgent || '');
            const help = document.getElementById('cmass-overlay-ios-help');
            if (isiOS && help) help.style.display = '';
          }catch(e){}
        // wire up the manual lock/dismiss button
    // wire up the manual lock/dismiss button
    // wire up the manual lock/dismiss button
        try{
          const btn = document.getElementById('cmass-overlay-lock-btn');
          if (btn) btn.addEventListener('click', async function(){
            const overlay = document.getElementById('cmass-landscape-overlay');
            try{
              if (screen && screen.orientation && typeof screen.orientation.lock === 'function'){
                await screen.orientation.lock('portrait');
              }
            }catch(e){ /* locking may fail in some browsers, ignore */ }
            try{ if (overlay) overlay.style.display = 'none'; }catch(e){}
            try{ document.documentElement.style.overflow = 'auto'; }catch(e){}
            try{ sessionStorage.setItem('cmass_overlay_dismissed','1'); }catch(e){}
          });
          // retry button: useful for iOS/Safari where lock may fail; hide overlay and prompt user
          const retryBtn = document.getElementById('cmass-overlay-retry-btn');
          if (retryBtn) retryBtn.addEventListener('click', async function(){
            const overlay = document.getElementById('cmass-landscape-overlay');
            try{
              if (screen && screen.orientation && typeof screen.orientation.lock === 'function'){
                await screen.orientation.lock('portrait');
              } else {
                // show a brief guidance toast/alert for iOS users
                try{ alert('이 브라우저에서는 자동 고정이 지원되지 않을 수 있습니다. 기기를 직접 세로로 돌려주세요.'); }catch(e){}
              }
            }catch(e){ try{ alert('세로 고정 시도에 실패했습니다. 기기를 직접 세로로 돌려주세요.'); }catch(er){} }
            try{ if (overlay) overlay.style.display = 'none'; }catch(e){}
            try{ document.documentElement.style.overflow = 'auto'; }catch(e){}
            try{ sessionStorage.setItem('cmass_overlay_dismissed','1'); }catch(e){}
          });
          // hide overlay automatically while typing: when any focusable text input is focused, hide overlay
          document.addEventListener('focusin', function(ev){
            try{
              const t = ev.target;
              if (!t) return;
              const tag = (t.tagName || '').toLowerCase();
              const type = (t.type || '').toLowerCase();
              const isTextInput = tag === 'input' && (type === 'text' || type === 'search' || type === 'tel' || type === 'email' || type === 'number' || type === 'password') || tag === 'textarea' || (t.isContentEditable);
              if (isTextInput){ const overlay = document.getElementById('cmass-landscape-overlay'); if (overlay) overlay.style.display = 'none'; }
            }catch(e){}
          });
          // when input blur, re-evaluate overlay after short delay
          document.addEventListener('focusout', function(){ setTimeout(updatePortraitOverlay, 300); });
        }catch(e){}
      });
    })();
  </script>
  <script>
    // Lightweight modal confirm and toast helpers to replace native confirm/alert
    (function(){
      function ensureModal() {
        if (document.getElementById('cmass-confirm-modal')) return;
        const tpl = document.createElement('div');
        tpl.id = 'cmass-confirm-modal';
        tpl.style.display = 'none';
        tpl.innerHTML = '\n          <div class="cmass-modal-backdrop" style="position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.5);z-index:99999">\n            <div class="cmass-modal-card" style="background:#fff;color:#072042;padding:18px;border-radius:10px;max-width:420px;width:92%;box-shadow:0 12px 30px rgba(2,6,23,0.35);text-align:center">\n              <div id="cmass-modal-msg" style="margin-bottom:14px;white-space:pre-wrap;text-align:left"></div>\n              <div style="text-align:right">\n                <button id="cmass-modal-no" class="alt-btn" style="margin-right:8px;padding:8px 12px;border-radius:8px">취소</button>\n                <button id="cmass-modal-yes" style="padding:8px 12px;border-radius:8px;background:#1e88e5;color:#fff;border:none">확인</button>\n              </div>\n            </div>\n          </div>';
        document.body.appendChild(tpl);
      }
      window.showConfirmModal = function(message){
        ensureModal();
        const root = document.getElementById('cmass-confirm-modal');
        const msg = root.querySelector('#cmass-modal-msg');
        const yes = root.querySelector('#cmass-modal-yes');
        const no = root.querySelector('#cmass-modal-no');
        msg.textContent = message || '';
        root.style.display = '';
        return new Promise((resolve)=>{
          function cleanup(val){ root.style.display = 'none'; yes.removeEventListener('click', onYes); no.removeEventListener('click', onNo); resolve(val); }
          function onYes(){ cleanup(true); }
          function onNo(){ cleanup(false); }
          yes.addEventListener('click', onYes);
          no.addEventListener('click', onNo);
        });
      };

      window.showToast = function(message, timeout){
        try{
          let t = document.getElementById('cmass-toast');
          if (!t){ t = document.createElement('div'); t.id = 'cmass-toast'; t.style.position='fixed'; t.style.right='16px'; t.style.bottom='18px'; t.style.zIndex='99999'; t.style.background='rgba(0,0,0,0.85)'; t.style.color='#fff'; t.style.padding='10px 14px'; t.style.borderRadius='8px'; t.style.fontSize='14px'; t.style.boxShadow='0 8px 20px rgba(0,0,0,0.2)'; document.body.appendChild(t); }
          t.textContent = message || '';
          t.style.opacity = '1'; t.style.transition = 'opacity 0.25s ease';
          if (window.__cmass_toast_timer) clearTimeout(window.__cmass_toast_timer);
          window.__cmass_toast_timer = setTimeout(()=>{ t.style.opacity = '0'; }, timeout || 2200);
        }catch(e){ try{ alert(message); }catch(_){} }
      };
    })();
  </script>
</head>
<body>
  <!-- Diagnostic error overlay: shows uncaught JS errors and offers quick actions (unregister SW / reload) -->
  <div id="cmass-error-overlay" style="display:none;position:fixed;inset:12px;background:rgba(12,12,14,0.9);color:#fff;z-index:999999;padding:18px;border-radius:10px;overflow:auto;font-family:Segoe UI,Arial,Helvetica;">
    <div style="display:flex;justify-content:space-between;align-items:center;gap:12px;margin-bottom:8px;">
      <strong style="font-size:1.05rem">페이지 오류가 발생했습니다</strong>
      <div style="display:flex;gap:8px;align-items:center">
        <button id="cmass-unregister-sw" style="background:#ff7043;border:none;color:#fff;padding:.5rem .7rem;border-radius:.5rem;cursor:pointer">서비스워커 해제</button>
        <button id="cmass-reload" style="background:#2b6cff;border:none;color:#fff;padding:.5rem .7rem;border-radius:.5rem;cursor:pointer">새로고침</button>
        <button id="cmass-hide-overlay" style="background:transparent;border:1px solid #fff;color:#fff;padding:.4rem .6rem;border-radius:.5rem;cursor:pointer">닫기</button>
      </div>
    </div>
    <pre id="cmass-error-text" style="white-space:pre-wrap;color:#ffecec;background:transparent;border-radius:6px;padding:8px;font-size:0.95rem;line-height:1.35;">(오류가 표시됩니다)</pre>
  </div>
  <script>
    // Global diagnostic error handlers: show overlay on uncaught errors / rejections
    (function(){
      function showError(text){
        try{
          const ov = document.getElementById('cmass-error-overlay');
          const pre = document.getElementById('cmass-error-text');
          if (pre) pre.textContent = (text && text.stack) ? (text.stack + '\n') : (typeof text === 'string' ? text : JSON.stringify(text,null,2));
          if (ov) ov.style.display = 'block';
          console.error('CMASS error:', text);
        }catch(e){console.error('showError failed', e)}
      }
      window.addEventListener('error', function(ev){
        try{ showError(ev.error || ev.message || ev); }catch(e){}
      });
      window.addEventListener('unhandledrejection', function(ev){
        try{ showError(ev.reason || ev); }catch(e){}
      });
      // buttons
      document.addEventListener('click', function(e){
        const t = e.target;
        if (!t) return;
        if (t.id === 'cmass-reload') { location.reload(true); }
        if (t.id === 'cmass-hide-overlay') { document.getElementById('cmass-error-overlay').style.display='none'; }
        if (t.id === 'cmass-unregister-sw') {
          try{
            if ('serviceWorker' in navigator) {
              navigator.serviceWorker.getRegistrations().then(function(regs){
                regs.forEach(r=>{ r.unregister().catch(()=>{}); });
                alert('서비스워커 등록 해제를 시도했습니다. 새로고침 후 확인하세요.');
              }).catch(()=>alert('서비스워커 해제 실패'));
            } else alert('이 브라우저는 서비스워커를 지원하지 않습니다.');
          }catch(e){alert('서비스워커 해제 중 오류: '+(e && e.message));}
        }
      });
    })();

    // Immediate redirect: forward legacy /sales-input.html to /front.html preserving the user token.
    // This lets installed TWA APKs that still open the old start_url load the new dashboard without reinstall.
    (function(){
      try{
        // Only auto-redirect when this page is opened with NO same-origin referrer.
        // This handles the case where an old installed TWA uses /sales-input.html as start_url.
        const path = location.pathname || '';
        const isSalesInput = path.endsWith('/sales-input.html') || path === '/sales-input.html';
        const ref = document.referrer || '';
        const hasSameOriginRef = ref && ref.indexOf(location.origin) === 0;
        if (isSalesInput && !hasSameOriginRef){
          const params = new URLSearchParams(location.search);
          const user = params.get('user') || '';
          const target = '/front.html' + (user ? '?user=' + encodeURIComponent(user) : '');
          if (location.pathname !== '/front.html') {
            // use replace to avoid polluting back history
            location.replace(target);
            return;
          }
        }
      }catch(e){ /* ignore errors */ }
    })();

    // Register service worker for offline support and PWA install
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('/service-worker.js').then(() => console.log('SW registered')).catch(e=>console.warn('SW reg failed',e));
    }
  </script>
  <!-- PIN overlay: requires 4-digit PIN for selected staff to proceed -->
  <style>
    #pinOverlay{position:fixed;inset:0;background:rgba(4,12,34,0.56);display:flex;align-items:center;justify-content:center;z-index:9999}
    #pinBox{background:#fff;padding:20px;border-radius:12px;max-width:420px;width:94%;box-shadow:0 18px 48px rgba(2,6,23,0.5);text-align:center}
    #pinBox h3{margin:0 0 8px 0;font-size:1.2rem;color:#072042}
    #pinBox p{margin:0 0 12px 0;color:#40537a}
    #pinInput{font-size:1.4rem;padding:.6rem .8rem;border-radius:8px;border:1px solid #d6dbe8;width:140px;text-align:center;letter-spacing:6px}
    #pinError{color:#c33;margin-top:8px;min-height:20px}
    #pinProceed{margin-top:12px;padding:.7rem 1rem;border-radius:.8rem;border:none;background:#1e3c72;color:#fff;font-weight:800;cursor:pointer}
  </style>
  <div id="pinOverlay" style="display:none;">
    <div id="pinBox" role="dialog" aria-labelledby="pinTitle" aria-modal="true">
      <h3 id="pinTitle">영업일지 접근 인증</h3>
      <p id="pinDesc">본인 영업일지에 접근하려면 4자리 PIN을 입력하세요.</p>
      <div>
        <label for="pinInput" style="position:absolute;left:-9999px;">PIN 입력</label>
        <input id="pinInput" type="password" inputmode="numeric" maxlength="4" placeholder="●●●●" aria-label="4자리 PIN 입력" />
      </div>
      <div id="pinError"></div>
      <button id="pinProceed">입력</button>
    </div>
  </div>
  <script>
    // Canonicalize legacy lowercase user tokens to canonical tokens so address bar shows consistent URLs.
    (function canonUserParam(){
      try{
        const params = new URLSearchParams(window.location.search);
        const user = params.get('user');
        if (!user) return;
        const canonMap = {
          'songhunje': 'Songhoonjae',
          'songhoonjae': 'Songhoonjae',
          'imjunho': 'LimJunho',
          'limjunho': 'LimJunho',
          'joyounghwan': 'ChoYounghwan',
          'choyounghwan': 'ChoYounghwan'
        };
        const lower = user.toLowerCase();
        const mapped = canonMap[lower];
        if (mapped && mapped !== user) {
          params.set('user', mapped);
          const newUrl = window.location.pathname + '?' + params.toString();
          history.replaceState(null, '', newUrl);
        }
      } catch(e){ console.warn('canonUserParam error', e); }
    })();
  </script>
  <div style="width:95vw;max-width:640px;margin:0 auto 8px;display:flex;align-items:center;justify-content:space-between;gap:12px;">
  <h2 style="margin:0;">영업일지 입력</h2>
  <button id="goFrontBtn" type="button" style="background:#1e3c72;color:#fff;border:none;padding:.6rem .9rem;border-radius:.8rem;font-weight:800;cursor:pointer;box-shadow:0 8px 22px rgba(18,50,90,0.12);">뒤로 가기</button>
  </div>
  <script>
    (function(){
      const btn = document.getElementById('goFrontBtn');
      if (!btn) return;
      btn.addEventListener('click', function(){
        try {
          // save current draft synchronously before navigating away
          try{ saveDraftForDate(); }catch(e){}

          // Build an absolute target URL for front page with the current user token (if any)
          const params = new URLSearchParams(window.location.search);
          const token = params.get('user') || '';
          const targetRel = '/front.html' + (token ? '?user=' + encodeURIComponent(token) : '');
          const target = location.origin + targetRel;

          // If there is a same-origin referrer and a meaningful history length, try history.back().
          // Use a short timeout fallback to ensure navigation happens even when history.back() is a no-op.
          if (document.referrer && document.referrer.indexOf(location.origin) === 0 && window.history.length > 1) {
            let navigated = false;
            let timer = null;
            const onVisibility = function(){ navigated = true; cleanup(); };
            const cleanup = function(){ document.removeEventListener('visibilitychange', onVisibility); if(timer) clearTimeout(timer); };
            document.addEventListener('visibilitychange', onVisibility);
            // Attempt history back first
            window.history.back();
            // Fallback after 300ms to front page if back didn't navigate
            timer = setTimeout(function(){ if(!navigated){ window.location.assign(target); } cleanup(); }, 300);
            return;
          }

          // No usable history -> navigate directly to front page
          window.location.assign(target);
        } catch (e) {
          console.warn('goBackBtn failed', e);
          try { window.location.assign(location.origin + '/front.html'); } catch(_){}
        }
      });
    })();
  </script>
  <div id="step1">
    <form>
  <label for="visitDate">방문일</label>
  <input type="date" id="visitDate" name="visitDate" required style="padding:.7rem;border-radius:.8rem;border:1px solid #d6dbe8;margin-bottom:.6rem;" />
  <div id="staffInfo" style="font-size:1.2rem;font-weight:bold;margin-bottom:1rem;">담당자: -</div>
  <label>지역</label>
  <div style="display:flex;gap:.5rem;margin-bottom:.6rem;align-items:center;">
    <input id="searchInput" type="search" placeholder="지역 또는 학교 검색" style="flex:1;padding:.7rem;border-radius:.8rem;border:1px solid #d6dbe8;" aria-label="지역 또는 학교 검색" />
    <button type="button" id="searchClear" style="padding:.6rem .8rem;border-radius:.8rem;border:1px solid #d6dbe8;background:#fff;">지우기</button>
  </div>
  <div id="regionButtons" class="btn-grid" role="listbox" aria-label="지역 선택"></div>
    <label>학교명</label>
    <div id="schoolButtons" class="btn-grid" role="listbox" aria-label="학교명 선택"></div>
    <!-- inline school metadata shown immediately after selecting a school -->
    <div id="schoolMetaInline" class="meta-card" style="display:none;">
      <h4>학교 정보</h4>
      <div class="meta-summary">
        <div class="meta-pill" id="inlinePillEstablish">설립: -</div>
        <div class="meta-pill" id="inlinePillLevel">급: -</div>
        <div class="meta-pill" id="inlinePillStudents">총학생수: -</div>
        <div class="meta-pill" id="inlinePillFeature" style="display:none;">특성: -</div>
      </div>
      <div class="grade-rows">
        <div class="grade-row"><div class="grade-label">1학년:</div><div class="grade-value"><span id="inlineG1c"></span> 학급 / <span id="inlineG1s"></span> 학생</div></div>
        <div class="grade-row"><div class="grade-label">2학년:</div><div class="grade-value"><span id="inlineG2c"></span> 학급 / <span id="inlineG2s"></span> 학생</div></div>
        <div class="grade-row"><div class="grade-label">3학년:</div><div class="grade-value"><span id="inlineG3c"></span> 학급 / <span id="inlineG3s"></span> 학생</div></div>
      </div>
      <!-- Inline NEIS timetable controls for quick lookup when selecting from the list -->
      <div style="margin-top:12px;padding-top:8px;border-top:1px dashed #e6eefc;">
        <label style="font-weight:900;display:block;margin-bottom:6px;">시간표 가져오기 (NEIS)</label>
        <div style="display:flex;gap:.5rem;flex-wrap:wrap;align-items:center;">
          <select id="inlineNeisYear" style="padding:.45rem;border-radius:.5rem;border:1px solid #d6dbe8;"> 
            <option value="2025">2025</option>
            <option value="2024">2024</option>
            <option value="2023">2023</option>
          </select>
          <select id="inlineNeisSemester" style="padding:.45rem;border-radius:.5rem;border:1px solid #d6dbe8;">
            <option value="1">1학기</option>
            <option value="2" selected>2학기</option>
          </select>
          <button type="button" id="btnFetchSelectedTimetableInline" class="meeting-btn" style="margin-left:6px;">선택 학교 시간표 보기</button>
          <button type="button" id="btnCloseTimetableInline" class="meeting-btn" style="margin-left:6px;background:#fff;color:#12325a;border:1px solid #d6dbe8;display:none;">시간표 닫기</button>
        </div>
        <div id="timetableProgressInline" style="margin-top:8px;color:#175;display:none;font-size:13px;"></div>
        <div id="timetableContainerInline" style="margin-top:10px;"></div>
      </div>
    </div>
      <button type="button" id="nextStepBtn" style="width:100%;margin:1rem 0 0 0;padding:1rem;font-size:1.1rem;border-radius:1rem;background:#1e3c72;color:#fff;font-weight:bold;border:none;cursor:pointer;">다음</button>
    </form>
  </div>
  <div id="step2" style="display:none;">
  <form id="salesForm">
      <!-- show selected region/school -->
      <div id="selectedInfo" style="margin-bottom:1rem;font-weight:bold;font-size:1.1rem;display:none;">
        선택된 지역: <span id="displayRegion"></span> &nbsp; | &nbsp; 학교: <span id="displaySchool"></span>
      </div>
      <!-- Draft status & test controls -->
      <div id="draftControls" style="margin-bottom:0.8rem;display:flex;align-items:center;gap:10px;">
        <div id="draftStatus" style="font-size:0.95rem;color:#175;">드래프트 상태: 없음</div>
        <div style="margin-left:auto;display:flex;gap:8px;">
          <button type="button" id="forceSaveDraftBtn" style="padding:.4rem .6rem;border-radius:.5rem;border:1px solid #d6dbe8;background:#fff;cursor:pointer;">강제저장</button>
          <button type="button" id="forceLoadDraftBtn" style="padding:.4rem .6rem;border-radius:.5rem;border:1px solid #d6dbe8;background:#fff;cursor:pointer;">강제복원</button>
        </div>
      </div>
      <!-- hidden fields to submit selected region/school -->
      <input type="hidden" id="selectedRegionInput" name="region">
      <input type="hidden" id="selectedSchoolInput" name="schoolName">
      <!-- school metadata panel (Step2) -->
      <div id="schoolMeta" class="meta-card">
        <h4>학교 정보</h4>
        <div class="meta-summary">
          <div class="meta-pill" id="metaPillEstablish">설립: -</div>
          <div class="meta-pill" id="metaPillLevel">급: -</div>
          <div class="meta-pill" id="metaPillStudents">총학생수: -</div>
          <div class="meta-pill" id="metaPillFeature" style="display:none;">특성: -</div>
        </div>
        <div class="grade-rows">
          <div class="grade-row"><div class="grade-label">1학년:</div><div class="grade-value"><span id="metaG1c"></span> 학급 / <span id="metaG1s"></span> 학생</div></div>
          <div class="grade-row"><div class="grade-label">2학년:</div><div class="grade-value"><span id="metaG2c"></span> 학급 / <span id="metaG2s"></span> 학생</div></div>
          <div class="grade-row"><div class="grade-label">3학년:</div><div class="grade-value"><span id="metaG3c"></span> 학급 / <span id="metaG3s"></span> 학생</div></div>
        </div>
      <!-- NEIS timetable controls -->
      <div style="margin-top:12px;padding-top:8px;border-top:1px dashed #e6eefc;">
        <label style="font-weight:900;display:block;margin-bottom:6px;">시간표 가져오기 (NEIS)</label>
        <div style="display:flex;gap:.5rem;flex-wrap:wrap;align-items:center;">
          <select id="neisYear" style="padding:.45rem;border-radius:.5rem;border:1px solid #d6dbe8;"> 
            <option value="2025">2025</option>
            <option value="2024">2024</option>
            <option value="2023">2023</option>
          </select>
          <select id="neisSemester" style="padding:.45rem;border-radius:.5rem;border:1px solid #d6dbe8;">
            <option value="1">1학기</option>
            <option value="2" selected>2학기</option>
          </select>
          <button type="button" id="btnFetchSelectedTimetable" class="meeting-btn" style="margin-left:6px;">선택 학교 시간표 보기</button>
          <button type="button" id="btnCloseTimetable" class="meeting-btn" style="margin-left:6px;background:#fff;color:#12325a;border:1px solid #d6dbe8;display:none;">시간표 닫기</button>
        </div>
        <div id="timetableProgress" style="margin-top:8px;color:#175;display:none;font-size:13px;"></div>
        <div id="timetableContainer" style="margin-top:10px;"></div>

        <!-- 교육청 매핑 편집 UI 제거됨 -->
      </div>
      </div>
      <label for="visitStartHour">방문 시작 시간</label>
        <select id="visitStartHour" name="visitStartHour" aria-label="방문 시작 시"></select>
        <select id="visitStartMinute" name="visitStartMinute" aria-label="방문 시작 분"></select>
      <label for="visitDuration">총 방문 시간(분)</label>
      <div id="durationControls" style="margin-bottom:0.8rem;">
        <div id="durationButtons" class="btn-grid" style="grid-template-columns:repeat(5,1fr); gap:0.5rem;">
          <!-- buttons injected by JS -->
        </div>
        <div style="margin-top:0.6rem; display:flex; gap:0.6rem; align-items:center;">
          <input type="number" id="visitDuration" placeholder="예: 80" min="1" style="flex:1; padding:.8rem; border-radius:.8rem; border:1px solid #d6dbe8;" aria-label="총 방문 시간(분) 수동 입력">
          <button type="button" id="clearDuration" style="padding:.7rem 1rem; border-radius:.8rem; background:#f2f3f8; border:1px solid #d6dbe8; cursor:pointer;">지우기</button>
          <button type="button" id="getCurrentVisit" style="padding:.7rem 1rem; border-radius:.8rem; background:#eef7ff; border:1px solid #c6ddff; cursor:pointer; margin-left:4px;">가져오기</button>
        </div>
      </div>
      <input type="hidden" id="selectedDurationInput" name="durationMinutes">
  <label for="visitEnd" style="margin-top:0.6rem;">방문 종료 시간 <small style="font-weight:600;color:#40537a">(자동 계산됨)</small></label>
    <input type="text" id="visitEnd" name="visitEnd" readonly>
      <div id="subjectsBlock">
        <label>과목/선생님별 영업기록</label>
      </div>
      <button type="button" id="addSubjectBtn" style="width:100%;margin:0.5rem 0 1rem 0;padding:1rem;font-size:1.1rem;border-radius:1rem;background:#e3eafc;color:#1e3c72;font-weight:bold;border:none;cursor:pointer;">과목/선생님 추가</button>
      <!-- follow-up select is now per subject-block -->
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:0.6rem;margin-top:0.6rem;">
        <button type="button" id="backBtn" style="padding:1rem;border-radius:1rem;border:1px solid #d6dbe8;background:#fff;color:#1e3c72;font-weight:700;cursor:pointer;">뒤로 돌아가기</button>
        <button type="submit" class="btn-submit">입력 완료</button>
      </div>

      <!-- Canonical subject-block template for cloning (used by restore/add functions) -->
      <template id="subject-template">
        <div class="subject-block">
              <input type="hidden" class="subject-name" required>
              <div class="subjects" style="display:grid;grid-template-columns:repeat(7,1fr);gap:8px;margin-bottom:8px;">
                <button type="button" class="grid-button subject-choice" data-subject="정보">정보</button>
                <button type="button" class="grid-button subject-choice" data-subject="진로">진로</button>
                <button type="button" class="grid-button subject-choice" data-subject="보건">보건</button>
                <button type="button" class="grid-button subject-choice" data-subject="미술">미술</button>
                <button type="button" class="grid-button subject-choice" data-subject="체육">체육</button>
                <button type="button" class="grid-button subject-choice" data-subject="도서관사서">도서관사서</button>
                <button type="button" class="grid-button subject-choice" data-subject="특성화">특성화</button>
                <button type="button" class="grid-button subject-choice" data-subject="기타">기타</button>
              </div>
          <input type="text" class="teacher-name" placeholder="선생님 이름" required>
          <input type="text" class="teacher-location" placeholder="선생님 위치 (예: 1층 본교무실)" style="margin-top:8px;">
            <select class="publisher">
                <option value="">출판사 선택</option>
                <option>씨마스</option><option>천재</option><option>비상</option><option>미래엔</option><option>동아</option><option>지학사</option><option>금성</option><option>창비</option><option>해냄</option><option>능률</option><option>삼양</option><option>이오북스</option><option>YBM</option><option>길벗</option><option>미진사</option><option>다락원</option><option>타임</option><option>채움</option>
              </select>
              <div style="display:flex;gap:.5rem;align-items:center;margin-top:.5rem;">
                <label style="font-weight:700;min-width:38px;">연락처</label>
                    <div style="display:flex;gap:.5rem;align-items:center;margin-top:.5rem;">
                      <span style="display:inline-block;padding:.55rem .7rem;border-radius:.6rem;background:#f2f4ff;border:1px solid #d6dbe8;color:#12325a;font-weight:700;">010</span>
                      <input type="text" class="contact-suffix" placeholder="12345678" maxlength="8" inputmode="numeric" pattern="[0-9]*" aria-label="연락처 뒷자리 8자리 입력" style="width:120px;padding:.55rem .6rem;border-radius:.6rem;border:1px solid #d6dbe8;">
                      <input type="email" class="contact-email" placeholder="email@example.com" style="width:220px;padding:.55rem .6rem;border-radius:.6rem;border:1px solid #d6dbe8;margin-left:6px;"> 
                      <span class="contact-formatted" style="margin-left:8px;color:#103254;font-weight:700;"></span>
                      <button type="button" class="copy-contact" style="margin-left:6px;padding:.4rem .6rem;border-radius:.5rem;border:1px solid #d6dbe8;background:#fff;cursor:pointer;">복사</button>
                    </div>
              </div>
          <div style="margin-top:16px;"></div>
          <div class="meeting-buttons main-meeting-buttons">
            <button class="meeting-btn" type="button">명함인사</button>
            <button class="meeting-btn" type="button">티칭샘소개</button>
            <button class="meeting-btn" type="button">채팅방소개</button>
            <button class="meeting-btn" type="button">미팅불가</button>
            <button class="meeting-btn" type="button">포스터</button>
          </div>
          <div class="meeting-buttons info-extra-buttons" style="display:none;">
            <button class="meeting-btn" type="button">브로슈어</button>
            <button class="meeting-btn" type="button">가이드북</button>
            <button class="meeting-btn" type="button">구글클래스룸 사용</button>
            <button class="meeting-btn" type="button">패들렛 사용</button>
            <button class="meeting-btn" type="button">하이러닝 사용</button>
          </div>
          <textarea class="conversation-detail" rows="2" placeholder="특이사항"></textarea>
          <div style="margin-top:0.6rem;">
            <label style="font-weight:700;display:block;margin-bottom:6px;">후속조치</label>
            <select class="followUpSelect" style="width:100%;padding:.6rem;border-radius:.6rem;border:1px solid #d6dbe8;background:#fff;">
              <option value="">선택하세요</option>
              <option>채팅방 지속 관리</option>
              <option>추가 자료 발송 예정</option>
              <option>재방문 예정</option>
              <option>선정 시기 연락 대기</option>
              <option>워크북 무상지원 제안</option>
              <option>완료 (추가 조치 없음)</option>
            </select>
          </div>
          <button type="button" class="removeSubjectBtn" style="margin:0.5rem 0 1rem 0;padding:0.5rem 1rem;font-size:1rem;border-radius:0.7rem;background:#ff9800;color:#fff;border:none;cursor:pointer;">삭제</button>
        </div>
      </template>
      <script>
        // Ensure an initial subject-block exists by cloning the canonical template when the page is parsed.
        (function ensureInitialSubjectBlock(){
          try{
            const container = document.getElementById('subjectsBlock');
            if (!container) return;
            // if there are no subject-block children, clone the template
            if ((container.querySelectorAll('.subject-block') || []).length === 0) {
              const tpl = document.getElementById('subject-template');
              if (tpl && tpl.content) {
                const proto = tpl.content.querySelector('.subject-block');
                if (proto) {
                  const clone = proto.cloneNode(true);
                  container.appendChild(clone);
                  if (typeof renumberSubjectBlocks === 'function') renumberSubjectBlocks();
                }
              }
            }
          }catch(e){ console.warn('ensureInitialSubjectBlock failed', e); }
        })();
      </script>
      <div style="margin-top:1rem;">
        <div style="display:flex;gap:.5rem;margin-bottom:.5rem;align-items:center;">
          <div id="tagOptions" style="display:none;"> <!-- hidden: default/basic behavior applied -->
            <label style="font-size:13px;display:flex;align-items:center;gap:.4rem;"><input type="checkbox" id="optHumanLine" checked>한글 라인</label>
            <label style="font-size:13px;display:flex;align-items:center;gap:.4rem;"><input type="checkbox" id="optHashtags">해시태그 포함</label>
            <label style="font-size:13px;display:flex;align-items:center;gap:.4rem;">최대태그수 <input id="optMaxTags" type="number" min="1" max="20" value="8" style="width:56px;padding:.2rem .4rem;border-radius:.4rem;border:1px solid #d6dbe8;margin-left:.4rem;"></label>
          </div>
          <button type="button" id="copyKakaoBtn" style="flex:1;padding:.75rem;border-radius:1rem;border:1px solid #ffd9b3;background:#fff;color:#b25700;font-weight:800;">카톡으로 복사</button>
        </div>
        <div style="display:flex;gap:.5rem;margin-bottom:.5rem;">
          <button type="button" id="saveToServerBtn" style="flex:1;min-width:0;padding:.75rem;border-radius:1rem;border:1px solid #cfe8ff;background:#e9f4ff;color:#0b3a72;font-weight:800;">서버에 저장</button>
        </div>
        <div style="display:flex;gap:.5rem;align-items:center;margin-top:.6rem;">
          <button type="button" id="summaryEditToggleBtn" style="flex:1;min-width:0;padding:.6rem;border-radius:.6rem;border:1px solid #cfe8ff;background:#fff;color:#0b3a72;font-weight:800;">수정</button>
          <button type="button" id="summaryTempSaveBtn" style="flex:1;min-width:0;padding:.6rem;border-radius:.6rem;border:1px solid #d6dbe8;background:#fff;color:#0b3a72;font-weight:800;">임시저장</button>
          <button type="button" id="summaryRegenerateBtn" style="flex:1;min-width:0;padding:.6rem;border-radius:.6rem;border:1px solid #e6eefc;background:#f8fbff;color:#0b3a72;font-weight:700;">내용 전체지우기</button>
        </div>
        <div style="display:flex;flex-direction:column;gap:.5rem;">
          <div style="display:flex;align-items:center;gap:.6rem;">
            <button type="button" id="chooseCollectTimeBtn" style="padding:.5rem .8rem;border-radius:.6rem;border:1px solid #d6dbe8;background:#fff;color:#0b3a72;font-weight:700;">퇴근보고 시간 설정</button>
            <div id="collectTimeDisplay" style="font-size:13px;color:#3b4b63">기본: 퇴근 시각 기준 + 30분</div>
          </div>
          <input type="hidden" id="customCollectStart" value="">
          <input type="hidden" id="customCollectMinutes" value="30">
          <textarea id="generatedSummary" rows="10" readonly style="width:100%;margin-top:.6rem;padding:.8rem;border-radius:.8rem;border:1px solid #d6dbe8;display:block;">요약이 여기에 생성됩니다.</textarea>
        </div>
      </div>
    </form>
  </div>
  <style>
    .contact-invalid { border-color:#e05252 !important; box-shadow:0 4px 12px rgba(224,82,82,0.08); }
  </style>
  <script>
    // If the page is opened via file:// the browser will block fetch requests (origin=null).
    // Show a clear on-page message to the user instead of failing silently with CORS errors.
    // --- Multi-visit (dayVisits) support and summary templates ---
    const dayVisits = [];
    // 사용자 지정 퇴근보고 시간 설정
    let customCollectStart = '';
    let customCollectMinutes = 30;
    function updateCollectDisplay(){
      const el = document.getElementById('collectTimeDisplay'); if(!el) return;
      if (customCollectStart) el.textContent = `지정: ${customCollectStart} (+${customCollectMinutes}분)`;
      else el.textContent = `기본: 퇴근 시각 기준 + ${customCollectMinutes}분`;
    }
    document.addEventListener('click', function attachCollectBtn(){
      const btn = document.getElementById('chooseCollectTimeBtn'); if (!btn) return;
      if (btn.dataset._handlerAttached) return; btn.dataset._handlerAttached='1';
      btn.addEventListener('click', ()=>{
        const start = prompt('퇴근보고 시작 시간을 입력하세요 (HH:MM) — 비워두면 자동(퇴근시각) 사용됩니다.', customCollectStart || '');
        if (start === null) return;
        const cleaned = (start||'').trim();
        if (cleaned) {
          if (!/^\d{1,2}:\d{2}$/.test(cleaned)) { alert('형식이 잘못되었습니다. 예: 18:30'); return; }
          customCollectStart = cleaned;
        } else { customCollectStart = ''; }
        const minStr = prompt('정리 소요 시간(분)을 입력하세요 (기본 30):', String(customCollectMinutes));
        if (minStr === null) { updateCollectDisplay(); return; }
        const mins = parseInt((minStr||'').replace(/[^0-9]/g,''),10);
        customCollectMinutes = isNaN(mins) || mins <= 0 ? 30 : mins;
        const hi = document.getElementById('customCollectStart'); if (hi) hi.value = customCollectStart;
        const hm = document.getElementById('customCollectMinutes'); if (hm) hm.value = String(customCollectMinutes);
        updateCollectDisplay();
      });
    });
  // whether the user has manually edited the generated summary textarea
  let manualSummaryEdited = false;
  // internal flag: when true, programmatic writes to the summary should not be treated as user edits
  let _suppressSummaryInputHandler = false;

  // Feature flag: prevent automatic advancement to step2 on page load.
  // Set to true only if you intentionally want pages to auto-advance.
  const ALLOW_AUTO_ADVANCE = false;

  // small utility: pad numbers to 2 digits. Defined early so other functions can use it.
    function pad2(n){
      const num = parseInt(n,10);
      if (isNaN(num)) return '00';
      return (num < 10 ? '0' : '') + String(num);
    }

    function buildCurrentVisitObject() {
      // capture top-level visit info
      const visitDate = (document.getElementById('visitDate') || {}).value || '';
      const staff = (document.getElementById('staffName') || {}).value || '';
  const region = (document.querySelector('#regionButtons .grid-button[aria-selected="true"]') || {}).dataset?.region || '';
  const schoolBtn = document.querySelector('#schoolButtons .grid-button[aria-selected="true"]');
  const school = schoolBtn ? (schoolBtn.dataset.school || schoolBtn.textContent.trim()) : '';
      const meta = {};
      const est = document.getElementById('metaPillEstablish'); if (est) meta.establish = est.textContent || '';
      const level = document.getElementById('metaPillLevel'); if (level) meta.level = level.textContent || '';
      const g1 = document.getElementById('metaG1c'); if (g1) meta.g1 = g1.textContent || '';

      // default start to current time rounded to 5 minutes if user didn't change selects
      const now = new Date();
      let defaultHour = now.getHours();
      let defaultMin = Math.round(now.getMinutes() / 5) * 5; if (defaultMin >= 60) { defaultMin = 55; }
      const startHour = (document.getElementById('visitStartHour')||{}).value || pad2(defaultHour);
      const startMinute = (document.getElementById('visitStartMinute')||{}).value || pad2(defaultMin);
      const visitStart = `${pad2(startHour)}:${pad2(startMinute)}`;
      let visitEnd = (document.getElementById('visitEnd')||{}).value || '';
      // if no explicit visitEnd but a duration is provided, compute end time
      const explicitDuration = Number((document.getElementById('selectedDurationInput')||{}).value || (document.getElementById('visitDuration')||{}).value || 0);
      if ((!visitEnd || visitEnd === '') && explicitDuration > 0){
        try{
          const sh = parseInt(startHour,10)||0; const sm = parseInt(startMinute,10)||0;
          let total = sh*60 + sm + Number(explicitDuration);
          total = ((total % (24*60)) + (24*60)) % (24*60);
          const eh = Math.floor(total/60); const em = total % 60;
          visitEnd = pad2(eh) + ':' + pad2(em);
        }catch(e){ /* ignore computation errors */ }
      }

      // subjects
      const subjectBlocks = Array.from(document.querySelectorAll('#subjectsBlock .subject-block'));
      const subjects = subjectBlocks.map((blk)=>{
        const subj = (blk.querySelector('.subject-name')||{}).value || '';
        const teacher = (blk.querySelector('.teacher-name')||{}).value || '';
        const teacherLocation = (blk.querySelector('.teacher-location')||{}).value || '';
        const publisher = (blk.querySelector('.publisher')||{}).value || '';
        const conv = (blk.querySelector('.conversation-detail')||{}).value || '';
        const followUp = (blk.querySelector('.followUpSelect')||{}).value || '';
        const contactSuffix = (blk.querySelector('.contact-suffix')||{}).value || '';
        const contactEmail = (blk.querySelector('.contact-email')||{}).value || '';
        const contact = contactSuffix ? `010-${contactSuffix.slice(0,4)}-${contactSuffix.slice(4)}` : '';
        const meetings = Array.from(blk.querySelectorAll('.meeting-btn.selected')).map(b=>b.dataset.value||b.textContent.trim());
        return { subject:subj, teacher, teacherLocation, publisher, conversation:conv, followUp, contact, contactEmail, meetings };
      });

      return { visitDate, staff, region, school, meta, visitStart, visitEnd, duration: explicitDuration, subjects };
    }

    // --- Inline field error helpers ---
    function showFieldError(el, msg) {
      try {
        if (!el) return;
      document.querySelectorAll('#regionButtons .grid-button.selected').forEach(b=>b.classList.remove('selected'));
      document.querySelectorAll('#schoolButtons .grid-button.selected').forEach(b=>b.classList.remove('selected'));
      document.getElementById('selectedRegionInput').value = '';
      document.getElementById('selectedSchoolInput').value = '';
      document.getElementById('displayRegion').textContent = '';
      document.getElementById('displaySchool').textContent = '';
      document.getElementById('selectedInfo').style.display = 'none';
      // reset subject blocks: but if a draft exists for this date, preserve it
      const container = document.getElementById('subjectsBlock');
      try{
        const visitDate = (document.getElementById('visitDate')||{}).value || '';
        if (visitDate){ const draft = loadDraftForDate(visitDate); if (draft && Array.isArray(draft.subjects) && draft.subjects.length){ /* preserve draft subjects */ return; } }
      }catch(e){}
      // Use canonical template instead of injecting raw HTML to avoid duplication.
      container.innerHTML = '<label>과목/선생님별 영업기록</label>';
      try {
        const tpl = document.getElementById('subject-template');
        if (tpl && tpl.content) {
          const proto = tpl.content.querySelector('.subject-block');
          if (proto) {
            const clone = proto.cloneNode(true);
            // ensure remove button wired
            try {
              let rem = clone.querySelector('.removeSubjectBtn');
              if (!rem) {
                rem = document.createElement('button'); rem.type = 'button'; rem.className = 'removeSubjectBtn'; rem.textContent = '삭제'; rem.style = 'margin:0.5rem 0 1rem 0;padding:0.5rem 1rem;font-size:1rem;border-radius:0.7rem;background:#ff9800;color:#fff;border:none;cursor:pointer;';
                clone.appendChild(rem);
              }
              rem.onclick = function(){ clone.remove(); if(typeof renumberSubjectBlocks==='function') renumberSubjectBlocks(); };
            }catch(e){}
            container.appendChild(clone);
          }
        }
      }catch(e){ console.warn('showFieldError template clone failed', e); }
      if (typeof renumberSubjectBlocks === 'function') renumberSubjectBlocks();
      }catch(e){ console.warn('showFieldError failed', e); }
    }
    // utility: show current visit JSON and copy to clipboard
    function showCurrentVisitData(){
      try{
        const v = buildCurrentVisitObject();
        const pretty = JSON.stringify(v, null, 2);
        // try clipboard first, fallback to prompt for manual copy
        if (navigator.clipboard && navigator.clipboard.writeText){
          navigator.clipboard.writeText(pretty).then(()=>{
            const _msg = '현재 입력값이 클립보드에 복사되었습니다.\n\n' + pretty;
            alert(_msg);
          }).catch(()=>{
            // if writeText fails, show prompt with the JSON
            prompt('복사에 실패했습니다. 아래 내용을 수동으로 복사하세요:', pretty);
          });
        } else {
          prompt('클립보드 API를 지원하지 않습니다. 아래 내용을 복사하세요:', pretty);
        }
        console.log('Current visit object:', v);
      }catch(err){
        console.error('showCurrentVisitData error', err);
        alert('입력값을 가져오는 중 오류가 발생했습니다. 콘솔을 확인하세요.');
      }
    }

    document.addEventListener('DOMContentLoaded', ()=>{
      const btn = document.getElementById('getCurrentVisit');
      if (btn) btn.addEventListener('click', ()=>{
        try{
          if (typeof window.showCurrentVisitData === 'function') {
            window.showCurrentVisitData();
          } else {
            console.warn('showCurrentVisitData not defined yet');
            alert('기능 로드가 완료되지 않았습니다. 새로고침 후 다시 시도하세요.');
          }
        }catch(e){ console.error(e); alert('함수 실행 중 오류가 발생했습니다. 콘솔을 확인하세요.'); }
      });
    });

    // --- Enhanced fuzzy/tokenized/pronunciation-insensitive search for region and school buttons ---
    (function attachSearchFilter(){
      try{
        const search = document.getElementById('searchInput');
        const clearBtn = document.getElementById('searchClear');
        const regionContainer = document.getElementById('regionButtons');
        const schoolContainer = document.getElementById('schoolButtons');
        if(!search || !regionContainer || !schoolContainer) return;

        // remove diacritics, normalize unicode and lower
        function removeDiacritics(str){
          try{ return str.normalize('NFKD').replace(/\p{M}/gu,''); }catch(e){ return str; }
        }

        // Hangul syllable decomposition to cho/jung/jong indices (used to make matching pronunciation-insensitive)
        const CHO = ["ㄱ","ㄲ","ㄴ","ㄷ","ㄸ","ㄹ","ㅁ","ㅂ","ㅃ","ㅅ","ㅆ","ㅇ","ㅈ","ㅉ","ㅊ","ㅋ","ㅌ","ㅍ","ㅎ"];
        const JUNG = ["ㅏ","ㅐ","ㅑ","ㅒ","ㅓ","ㅔ","ㅕ","ㅖ","ㅗ","ㅘ","ㅙ","ㅚ","ㅛ","ㅜ","ㅝ","ㅞ","ㅟ","ㅠ","ㅡ","ㅢ","ㅣ"];
        const JONG = ["","ㄱ","ㄲ","ㄳ","ㄴ","ㄵ","ㄶ","ㄷ","ㄹ","ㄺ","ㄻ","ㄼ","ㄽ","ㄾ","ㄿ","ㅀ","ㅁ","ㅂ","ㅄ","ㅅ","ㅆ","ㅇ","ㅈ","ㅊ","ㅋ","ㅌ","ㅍ","ㅎ"];
        function hangulToJamoKey(s){
          let out = '';
          for (let ch of s){
            const code = ch.charCodeAt(0);
            if (code >= 0xAC00 && code <= 0xD7A3){
              const SIndex = code - 0xAC00;
              const cho = Math.floor(SIndex / (21*28));
              const jung = Math.floor((SIndex % (21*28)) / 28);
              const jong = SIndex % 28;
              out += 'C'+cho+'V'+jung+'T'+jong+'|';
            } else {
              out += ch;
            }
          }
          return out;
        }

        // simple tokenization: split on whitespace/punct and also produce trigrams
        function tokenize(str){
          const s = removeDiacritics(String(str||'')).toLowerCase();
          const rawTokens = s.split(/[^\p{L}\p{N}]+/u).filter(Boolean);
          const tokens = [];
          rawTokens.forEach(t=>{
            tokens.push(t);
            // trigrams for short fuzzy matching
            const n = 3;
            if (t.length > n){
              for (let i=0;i<=t.length-n;i++){ tokens.push(t.slice(i,i+n)); }
            }
          });
          return tokens;
        }

        // Levenshtein distance
        function levenshtein(a,b){
          if(a===b) return 0;
          a = a || '';
          b = b || '';
          const m = a.length, n = b.length;
          if(m===0) return n; if(n===0) return m;
          let v0 = new Array(n+1), v1 = new Array(n+1);
          for(let j=0;j<=n;j++) v0[j]=j;
          for(let i=0;i<m;i++){
            v1[0]=i+1;
            for(let j=0;j<n;j++){
              const cost = a[i]===b[j] ? 0 : 1;
              v1[j+1] = Math.min(v1[j]+1, v0[j+1]+1, v0[j]+cost);
            }
            const tmp=v0; v0=v1; v1=tmp;
          }
          return v0[n];
        }

        // Build an index for buttons to speed matching (runs lazily when lists change)
        function buildIndex(container){
          const items = Array.from(container.querySelectorAll('.grid-button'));
          return items.map(b=>{
            const raw = (b.textContent || b.dataset.value || '').trim();
            const base = removeDiacritics(raw).toLowerCase();
            const jamo = hangulToJamoKey(raw);
            const tokens = tokenize(raw);
            return { el: b, raw, base, jamo, tokens };
          });
        }

        let regionIndex = buildIndex(regionContainer);
        let schoolIndex = buildIndex(schoolContainer);

        // If DOM changes, rebuild indexes
        const rebuild = ()=>{ regionIndex = buildIndex(regionContainer); schoolIndex = buildIndex(schoolContainer); };

        function candidateScore(queryTokens, qJamo, cand){
          // quick exact substring check
          const qJoined = queryTokens.join(' ');
          if (cand.base.indexOf(qJoined) !== -1) return 1.0;
          // token overlap
          let overlap = 0;
          for (let qt of queryTokens){
            for (let ct of cand.tokens){ if (ct.indexOf(qt) !== -1 || qt.indexOf(ct)!==-1) { overlap++; break; } }
          }
          const overlapRatio = overlap / Math.max(1, queryTokens.length);
          // jamo similarity (for Hangul phonetic matching)
          let jamoScore = 0;
          try{
            const lev = levenshtein(qJamo, cand.jamo);
            const maxL = Math.max(qJamo.length, cand.jamo.length);
            jamoScore = maxL ? 1 - (lev / maxL) : 0;
          }catch(e){ jamoScore = 0; }
          // fallback fuzzy on joined strings
          const lev2 = levenshtein(qJoined, cand.base);
          const levScore = 1 - (lev2 / Math.max(1, Math.max(qJoined.length, cand.base.length)));
          // combine scores (weights favor token overlap and jamo for Korean)
          const score = Math.max(overlapRatio, levScore*0.9, jamoScore*0.95);
          return Math.max(0, Math.min(1, score));
        }

        function filterLists(){
          const rawQ = String(search.value || '').trim();
          if (!rawQ){
            regionIndex.forEach(i=>i.el.style.display='');
            schoolIndex.forEach(i=>i.el.style.display='');
            return;
          }
          // If no school buttons are present yet (user hasn't selected a region),
          // offer inline school matches by populating schoolButtons from staffData
          // where either the school name or region contains the query string.
          try{
            const existing = Array.from(schoolContainer.querySelectorAll('.grid-button')).map(x=> (x.dataset.school||x.textContent||'').trim());
            // If DOM contains buttons but they're all hidden, treat as 'no visible buttons' and populate from staffData.
            const visibleSchoolButtons = Array.from(schoolContainer.querySelectorAll('.grid-button')).filter(b => {
              try { return b.offsetParent !== null && getComputedStyle(b).display !== 'none'; } catch(e) { return true; }
            });
            if ((visibleSchoolButtons.length === 0) && window.staffData && Array.isArray(window.staffData) && rawQ.length){
              const qLow = rawQ.toLowerCase();
              const matched = [...new Set(window.staffData.filter(d => {
                try{ const s = (d.school||'').toString().toLowerCase(); const r = (d.region||'').toString().toLowerCase(); return (s && s.indexOf(qLow) !== -1) || (r && r.indexOf(qLow) !== -1); }catch(e){ return false; }
              }).map(d=>d.school).filter(Boolean))];
              // only populate if we found matches
              if (matched.length){
                schoolContainer.innerHTML = '';
                matched.forEach(sch => {
                  const sb = document.createElement('button'); sb.type='button'; sb.className='grid-button'; sb.dataset.school = sch; sb.setAttribute('role','option'); sb.setAttribute('aria-selected','false'); sb.tabIndex = 0; sb.textContent = sch; sb.title = sch; schoolContainer.appendChild(sb);
                });
                // rebuild index to include newly injected buttons
                rebuild();
              }
            }
          }catch(e){ console.warn('inline school populate failed', e); }
          // tokenize query and also create jamo key
          const queryTokens = tokenize(rawQ);
          const qJamo = hangulToJamoKey(rawQ);
          // threshold can be tuned; lower for broader matches
          const THRESH = 0.45;

          regionIndex.forEach(cand=>{
            const sc = candidateScore(queryTokens, qJamo, cand);
            cand.el.style.display = sc >= THRESH ? '' : 'none';
          });
          schoolIndex.forEach(cand=>{
            const sc = candidateScore(queryTokens, qJamo, cand);
            cand.el.style.display = sc >= THRESH ? '' : 'none';
          });
        }

        // wire events
        search.addEventListener('input', filterLists);
        clearBtn.addEventListener('click', ()=>{ search.value=''; search.dispatchEvent(new Event('input')); search.focus(); });

        // observe list changes and rebuild indexes + reapply filter
        const observer = new MutationObserver(()=>{ try{ rebuild(); filterLists(); }catch(e){/*ignore*/} });
        observer.observe(regionContainer, { childList: true, subtree: true });
        observer.observe(schoolContainer, { childList: true, subtree: true });
      }catch(e){ console.warn('attachSearchFilter failed', e); }
    })();

    function renderVisitsList() {
      const el = document.getElementById('visitsList');
      if (!el) return;
      el.innerHTML = '';
      if (dayVisits.length === 0) { el.innerHTML = '<div style="color:#666;padding:.6rem;">추가된 방문이 없습니다.</div>'; return; }
      // render stacked cards (chronological)
      dayVisits.forEach((v, idx) => {
        const card = document.createElement('div');
        card.className = 'visit-card';
        card.style = 'border-radius:8px;border:1px solid #e6eefc;background:#fff;padding:.8rem;margin-bottom:8px;';
        const header = document.createElement('div');
        header.style = 'display:flex;justify-content:space-between;align-items:center;gap:.6rem;';
        const title = document.createElement('div');
        title.innerHTML = `<strong>${idx+1}. ${v.school || '학교 미선택'}</strong><div style="font-size:12px;color:#556">${v.visitDate || ''} ${v.visitStart || ''} ~ ${v.visitEnd || ''}</div>`;
        const actions = document.createElement('div');
        const editBtn = document.createElement('button'); editBtn.textContent='편집'; editBtn.style='margin-right:6px;padding:.3rem .6rem;border-radius:.5rem;'; editBtn.addEventListener('click',()=>loadVisitToForm(idx));
        const removeBtn = document.createElement('button'); removeBtn.textContent='제거'; removeBtn.style='padding:.3rem .6rem;border-radius:.5rem;color:#c33;'; removeBtn.addEventListener('click',()=>{ if(editingVisitIndex===idx) resetEditState(); dayVisits.splice(idx,1); renderVisitsList(); });
        actions.appendChild(editBtn); actions.appendChild(removeBtn);
        header.appendChild(title); header.appendChild(actions);
        card.appendChild(header);
        // brief subjects summary
        if (v.subjects && v.subjects.length) {
          const ul = document.createElement('div'); ul.style='margin-top:.6rem;font-size:13px;color:#233';
          v.subjects.forEach(s=>{
            const line = document.createElement('div'); line.textContent = `${s.subject || '-'} ${s.teacher? '('+s.teacher+')':''} ${s.contact? '· '+s.contact : ''}`;
            ul.appendChild(line);
          });
          card.appendChild(ul);
        }
        el.appendChild(card);
      });
      // auto-scroll to bottom so latest added visit is visible
      el.scrollTop = el.scrollHeight;
    }

    function resetFormForNextVisit() {
      // keep visitDate and staffInfo, clear region/school selection and subject blocks (leave one blank block)
      // If a draft exists for the current date/region/school/staff, preserve the form so the draft remains visible to the user.
      try{
        const vd = document.getElementById('visitDate');
        const todayDate = vd ? (vd.value || '') : '';
        if (todayDate) {
          const existingDraft = loadDraftForDate(todayDate);
          if (existingDraft) {
            try{ showToast('저장된 드래프트가 있어 폼을 유지합니다.', 1800); }catch(e){}
            return; // do not clear the current form when a draft exists
          }
        }
      }catch(e){ /* ignore draft-check errors and continue to reset */ }
      // clear region/school UI selection
      document.querySelectorAll('#regionButtons .grid-button.selected').forEach(b=>b.classList.remove('selected'));
      document.querySelectorAll('#schoolButtons .grid-button.selected').forEach(b=>b.classList.remove('selected'));
      document.getElementById('selectedRegionInput').value = '';
      document.getElementById('selectedSchoolInput').value = '';
      document.getElementById('displayRegion').textContent = '';
      document.getElementById('displaySchool').textContent = '';
      document.getElementById('selectedInfo').style.display = 'none';
  const container = document.getElementById('subjectsBlock');
  if (container) {
    // keep a single blank canonical block by cloning the template
    container.innerHTML = '<label>과목/선생님별 영업기록</label>';
    try {
      const tpl = document.getElementById('subject-template');
      if (tpl && tpl.content) {
        const clone = tpl.content.querySelector('.subject-block').cloneNode(true);
        // ensure remove button wired
        try {
          let rem = clone.querySelector('.removeSubjectBtn');
          if (!rem) {
            rem = document.createElement('button'); rem.type='button'; rem.className='removeSubjectBtn'; rem.textContent='삭제'; rem.style='margin:0.5rem 0 1rem 0;padding:0.5rem 1rem;font-size:1rem;border-radius:0.7rem;background:#ff9800;color:#fff;border:none;cursor:pointer;';
            clone.appendChild(rem);
          }
          rem.onclick = function(){ clone.remove(); if(typeof renumberSubjectBlocks==='function') renumberSubjectBlocks(); };
        }catch(e){}
        container.appendChild(clone);
      } else {
        // fallback: leave container empty label
      }
    }catch(e){ console.warn('resetFormForNextVisit template clone failed', e); }
  }
  if (typeof renumberSubjectBlocks === 'function') renumberSubjectBlocks();
      // if user enabled auto-focus, focus the first region button (or school if region already selected)
      setTimeout(()=>{
        try{
          const auto = document.getElementById('autoFocusNext');
          if (auto && auto.checked) {
            const regionFirst = document.querySelector('#regionButtons .grid-button');
            const schoolFirst = document.querySelector('#schoolButtons .grid-button');
            if (regionFirst) { regionFirst.focus(); }
            else if (schoolFirst) { schoolFirst.focus(); }
          }
        }catch(e){/* ignore focus errors */}
      },60);
    }

    let editingVisitIndex = -1; // -1 means not editing

    function resetEditState() {
      editingVisitIndex = -1;
      const addBtn = document.getElementById('addVisitBtn'); if (addBtn) addBtn.textContent = '오늘 방문에 추가';
      renderVisitsList();
    }

  async function loadVisitToForm(idx) {
      const v = dayVisits[idx];
      if (!v) return;
      // populate top-level
      if (v.visitDate) {
        const vdEl = document.getElementById('visitDate') || null;
        try{
          const s = String(v.visitDate || '').trim();
          let norm = '';
          if (/^\d{4}-\d{2}-\d{2}$/.test(s)) norm = s;
          else {
            const m = s.match(/^(\d{4}-\d{2}-\d{2})T/);
            if (m && m[1]) norm = m[1];
            else { const d = new Date(s); if (!isNaN(d.getTime())) norm = d.toISOString().slice(0,10); }
          }
          if (vdEl) vdEl.value = norm || '';
        }catch(e){}
      }
      if (v.visitStart) {
        const [hh, mm] = v.visitStart.split(':');
        if (document.getElementById('visitStartHour')) document.getElementById('visitStartHour').value = hh;
        if (document.getElementById('visitStartMinute')) document.getElementById('visitStartMinute').value = mm;
      }
      if (v.visitEnd) (document.getElementById('visitEnd')||{}).value = v.visitEnd;
      // select region and school buttons if possible
      if (v.region) {
        const regionBtn = Array.from(document.querySelectorAll('#regionButtons .grid-button')).find(b=>b.textContent.trim()===v.region || b.dataset.region===v.region);
        if (regionBtn) regionBtn.click();
      }
      if (v.school) {
        // small delay to allow schools populated after region click
        setTimeout(()=>{
          const schoolBtn = Array.from(document.querySelectorAll('#schoolButtons .grid-button')).find(b=>b.textContent.trim()===v.school || b.dataset.school===v.school);
          if (schoolBtn) schoolBtn.click();
        }, 120);
      }
      // clear existing subject blocks and rebuild from v.subjects (use template cloning to preserve canonical markup & handlers)
      const container = document.getElementById('subjectsBlock'); if (!container) return;
      // try to find an existing canonical .subject-block in the page (usually created by reset); if not, build a temporary template
      let template = container.querySelector('.subject-block');
      if (!template) {
        // Use helper that prefers canonical <template id="subject-template"> and otherwise builds a single programmatic fallback
        template = getSubjectBlockTemplateNode();
      }
      // clear container but keep canonical template in-memory; then clone for each subject so we preserve full markup
      container.innerHTML = '<label>과목/선생님별 영업기록</label>';
      (v.subjects||[]).forEach(s => {
        const block = template.cloneNode(true);
        block.className = 'subject-block';
        // populate values
        if (s.subject) {
          block.querySelector('.subject-name').value = s.subject;
          const subjectBtn = Array.from(block.querySelectorAll('.subject-choice')).find(b=>b.dataset.subject===s.subject || b.textContent.trim()===s.subject);
          if (subjectBtn) subjectBtn.classList.add('selected');
        }
        if (s.teacher) block.querySelector('.teacher-name').value = s.teacher;
        if (s.publisher) block.querySelector('.publisher').value = s.publisher;
        if (s.followUp) block.querySelector('.followUpSelect').value = s.followUp;
        if (s.contact) {
          // extract suffix digits from format like 010-1234-5678
          const digits = (s.contact || '').replace(/\D+/g,'');
          if (digits.length === 11) block.querySelector('.contact-suffix').value = digits.slice(3);
        }
        if (s.conversation) block.querySelector('.conversation-detail').value = s.conversation;
        // meetings selection
        setTimeout(()=>{
          if (s.meetings && s.meetings.length) {
            Array.from(block.querySelectorAll('.meeting-btn')).forEach(btn=>{
              if (s.meetings.includes(btn.textContent.trim())) btn.classList.add('selected');
            });
          }
        }, 10);
        // ensure remove button exists and is wired (guard against templates that omit it)
        try {
          let remBtn = block.querySelector('.removeSubjectBtn');
          if (!remBtn) {
            remBtn = document.createElement('button');
            remBtn.type = 'button';
            remBtn.className = 'removeSubjectBtn';
            remBtn.style = 'margin:0.5rem 0 1rem 0;padding:0.5rem 1rem;font-size:1rem;border-radius:0.7rem;background:#ff9800;color:#fff;border:none;cursor:pointer;';
            remBtn.textContent = '삭제';
            block.appendChild(remBtn);
          }
          remBtn.onclick = function(){ block.remove(); if(typeof renumberSubjectBlocks==='function') renumberSubjectBlocks(); };
        } catch(e) { /* non-fatal */ }
        container.appendChild(block);
      });
      // renumber and show edit UI
      if (typeof renumberSubjectBlocks === 'function') renumberSubjectBlocks();
      editingVisitIndex = idx;
      const addBtn = document.getElementById('addVisitBtn'); if (addBtn) addBtn.textContent = '편집사항 저장';
      renderVisitsList();
    }

    // Helper: return a subject-block Element to be used as a template source.
    // Prefer the canonical <template id="subject-template"> if present; otherwise build a compact fallback element.
    function getSubjectBlockTemplateNode() {
      try {
        const tplEl = document.getElementById('subject-template');
        if (tplEl && tplEl.content) {
          const node = tplEl.content.querySelector('.subject-block');
          if (node) return node;
        }
      } catch (e) { /* ignore and fall through to programmatic builder */ }

      // Programmatic fallback: build DOM nodes to avoid HTML string duplication
      const block = document.createElement('div');
      block.className = 'subject-block';

      const hidden = document.createElement('input');
      hidden.type = 'hidden'; hidden.className = 'subject-name'; hidden.required = true;
      block.appendChild(hidden);

      const subjectsDiv = document.createElement('div');
      subjectsDiv.className = 'subjects';
      subjectsDiv.style.cssText = 'display:grid;grid-template-columns:repeat(7,1fr);gap:8px;margin-bottom:8px;';
      const btn = document.createElement('button');
      btn.type = 'button'; btn.className = 'grid-button subject-choice'; btn.dataset.subject = '기타'; btn.textContent = '기타';
      subjectsDiv.appendChild(btn);
      block.appendChild(subjectsDiv);

      const teacherInput = document.createElement('input');
      teacherInput.type = 'text'; teacherInput.className = 'teacher-name'; teacherInput.placeholder = '선생님 이름'; teacherInput.required = true;
      block.appendChild(teacherInput);

      const publisher = document.createElement('select'); publisher.className = 'publisher';
      const opt = document.createElement('option'); opt.value = ''; opt.textContent = '출판사 선택'; publisher.appendChild(opt);
      block.appendChild(publisher);

      const followWrap = document.createElement('div'); followWrap.style.marginTop = '0.6rem';
      const followLabel = document.createElement('label'); followLabel.style.cssText = 'font-weight:700;display:block;margin-bottom:6px;'; followLabel.textContent = '후속조치';
      followWrap.appendChild(followLabel);
      const followSel = document.createElement('select'); followSel.className = 'followUpSelect'; followSel.style.cssText = 'width:100%;padding:.6rem;border-radius:.6rem;border:1px solid #d6dbe8;background:#fff;';
      const fopt = document.createElement('option'); fopt.value = ''; fopt.textContent = '선택하세요'; followSel.appendChild(fopt);
      followWrap.appendChild(followSel);
      block.appendChild(followWrap);

      const contactRow = document.createElement('div'); contactRow.style.cssText = 'display:flex;gap:.5rem;align-items:center;margin-top:.5rem;';
      const contactLabel = document.createElement('label'); contactLabel.style.cssText = 'font-weight:700;min-width:38px;'; contactLabel.textContent = '연락처';
      contactRow.appendChild(contactLabel);
      const contactInner = document.createElement('div'); contactInner.style.cssText = 'display:flex;gap:.5rem;align-items:center;margin-top:.5rem;';
      const spanPref = document.createElement('span'); spanPref.style.cssText = 'display:inline-block;padding:.55rem .7rem;border-radius:.6rem;background:#f2f4ff;border:1px solid #d6dbe8;color:#12325a;font-weight:700;'; spanPref.textContent = '010';
      const contactInput = document.createElement('input'); contactInput.type = 'text'; contactInput.className = 'contact-suffix'; contactInput.placeholder = '12345678'; contactInput.maxLength = 8; contactInput.inputMode = 'numeric'; contactInput.pattern = '[0-9]*'; contactInput.style.width = '120px'; contactInput.style.padding = '.55rem .6rem'; contactInput.style.borderRadius = '.6rem'; contactInput.style.border = '1px solid #d6dbe8';
      const contactFmt = document.createElement('span'); contactFmt.className = 'contact-formatted'; contactFmt.style.cssText = 'margin-left:8px;color:#103254;font-weight:700;';
      contactInner.appendChild(spanPref); contactInner.appendChild(contactInput); contactInner.appendChild(contactFmt);
      contactRow.appendChild(contactInner);
      block.appendChild(contactRow);

      const spacer = document.createElement('div'); spacer.style.marginTop = '16px'; block.appendChild(spacer);

      const meetings = document.createElement('div'); meetings.className = 'meeting-buttons'; meetings.id = 'main-meeting-buttons';
      ['명함인사','티칭샘소개','채팅방소개','미팅불가'].forEach(text => { const b = document.createElement('button'); b.className='meeting-btn'; b.type='button'; b.textContent = text; meetings.appendChild(b); });
      block.appendChild(meetings);

      const ta = document.createElement('textarea'); ta.className = 'conversation-detail'; ta.rows = 2; ta.placeholder = '특이사항'; block.appendChild(ta);

      return block;
    }

    document.getElementById('addVisitBtn')?.addEventListener('click',()=>{
      const v = buildCurrentVisitObject();
      // 방문일 필수
      if (!v.visitDate) { alert('방문일을 선택한 뒤 방문을 추가하세요.'); const vd = document.getElementById('visitDate'); vd && vd.focus(); return; }
      // basic validation: must have school
      if (!v.school) { alert('학교를 선택한 뒤 추가하세요.'); return; }
      if (editingVisitIndex >= 0) {
        dayVisits[editingVisitIndex] = v;
        resetEditState();
        renderVisitsList();
      } else {
        dayVisits.push(v);
        renderVisitsList();
        // NOTE: Do NOT clear drafts on commit — drafts persist per visitDate+region+school+staff
        // prepare form for next visit
        resetFormForNextVisit();
      }
    });

      // wire draft autosave listeners and visitDate change restore (non-destructive)
      document.addEventListener('DOMContentLoaded', ()=>{
        try{
          const sf = document.getElementById('salesForm');
          if (sf) { sf.addEventListener('input', saveDraftDebounced); sf.addEventListener('change', saveDraftDebounced); }
          const sb = document.getElementById('subjectsBlock');
          if (sb) { sb.addEventListener('input', saveDraftDebounced); sb.addEventListener('change', saveDraftDebounced); }
          const vd = document.getElementById('visitDate');
          if (vd) vd.addEventListener('change', ()=>{ const d = vd.value; if (!d) return; const draft = loadDraftForDate(d); if (draft) { populateFormFromVisit(draft); } else { loadSavedForDate(d); } try{ if (typeof updateDraftStatus === 'function') updateDraftStatus(); }catch(e){} });
          // also save draft on beforeunload
          window.addEventListener('beforeunload', saveDraftForDate);
          // wire force save/restore buttons for testing
          const fsb = document.getElementById('forceSaveDraftBtn'); if (fsb) fsb.addEventListener('click', ()=>{ try{ saveDraftForDate(); alert('강제 저장 완료'); }catch(e){ alert('저장 실패: '+e.message); } });
          const frb = document.getElementById('forceLoadDraftBtn'); if (frb) frb.addEventListener('click', ()=>{ try{ const d = (document.getElementById('visitDate')||{}).value || ''; if (!d) { alert('먼저 방문일을 선택하세요'); return; } const draft = loadDraftForDate(d); if (draft) { populateFormFromVisit(draft); updateDraftStatus(); alert('드래프트 복원 완료'); } else { alert('복원할 드래프트가 없습니다'); } }catch(e){ alert('복원 실패: '+e.message); } });
          // initial draft status update
          try{ setTimeout(()=>{ updateDraftStatus(); }, 120); }catch(e){}
        }catch(e){/* ignore */}
      });

    // copy to clipboard helper
    async function copyToClipboard(text) {
      if (navigator.clipboard && navigator.clipboard.writeText) {
        try { await navigator.clipboard.writeText(text); return true; } catch(e){ /* fallthrough */ }
      }
      // fallback
      const ta = document.createElement('textarea'); ta.value = text; document.body.appendChild(ta); ta.select();
      try { document.execCommand('copy'); document.body.removeChild(ta); return true; } catch(e){ document.body.removeChild(ta); return false; }
    }

    document.getElementById('copySummaryBtn')?.addEventListener('click', async ()=>{
      const txt = (document.getElementById('generatedSummary')||{}).value || '';
      if (!txt) { alert('복사할 요약이 없습니다. 먼저 요약을 생성하세요.'); return; }
      const ok = await copyToClipboard(txt);
      if (ok) { alert('요약이 클립보드에 복사되었습니다.'); } else { alert('복사에 실패했습니다. 수동으로 복사해주세요.'); }
    });

    // One-click: build kakao template from dayVisits (require at least one visit) and copy to clipboard
    // Build simple auto-tags from visits and return array of tags (Korean)
    // buildAutoTags(visits, maxTags)
    // returns an array of human-readable tag strings (Korean)
    function buildAutoTags(visits, maxTags=8){
      const tags = [];
      if (!visits || !visits.length) return tags;
      const subjCount = {};
      const schoolCount = {};
      let contactCount = 0;
      let chatInvite = false;
      let followUpNeeded = false;
      let trainingInterest = false;
      // expanded keywords for training/education interest
  const trainingKeywords = /(연수|연수안내|연수문의|워크숍|연수희망|연수희망자|교육|교육안내|교육설명회|교원연수|연수참여|연수요청|교사연수|직무연수|연수신청)/i;
      const chatKeywords = /(채팅|채팅방|카톡|카카오|텔레그램|라인|메신저)/i;
      const followKeywords = /(자료|발송|추가|재방문|워크북|샘플|안내자료|자료요청)/i;

      visits.forEach(v=>{
        if (v.school) schoolCount[v.school] = (schoolCount[v.school]||0)+1;
        (v.subjects||[]).forEach(s=>{
          const name = (s.subject||'').trim(); if (name) subjCount[name] = (subjCount[name]||0)+1;
          if (s.contact) contactCount++;
          const meetings = (s.meetings||[]).join(' ');
          if (chatKeywords.test(meetings)) chatInvite = true;
          if (s.followUp && followKeywords.test(s.followUp)) followUpNeeded = true;
          if (s.conversation && trainingKeywords.test(s.conversation)) trainingInterest = true;
        });
      });
      // subject-level tags (top subjects)
      const subjEntries = Object.entries(subjCount).sort((a,b)=>b[1]-a[1]);
      if (subjEntries.length){
        const top = subjEntries.slice(0,3).map(s=>s[0]+(s[1]>1?`(${s[1]}회)`:''));
        tags.push('주요과목: '+top.join(', '));
  subjEntries.forEach(([s,c])=>{ if(c>=3) tags.push(s+' 다수 방문'); });
      }
      // school-level
      const schoolEntries = Object.entries(schoolCount).sort((a,b)=>b[1]-a[1]);
      if (schoolEntries.length){
        const multi = schoolEntries.filter(e=>e[1]>=2).map(e=>e[0]);
        if (multi.length) tags.push('재방문: '+multi.join(', '));
      }
      if (contactCount>0) tags.push('연락처 확보 '+contactCount+'건');
      if (chatInvite) tags.push('채팅방 안내');
      if (followUpNeeded) tags.push('자료 발송 필요');
      if (trainingInterest) tags.push('연수 관심');
      // limit tags and dedupe according to maxTags
      const seen = new Set();
      const out = [];
      for (const t of tags){ if (!seen.has(t)){ seen.add(t); out.push(t); } if (out.length>=Math.max(1,Math.min(50,Math.floor(maxTags)||8))) break; }
      return out;
    }

    document.getElementById('copyKakaoBtn')?.addEventListener('click', async ()=>{
      if (!dayVisits || !dayVisits.length) { alert('먼저 방문을 추가하세요. (하루치 방문이 쌓여 있어야 합니다)'); return; }
      let summary = buildAggregateSummary(dayVisits, 'kakao');
      // build auto-tags and append to summary for Kakao copy
      try{
        const maxTags = parseInt(document.getElementById('optMaxTags')?.value) || 8;
        // basic/default behavior: include human-readable line, do NOT include hashtags
        const includeHuman = true;
        const includeHash = false;
        const tags = buildAutoTags(dayVisits, maxTags);
        if (tags && tags.length){
          if (includeHuman) summary += '\n\n자동 태그: ' + tags.join(', ');
          if (includeHash) summary += '\n\n#' + tags.map(t=>t.replace(/[^\p{L}\p{N}]+/gu,'_')).join(' #');
        }
      }catch(e){ console.warn('autotag generation failed', e); }
      const ok = await copyToClipboard(summary);
      if (ok) { alert('카카오용 요약이 클립보드에 복사되었습니다. 카톡에 붙여넣기 해주세요.'); }
      else { alert('복사에 실패했습니다. 생성된 요약을 수동으로 복사해주세요.'); }
    });

    // POST dayVisits to backend and immediately re-fetch saved doc to restore UI
    document.getElementById('saveToServerBtn')?.addEventListener('click', async ()=>{
      if (!dayVisits || !dayVisits.length) { alert('저장할 방문 기록이 없습니다. 먼저 방문을 추가하세요.'); return; }
      const staff = getStaffFromQuery() || (document.getElementById('staffInfo')||{}).textContent.replace(/^담당자:\s*/,'').trim();
      // include the generated summary so the server stores the final report text
      const gen = document.getElementById('generatedSummary');
      const payload = { staff, visits: dayVisits, summary: (gen && gen.value) ? gen.value : '' };
      try {
        const res = await fetch('/api/visits', {
          method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload)
        });
        const j = await res.json();
        if (res.ok && j && j.ok) {
          alert('서버에 저장되었습니다. ID: ' + j.id);
          // Immediately try to re-load from server for the selected visitDate so UI reflects server state
          try{
            const visitDateVal = (document.getElementById('visitDate')||{}).value || '';
            if (visitDateVal && typeof loadSavedForDate === 'function'){
              await loadSavedForDate(visitDateVal);
            }
          }catch(err){ console.warn('post-save requery failed', err); }
        }
        else { alert('저장 실패: ' + (j && j.msg ? j.msg : res.statusText)); }
      } catch(e){ alert('서버 저장 중 오류: ' + e.message); }
    });

      // Edit last added visit: load last visit into the form for editing
      document.getElementById('editLastBtn')?.addEventListener('click', ()=>{
        if (!dayVisits || !dayVisits.length) { alert('편집할 방문이 없습니다. 먼저 방문을 추가하세요.'); return; }
        const idx = dayVisits.length - 1;
        loadVisitToForm(idx);
        // switch to step2 view
        try { document.getElementById('step1').style.display = 'none'; document.getElementById('step2').style.display = 'block'; } catch(e){}
        // focus first editable field
        setTimeout(()=>{ const el = document.querySelector('#salesForm .teacher-name'); if(el) el.focus(); }, 120);
      });

    // register service worker for PWA (if available)
    if ('serviceWorker' in navigator) {
      // Register sw.js but handle promise rejection explicitly so
      // missing script (404) doesn't throw an uncaught promise error.
      if (navigator.serviceWorker && navigator.serviceWorker.register) {
        navigator.serviceWorker.register('/sw.js').then(()=>{
          console.log('sw.js registered');
        }).catch(()=>{
          // ignore registration failures (e.g., 404)
        });
      }
    }

    // enhanced generateSummary: uses dayVisits if exists, otherwise single current form
    document.getElementById('genSummaryBtn')?.addEventListener('click', ()=>{
      const template = (document.getElementById('summaryTemplate')||{}).value || 'detailed';
      let visits = dayVisits.length ? dayVisits : [ buildCurrentVisitObject() ];
      const summary = buildAggregateSummary(visits, template);
      const out = document.getElementById('generatedSummary'); if (out) writeGeneratedSummary(reportIntro() + '\n' + summary, { replace: true });
    });

    // report intro/header block to prepend to generated summaries
    function reportIntro() {
      // dynamic header: use URL ?user= parameter when present, otherwise fallback to staffInfo text
      let staffName = '';
      try {
        staffName = getStaffFromQuery() || '';
      } catch(e) { staffName = ''; }
      if (!staffName) {
        const infoEl = document.getElementById('staffInfo');
        if (infoEl && infoEl.textContent) {
          staffName = infoEl.textContent.replace(/^담당자:\s*/,'').trim();
        }
      }
      if (!staffName) staffName = '담당자';
      // normalize base name (remove common title suffixes if present)
      let base = staffName.replace(/\s*(부장|차장|과장|대리|사원)\s*$/,'').trim();
      // mapping to titled names
      const titleMap = {
        '송훈재': '송훈재 부장',
        '임준호': '임준호 차장',
        '조영환': '조영환 부장'
      };
      const displayName = titleMap[base] || staffName;
      const lines = [];
      lines.push(`(${displayName} 퇴근보고)`);
      lines.push('');
      return lines.join('\n');
    }

    function buildAggregateSummary(visits, template) {
      // aggregate stats
      // totalMeetings: count of UNIQUE school+subject pairs across all visits
      // (treat each distinct subject at a school as one meeting)
      const _schoolSubjectKeySet = new Set();
      visits.forEach(v => {
        (v.subjects||[]).forEach(s => {
          const subject = (s.subject || '').toString().trim();
          const school = (v.school || '').toString().trim();
          if (subject) {
            const skey = `${school}|||${subject}`;
            _schoolSubjectKeySet.add(skey);
          }
        });
      });
      const totalMeetings = _schoolSubjectKeySet.size;
      // uniqueSchools: count unique by visitDate + region + school (as requested)
      const _schoolKeySet = new Set();
      visits.forEach(v => {
        const key = `${v.visitDate||''}|||${v.region||''}|||${v.school||''}`;
        _schoolKeySet.add(key);
      });
      const uniqueSchools = _schoolKeySet.size;

      let contactCount = 0;
      let additionalConfirmCount = 0;
      visits.forEach(v => {
        (v.subjects||[]).forEach(s => { if (s.contact) contactCount++; if (s.followUp && s.followUp.indexOf('추가선정')!==-1) additionalConfirmCount++; });
      });

      // helper: Korean ordinal labels 가, 나, 다, ... fallback to numeric if out of range
      const korLetters = ['가','나','다','라','마','바','사','아','자','차','카','타','파','하'];
      const getKorLabel = (i) => (korLetters[i] ? korLetters[i] + '.' : (i+1) + '.');

      // treat first visit start as 출근, last visit end as 퇴근 (use insertion order)
      const firstStart = (visits && visits.length && visits[0].visitStart) ? visits[0].visitStart : '';
      const lastEnd = (visits && visits.length && visits[visits.length-1].visitEnd) ? visits[visits.length-1].visitEnd : '';

      if (template === 'compact') {
        // one-line per school
        const lines = visits.map((v,i)=>{
          const subjCount = v.subjects.length;
          return `${getKorLabel(i)} ${v.school} ${v.visitStart || ''}-${v.visitEnd || ''} (${subjCount}과목)`;
        });
  lines.push(`총 방문 학교: ${uniqueSchools}개 · 총 미팅수: ${totalMeetings}건, 연락처 확보: ${contactCount}건, 추가선정 확인: ${additionalConfirmCount}건`);
        return lines.join('\n');
      }

      if (template === 'paragraph') {
        // natural paragraph
        const parts = [];
        parts.push(`${visits[0].visitDate || ''} 방문 보고입니다.`.trim());
        visits.forEach((v,i)=>{
          parts.push(`${getKorLabel(i)} ${v.school} (${v.region || ''}) 에서 ${v.visitStart || ''}부터 ${v.visitEnd || ''}까지 방문하여 ${v.subjects.length}과목을 지도했습니다.`);
          v.subjects.forEach(s=>{
            const m = s.meetings && s.meetings.length ? `미팅: ${s.meetings.join(', ')}.` : '';
            parts.push(`- ${s.subject} ${s.teacher ? '('+s.teacher+')':''} ${m} ${s.conversation? '특이사항: '+s.conversation : ''}`);
          });
        });
  parts.push(`총 방문 학교: ${uniqueSchools}개, 총 미팅수: ${totalMeetings}건, 연락처 확보 ${contactCount}건, 추가선정 확인 ${additionalConfirmCount}건.`);
        return parts.join('\n');
      }

      if (template === 'kakao') {
        // Kakao-style structured report requested by user
        const parts = [];
        // include dynamic intro
        parts.push(reportIntro().trim());
        // header
        function fmtDateForHeader(raw) {
          if (!raw) return '';
          try {
            const d = new Date(raw);
            if (!isNaN(d.getTime())) {
              return d.getFullYear() + '-' + pad2(d.getMonth() + 1) + '-' + pad2(d.getDate());
            }
          } catch (e) {}
          const m = String(raw).match(/(\d{4}-\d{2}-\d{2})/);
          if (m) return m[1];
          return String(raw).slice(0,10);
        }
        parts.push(`방문일: ${fmtDateForHeader(visits[0].visitDate || '')}`);
  parts.push(`총 방문 학교: ${uniqueSchools}개 · 총 미팅수: ${totalMeetings}건 · 연락처 확보: ${contactCount}건 · 추가선정 확인: ${additionalConfirmCount}건`);
        // 1. 출근/퇴근 summary (numbered section 1)
        parts.push('');
        // compute 자료정리 end (lastEnd + 30min) and use it as 퇴근 when available
        function computeEndCollect(t){
          try{
            const fixedStartEl = document.getElementById('customCollectStart');
            const fixedMinEl = document.getElementById('customCollectMinutes');
            const fixedStart = fixedStartEl ? (fixedStartEl.value||'').trim() : (customCollectStart || '');
            const fixedMin = fixedMinEl ? parseInt(fixedMinEl.value||'') : (customCollectMinutes || 30);
            if (fixedStart) {
              return addMinutesToTime(fixedStart, isNaN(fixedMin) ? 30 : fixedMin);
            }
            if (!t) return '';
            return addMinutesToTime(t, (isNaN(customCollectMinutes) ? 30 : customCollectMinutes));
          }catch(e){ return ''; }
        }
        const lastEndTime = lastEnd || '';
        const computedEndCollect = computeEndCollect(lastEndTime);
        let finalEnd = lastEnd || '';
        if (lastEnd && computedEndCollect) finalEnd = computedEndCollect;
        // compute working duration between firstStart and finalEnd
        let workDurationText = '';
        if (firstStart && finalEnd) {
          const totalMin = calcMinutesInterval(firstStart, finalEnd);
          const hrs = Math.floor(totalMin / 60);
          const mins = totalMin % 60;
          workDurationText = ` (근무시간 ${hrs}h ${mins}m)`;
        }
        parts.push(`1. 출근: ${firstStart || '-'} · 퇴근: ${finalEnd || '-'}${workDurationText}`);
        parts.push('');
        // 2. 세부업무 with lettered school sections
        parts.push('2. 세부업무');
        parts.push('');
        // Group visits by school (preserve first-seen order)
        const schoolOrder = [];
        const schoolGroups = {};
        visits.forEach(v => {
          const key = (v.school || '-').trim();
          if (!Object.prototype.hasOwnProperty.call(schoolGroups, key)) {
            schoolGroups[key] = [];
            schoolOrder.push(key);
          }
          schoolGroups[key].push(v);
        });

        // For each school group, print a header (가, 나, ...) and then enumerate subjects as subitems (가1, 가2...)
        schoolOrder.forEach((schoolName, sIdx) => {
          const group = schoolGroups[schoolName] || [];
          const label = getKorLabel(sIdx).replace(/\.$/, '');
          // compute a single time range for the group: earliest start -> latest end
          // Robustly extract HH:MM tokens from possibly concatenated visitStart/visitEnd values
          let earliest = null; let latest = null; let durMinutes = null;
          try {
            const extractTimes = (str) => {
              if (!str) return [];
              const parts = String(str).split(/[,;|\\/]+/).map(s=>s.trim()).filter(Boolean);
              const times = [];
              parts.forEach(p => {
                if (p.indexOf('~') !== -1) {
                  const [a,b] = p.split('~').map(x=>x.trim());
                  if (/^\d{1,2}:\d{2}$/.test(a)) times.push(pad2(parseInt(a.split(':')[0],10))+ ':' + pad2(parseInt(a.split(':')[1],10)));
                  if (/^\d{1,2}:\d{2}$/.test(b)) times.push(pad2(parseInt(b.split(':')[0],10))+ ':' + pad2(parseInt(b.split(':')[1],10)));
                } else {
                  const m = p.match(/\d{1,2}:\d{2}/g);
                  if (m) m.forEach(x=> times.push(pad2(parseInt(x.split(':')[0],10))+ ':' + pad2(parseInt(x.split(':')[1],10))));
                }
              });
              return times.filter(Boolean);
            };
            const allStarts = [];
            const allEnds = [];
            group.forEach(gv => {
              try {
                const sTokens = extractTimes(gv.visitStart);
                const eTokens = extractTimes(gv.visitEnd);
                if (sTokens && sTokens.length) allStarts.push(...sTokens);
                if (eTokens && eTokens.length) allEnds.push(...eTokens);
              } catch(e) {}
            });
            if (allStarts.length || allEnds.length) {
              // if we only have one side, duplicate to allow range computation
              const sArr = allStarts.length ? allStarts.slice().sort() : (allEnds.length ? allEnds.slice().sort() : []);
              const eArr = allEnds.length ? allEnds.slice().sort() : (allStarts.length ? allStarts.slice().sort() : []);
              earliest = sArr.length ? sArr[0] : null;
              latest = eArr.length ? eArr[eArr.length-1] : null;
              if (earliest && latest) {
                try { durMinutes = calcMinutesInterval(earliest, latest); } catch(e){ durMinutes = null; }
              }
            }
          } catch(e) { /* ignore */ }
          const timeStr = (earliest && latest) ? ` ${earliest}~${latest}` : '';
          let durStr = '';
          try{ if (earliest && latest) { const mins = calcMinutesInterval(earliest, latest); if (mins) durStr = ` (${mins}분)`; } }catch(e){}
          parts.push(`${label}. ${schoolName || '-'}${timeStr}${durStr}`);
          parts.push('');

          // flatten subjects across visits for this school while preserving order
          const flatSubjects = [];
          group.forEach(gv => {
            (gv.subjects || []).forEach(s => flatSubjects.push(Object.assign({}, s, { _visitStart: gv.visitStart || '', _visitEnd: gv.visitEnd || '' })));
          });

          // enumerate per-subject lines with sublabels (가1, 가2, ...)
          flatSubjects.forEach((s, j) => {
            const subLabel = `${label}${j+1}.`;
            const meetings = s.meetings && s.meetings.length ? ` · ${s.meetings.join(', ')}` : '';
            const follow = s.followUp ? ` · 후속:${s.followUp}` : '';
            const conv = s.conversation ? ` · ${s.conversation}` : '';
            const teacher = s.teacher ? `(${s.teacher})` : '';
            const publisher = s.publisher ? ` / ${s.publisher}` : '';
            // example: -가1. 정보 (aa)
            const subjectLine = `-${subLabel} ${s.subject || '-'} ${teacher}${publisher}${meetings}${follow}${conv}`.trim();
            parts.push(subjectLine);
          });
          parts.push('');
        });
        // 3. 퇴근보고 자료 정리 — 사용자 지정 시간이 있으면 그것을 우선 사용하고, 없으면 마지막 종료 시각 기준 + customCollectMinutes
        try{
          let collectStart = lastEndTime;
          let collectEnd = computedEndCollect;
          const fixedStartEl = document.getElementById('customCollectStart');
          const fixedMinEl = document.getElementById('customCollectMinutes');
          const fixedStart = fixedStartEl ? (fixedStartEl.value||'').trim() : (customCollectStart || '');
          const fixedMin = fixedMinEl ? parseInt(fixedMinEl.value||'') : (customCollectMinutes || 30);
          if (fixedStart) {
            collectStart = fixedStart;
            try{ collectEnd = addMinutesToTime(fixedStart, isNaN(fixedMin) ? 30 : fixedMin); }catch(e){ collectEnd = computedEndCollect; }
          }
          if (collectStart && collectEnd) {
            const dur = calcMinutesInterval(collectStart, collectEnd);
            parts.push(`3. 퇴근보고 자료 정리 (${collectStart}~${collectEnd}) (${dur}분)`);
          } else { parts.push('3. 퇴근보고 자료 정리'); }
        }catch(e){ parts.push('3. 퇴근보고 자료 정리'); }
        parts.push('');
  parts.push('- 끝.');
        return parts.join('\n');
      }

      // detailed (default): header + per-visit block with per-subject rows
      const lines = [];
      lines.push(`방문일: ${visits[0].visitDate || ''}`);
  lines.push(`총 방문 학교: ${uniqueSchools}개 · 총 미팅수: ${totalMeetings}건`);
      lines.push(`출근: ${firstStart || '-'} | 퇴근: ${lastEnd || '-'}`);
      lines.push(`연락처 확보: ${contactCount}건 | 추가선정 확인: ${additionalConfirmCount}건`);
      lines.push('');
      // 세부업무: 한 번만 출력하고 같은 학교가 연속으로 나올 때는 학교명을 반복하지 않도록 그룹화
      lines.push('세부업무:');
      const schoolLabelMap = {}; // schoolName -> label index
      let nextLabelIndex = 0;
      visits.forEach((v, idx) => {
        const schoolName = v.school || '-';
        if (schoolLabelMap[schoolName] === undefined) {
          // first time we see this school: assign a label and print header
          schoolLabelMap[schoolName] = nextLabelIndex++;
          lines.push(`${getKorLabel(schoolLabelMap[schoolName])} ${schoolName} — ${v.region || ''} (${v.visitStart || ''} ~ ${v.visitEnd || ''})`);
        } else {
          // repeated school: do not print new label/school name, just show time range indented
          lines.push(`   (${v.visitStart || ''} ~ ${v.visitEnd || ''})`);
        }
        // subjects (always list)
        v.subjects.forEach(s => {
          const meetings = s.meetings && s.meetings.length ? `[${s.meetings.join(', ')}] ` : '';
          const follow = s.followUp ? `팔로업:${s.followUp} ` : '';
          const conv = s.conversation ? `특이사항:${s.conversation}` : '';
          lines.push(` - ${s.subject} / ${s.teacher || '-'} / ${s.publisher || '-'} ${meetings}${follow}${conv}`.trim());
        });
        lines.push('');
      });
      return lines.join('\n');
    }

    // format a single visit into a readable paragraph (used for appending to the textarea)
    function formatVisitText(v, idx) {
      const lines = [];
      // plain structured per-visit representation (no emojis)
      const timeRange = (v.visitStart || '') && (v.visitEnd || '') ? `${v.visitStart}~${v.visitEnd}` : '';
      const duration = (v.visitStart && v.visitEnd) ? ` (${calcMinutesInterval(v.visitStart,v.visitEnd)}분)` : '';
      lines.push(`${idx+1}. ${v.school || '-'} (${v.region || '-'}) ${timeRange}${duration}`);
      v.subjects.forEach(s=>{
        const segs = [];
        segs.push(s.subject || '-');
        if (s.teacher) segs.push(s.teacher);
        if (s.publisher) segs.push(s.publisher);
        if (s.meetings && s.meetings.length) segs.push(s.meetings.join('/'));
  // do not include contact value in generated text (kept for backend only)
        if (s.followUp) segs.push(`후속:${s.followUp}`);
        if (s.conversation) segs.push(`특이:${s.conversation}`);
        lines.push(' - ' + segs.join(' · '));
      });
      lines.push('');
      return lines.join('\n');
    }

    // add minutes to time string 'HH:MM' and return 'HH:MM' (24-hour wrap)
    function addMinutesToTime(timeStr, minutesToAdd) {
      if (!timeStr || typeof timeStr !== 'string') return '';
      const parts = timeStr.split(':');
      if (parts.length < 2) return '';
      const hh = parseInt(parts[0],10); const mm = parseInt(parts[1],10);
      if (isNaN(hh) || isNaN(mm)) return '';
      const total = hh * 60 + mm + parseInt(minutesToAdd,10);
      const wrapped = (total + 24*60) % (24*60);
      const newH = Math.floor(wrapped/60);
      const newM = wrapped % 60;
      return pad2(newH) + ':' + pad2(newM);
    }

    // robust writer for #generatedSummary: temporarily clear readonly, write (append or replace)
    // If the user manually edited the textarea (manualSummaryEdited === true), do not clobber their edits when asked to replace;
    // instead append the new content below.
    function writeGeneratedSummary(text, opts) {
      // opts: { replace: boolean }
      opts = opts || {};
      const ta = document.getElementById('generatedSummary');
      if (!ta) { console.warn('writeGeneratedSummary: textarea not found'); return; }
      // perform write on next tick to avoid interference with other DOM updates
      setTimeout(() => {
        const wasReadOnly = ta.hasAttribute('readonly');
        try {
          if (wasReadOnly) ta.removeAttribute('readonly');
          if (opts.replace) {
            if (manualSummaryEdited) {
              // user edited manually — append instead of replacing to avoid losing user's changes
              const cur = ta.value || '';
              const sep = cur && cur.trim() ? '\n\n' : '';
              ta.value = cur + sep + (text || '');
            } else {
              ta.value = text || '';
            }
          } else {
            // append ensuring a trailing newline separator
            const cur = ta.value || '';
            ta.value = (cur && cur.trim() && !cur.endsWith('\n') ? cur + '\n' : cur) + (text || '');
          }
          // dispatch input event so any listeners notice the change
          try {
            _suppressSummaryInputHandler = true;
            ta.dispatchEvent(new Event('input', { bubbles: true }));
          } catch(e){} finally { _suppressSummaryInputHandler = false; }
          // scroll to bottom so new content is visible
          ta.scrollTop = ta.scrollHeight;
          try{
            // persist summary to localStorage per-date so it can be restored when visitDate is re-selected
            const visitDateVal = (document.getElementById('visitDate')||{}).value || '';
            const staffToken = (getStaffFromQuery && getStaffFromQuery()) ? getStaffFromQuery() : '';
            if (visitDateVal){
              const key = 'cmass_summary_' + (staffToken ? staffToken + '_' : '') + visitDateVal;
              try{ localStorage.setItem(key, JSON.stringify({ ts:Date.now(), text: (ta.value||'') })); }catch(e){/* ignore storage errors */}
            }
          }catch(e){/* ignore */}
        } finally {
          // restore readonly state if it existed
          if (wasReadOnly) ta.setAttribute('readonly','');
        }
      }, 40);
    }

    // --- Draft (in-progress) save/restore for current visit ---
    function _debounce(fn, wait){ let t = null; return function(){ clearTimeout(t); const args = arguments; t = setTimeout(()=>fn.apply(this,args), wait); }; }
    // Draft keys are namespaced by staff + visitDate + region + school so drafts are unique per-context
    function _encodeKeyPart(s){ try{ return encodeURIComponent((s||'').toString().trim()); }catch(e){ return ''; } }
    function draftKeyForVisit(v){
      try{
        const staff = (getStaffFromQuery && getStaffFromQuery()) ? getStaffFromQuery() : (v && v.staff) ? v.staff : '';
        const date = (v && v.visitDate) ? v.visitDate : '';
        const region = (v && v.region) ? v.region : (document.getElementById('selectedRegionInput')||{}).value || '';
        const school = (v && v.school) ? v.school : (document.getElementById('selectedSchoolInput')||{}).value || '';
        return 'cmass_draft_' + _encodeKeyPart(staff) + '_' + date + '_' + _encodeKeyPart(region) + '_' + _encodeKeyPart(school);
      }catch(e){ return 'cmass_draft_' + ((v && v.visitDate) ? v.visitDate : ''); }
    }

    // Update the small draft status UI showing whether a draft exists for current staff+date+region+school
    function updateDraftStatus() {
      try {
        const v = buildCurrentVisitObject();
        const key = draftKeyForVisit(v);
        const staffKey = 'cmass_draft_' + _encodeKeyPart((getStaffFromQuery && getStaffFromQuery()) ? getStaffFromQuery() : '') + '_' + (v.visitDate || '');
        const genKey = 'cmass_draft_' + (v.visitDate || '');
        // compute visible labels
        const staffLabel = (getStaffFromQuery && getStaffFromQuery()) ? getStaffFromQuery() : ((document.getElementById('staffName')||{}).value || (document.getElementById('staffInfo')||{}).textContent.replace(/^담당자:\s*/,'').trim());
        const dateLabel = v.visitDate || '';
        const regionLabel = v.region || (document.getElementById('displayRegion')||{}).textContent || '';
        const schoolLabel = v.school || (document.getElementById('displaySchool')||{}).textContent || '';

        let statusLine = `담당자: ${staffLabel || '-'} · 방문일: ${dateLabel || '-'} · 지역: ${regionLabel || '-'} · 학교: ${schoolLabel || '-'}`;

        let msg = '';
        let found = null;
        if (localStorage.getItem(key)) {
          try { const obj = JSON.parse(localStorage.getItem(key)); msg = '드래프트(정확키) 저장됨: ' + (obj && obj.ts ? (new Date(obj.ts)).toLocaleString() : '저장됨'); found = key; }
          catch(e){ msg = '드래프트(정확키) 존재'; found = key; }
        } else if (localStorage.getItem(staffKey)) {
          try { const obj = JSON.parse(localStorage.getItem(staffKey)); msg = '드래프트(담당자+날짜) 저장됨: ' + (obj && obj.ts ? (new Date(obj.ts)).toLocaleString() : '저장됨'); found = staffKey; }
          catch(e){ msg = '드래프트(담당자+날짜) 존재'; found = staffKey; }
        } else if (localStorage.getItem(genKey)) {
          try { const obj = JSON.parse(localStorage.getItem(genKey)); msg = '드래프트(날짜) 저장됨: ' + (obj && obj.ts ? (new Date(obj.ts)).toLocaleString() : '저장됨'); found = genKey; }
          catch(e){ msg = '드래프트(날짜) 존재'; found = genKey; }
        } else {
          msg = '드래프트 상태: 없음';
        }

        const el = document.getElementById('draftStatus');
        if (el) {
          el.innerHTML = `<div style="font-weight:700;color:#12325a;">${statusLine}</div><div style="margin-top:6px;color:#175;">${msg}</div>`;
        }
        return found;
      } catch (e) { return null; }
    }

    function saveDraftForDate(){
      try{
        const v = buildCurrentVisitObject();
        const date = v.visitDate || '';
        if (!date) return;
        const key = draftKeyForVisit(v);
        // store minimal visit object to localStorage
        const payload = { ts: Date.now(), visit: v };
        try{ localStorage.setItem(key, JSON.stringify(payload)); }catch(e){}
        // update UI status after saving
        try{ updateDraftStatus(); }catch(e){}
      }catch(e){/* ignore */}
    }
    const saveDraftDebounced = _debounce(saveDraftForDate, 600);

    // load draft: prefer exact match (staff+date+region+school), then staff+date, then any draft for date
    function loadDraftForDate(dateStr){
      try{
        if (!dateStr) return null;
        const staff = (getStaffFromQuery && getStaffFromQuery()) ? getStaffFromQuery() : '';
        const region = (document.querySelector('#regionButtons .grid-button[aria-selected="true"]') || {}).dataset?.region || (document.getElementById('selectedRegionInput')||{}).value || '';
        const school = (document.querySelector('#schoolButtons .grid-button[aria-selected="true"]') || {}).dataset?.school || (document.getElementById('selectedSchoolInput')||{}).value || '';

        // try exact key first
        const exactKey = 'cmass_draft_' + _encodeKeyPart(staff) + '_' + dateStr + '_' + _encodeKeyPart(region) + '_' + _encodeKeyPart(school);
        let raw = localStorage.getItem(exactKey);
        if (raw) { try{ const obj = JSON.parse(raw); return obj && obj.visit ? obj.visit : null; }catch(e){} }

        // try staff+date (no region/school)
        const staffKey = 'cmass_draft_' + _encodeKeyPart(staff) + '_' + dateStr;
        raw = localStorage.getItem(staffKey);
        if (raw) { try{ const obj = JSON.parse(raw); return obj && obj.visit ? obj.visit : null; }catch(e){} }

        // fallback: search any cmass_draft_* that contains _<dateStr>_ and return the first match
        for (let i=0;i<localStorage.length;i++){
          const k = localStorage.key(i);
          if (!k) continue;
          if (k.indexOf('cmass_draft_')===0 && k.indexOf('_' + dateStr + '_')!==-1) {
            try{ const raw2 = localStorage.getItem(k); const obj2 = JSON.parse(raw2); if (obj2 && obj2.visit) return obj2.visit; }catch(e){}
          }
        }

        // generic fallback: cmass_draft_<dateStr>
        const genKey = 'cmass_draft_' + dateStr;
        raw = localStorage.getItem(genKey);
        if (raw) { try{ const obj = JSON.parse(raw); return obj && obj.visit ? obj.visit : null; }catch(e){} }

        return null;
      }catch(e){ return null; }
    }

    // clear draft helper (keeps for admin use) — removes drafts matching the provided date (all staff/region/school variants)
    function clearDraftForDate(dateStr){
      try{
        if (!dateStr) return;
        const keysToRemove = [];
        for (let i=0;i<localStorage.length;i++){
          const k = localStorage.key(i);
          if (!k) continue;
          if (k.indexOf('cmass_draft_')===0 && k.indexOf(dateStr)!==-1) keysToRemove.push(k);
        }
        keysToRemove.forEach(k=>{ try{ localStorage.removeItem(k); }catch(e){} });
      }catch(e){}
    }

    // populate current form fields from a visit object (does NOT push to dayVisits)
    function populateFormFromVisit(v){
      try{
        if (!v) return;
        // visitDate
        if (v.visitDate){ const vdEl = document.getElementById('visitDate'); if (vdEl) vdEl.value = v.visitDate; }
        if (v.visitStart){ const [hh,mm] = (v.visitStart||'').split(':'); if (document.getElementById('visitStartHour')) document.getElementById('visitStartHour').value = hh||''; if (document.getElementById('visitStartMinute')) document.getElementById('visitStartMinute').value = mm||''; }
        if (v.visitEnd) (document.getElementById('visitEnd')||{}).value = v.visitEnd;
        // region and school
        if (v.region){ const regionBtn = Array.from(document.querySelectorAll('#regionButtons .grid-button')).find(b=>b.textContent.trim()===v.region || b.dataset.region===v.region); if (regionBtn) regionBtn.click(); }
        if (v.school){ setTimeout(()=>{ const schoolBtn = Array.from(document.querySelectorAll('#schoolButtons .grid-button')).find(b=>b.textContent.trim()===v.school || b.dataset.school===v.school); if (schoolBtn) schoolBtn.click(); }, 120); }
        // subjects: rebuild subject blocks but do not alter dayVisits (use template cloning to preserve canonical markup & handlers)
        const container = document.getElementById('subjectsBlock'); if (!container) return;
        let template = container.querySelector('.subject-block');
        if (!template) {
          // Prefer canonical <template id="subject-template"> when available
          const tplEl = document.getElementById('subject-template');
          if (tplEl && tplEl.content) {
            template = tplEl.content.querySelector('.subject-block');
          } else {
            // Use centralized helper for the fallback template
            template = getSubjectBlockTemplateNode();
          }
        }
        container.innerHTML = '<label>과목/선생님별 영업기록</label>';
        (v.subjects||[]).forEach(s => {
          const block = template.cloneNode(true);
          block.className = 'subject-block';
          // populate values
          if (s.subject) {
            block.querySelector('.subject-name').value = s.subject;
            const subjectBtn = Array.from(block.querySelectorAll('.subject-choice')).find(b=>b.dataset.subject===s.subject || b.textContent.trim()===s.subject);
            if (subjectBtn) subjectBtn.classList.add('selected');
          }
          if (s.teacher) block.querySelector('.teacher-name').value = s.teacher;
          if (s.publisher) block.querySelector('.publisher').value = s.publisher;
          if (s.followUp) block.querySelector('.followUpSelect').value = s.followUp;
          if (s.contact) {
            const digits = (s.contact || '').replace(/\D+/g,'');
            if (digits.length === 11) block.querySelector('.contact-suffix').value = digits.slice(3);
          }
          if (s.conversation) block.querySelector('.conversation-detail').value = s.conversation;
          setTimeout(()=>{ if (s.meetings && s.meetings.length) { Array.from(block.querySelectorAll('.meeting-btn')).forEach(btn=>{ if (s.meetings.includes(btn.textContent.trim())) btn.classList.add('selected'); }); } }, 10);
          // ensure a remove button exists and is wired (so restored drafts remain editable)
          try {
            let remBtn = block.querySelector('.removeSubjectBtn');
            if (!remBtn) {
              remBtn = document.createElement('button');
              remBtn.type = 'button';
              remBtn.className = 'removeSubjectBtn';
              remBtn.style = 'margin:0.5rem 0 1rem 0;padding:0.5rem 1rem;font-size:1rem;border-radius:0.7rem;background:#ff9800;color:#fff;border:none;cursor:pointer;';
              remBtn.textContent = '삭제';
              block.appendChild(remBtn);
            }
            remBtn.onclick = function(){ block.remove(); if(typeof renumberSubjectBlocks==='function') renumberSubjectBlocks(); };
          } catch(e) { /* non-fatal */ }
          container.appendChild(block);
        });
        if (typeof renumberSubjectBlocks === 'function') renumberSubjectBlocks();
      }catch(e){/* ignore */}
    }

    // Load previously saved summary and visits for a given date.
    // Strategy: try server aggregated docs first (/api/visits without useEntries) for staff + date.
    // If none, fallback to localStorage key 'cmass_summary_<staff>_<yyyy-mm-dd>' or without staff.
    async function loadSavedForDate(dateStr){
      if (!dateStr) return;
      const staffName = (getStaffFromQuery && getStaffFromQuery()) ? getStaffFromQuery() : '';
      // If a local draft exists for this date, prefer restoring that to avoid clobbering in-progress edits
      try{
        const draft = loadDraftForDate(dateStr);
        if (draft) { try{ populateFormFromVisit(draft); }catch(e){}; return; }
      }catch(e){}
      // helper to apply loaded summary and visits
      function applyLoaded(obj){
        try{
          if (!obj) return;
          if (obj.summary) {
            writeGeneratedSummary(obj.summary, { replace: true });
          }
          // if server provided visits array, restore dayVisits and render list
          if (Array.isArray(obj.visits) && obj.visits.length){
            try{ dayVisits.length = 0; Array.prototype.push.apply(dayVisits, obj.visits); renderVisitsList(); }catch(e){ console.warn('applyLoaded visits restore failed', e); }
          }
        }catch(e){ console.warn('applyLoaded failed', e); }
      }

      // First: try server per-entry documents (visit_entries) which accumulate each '입력 완료'
      try{
        const paramsE = new URLSearchParams();
        if (staffName) paramsE.set('staff', staffName);
        paramsE.set('start', dateStr);
        paramsE.set('end', dateStr);
        paramsE.set('useEntries', 'true');
        const urlE = '/api/visits?' + paramsE.toString();
        const respE = await fetch(urlE, { cache: 'no-store' });
        if (respE && respE.ok){
          const j = await respE.json();
          if (j && Array.isArray(j.rows) && j.rows.length){
            // Convert each entry row into a visit object compatible with dayVisits
            const visits = j.rows.map(r => {
              const subj = {
                subject: r.subject || '',
                teacher: r.teacher || '',
                contact: r.contact || '',
                meetings: Array.isArray(r.meetings) ? r.meetings : (r.meetings ? [r.meetings] : []),
                conversation: r.conversation || '',
                followUp: r.followUp || ''
              };
              return {
                school: r.school || '',
                region: r.region || '',
                visitDate: r.visitDate || dateStr,
                visitStart: r.visitStart || '',
                visitEnd: r.visitEnd || '',
                subjects: [subj],
                server_id: r.id || null
              };
            });
            // apply constructed visits and rebuild generated summary
            try{
              dayVisits.length = 0; Array.prototype.push.apply(dayVisits, visits);
              renderVisitsList();
              // rebuild summary textarea from server entries
              const ta = document.getElementById('generatedSummary');
              if (ta) {
                const rebuilt = dayVisits.map((v,i) => formatVisitText(v,i)).join('\n');
                writeGeneratedSummary(rebuilt, { replace: true });
              }
            }catch(e){ console.warn('applyEntries failed', e); }
            return;
          }
        }
      }catch(e){ console.warn('loadSavedForDate entries fetch failed', e); }

      // Fallback: try server aggregated docs (legacy) which may include summary
      try{
        const params = new URLSearchParams();
        if (staffName) params.set('staff', staffName);
        params.set('start', dateStr);
        params.set('end', dateStr);
        // do NOT set useEntries so we get aggregated visits docs (which include summary)
        const url = '/api/visits?' + params.toString();
        const resp = await fetch(url, { cache: 'no-store' });
        if (resp && resp.ok){
          const j = await resp.json();
          if (j && Array.isArray(j.rows) && j.rows.length){
            // pick the most recent doc (first)
            const doc = j.rows[0];
            applyLoaded(doc);
            return;
          }
        }
      }catch(e){ console.warn('loadSavedForDate server fetch failed', e); }

      // fallback: localStorage (staff-specific then generic)
      try{
        const keyStaff = 'cmass_summary_' + (staffName ? staffName + '_' : '') + dateStr;
        const keyGeneric = 'cmass_summary_' + dateStr;
        let raw = null;
        try{ raw = localStorage.getItem(keyStaff); }catch(e){ raw = null; }
        if (!raw) { try{ raw = localStorage.getItem(keyGeneric); }catch(e){ raw = null; } }
        if (raw){
          try{ const obj = JSON.parse(raw); if (obj && obj.text) { applyLoaded({ summary: obj.text }); return; } }catch(e){ /* ignore parse */ }
        }
      }catch(e){ console.warn('loadSavedForDate localStorage failed', e); }
    }

    // When visitDate changes, try to restore saved content for that date
    (function wireVisitDateRestore(){
      try{
        const vd = document.getElementById('visitDate');
        if (!vd) return;
        vd.addEventListener('change', ()=>{ const d = vd.value; if (d) loadSavedForDate(d); });
        // on initial load, if date has value, try to load
        window.addEventListener('DOMContentLoaded', ()=>{ try{ const d = (document.getElementById('visitDate')||{}).value; if (d) setTimeout(()=>loadSavedForDate(d), 120); }catch(e){} });
      }catch(e){ console.warn('wireVisitDateRestore failed', e); }
    })();

    (function checkProtocolAndWarn(){
      if (window.location.protocol === 'file:') {
        const container = document.getElementById('step1');
        container.innerHTML = `
          <div style="padding:1.2rem;border:2px solid #ffdcdc;background:#fff5f5;border-radius:0.8rem;">
            <h3 style="margin:0 0 .5rem 0;color:#a33;">파일에서 직접 열려 있습니다 — CSV를 불러올 수 없습니다</h3>
            <div style="color:#333;margin-bottom:.6rem;">이 페이지는 CSV 파일을 브라우저에서 불러오기 위해 HTTP로 서빙되어야 합니다. 현재 파일 프로토콜(file://)로 열려 있어 브라우저가 외부 리소스(fetch)를 차단합니다.</div>
            <div style="font-size:0.95rem;color:#333;margin-bottom:.6rem;">권장: 해당 폴더에서 간단한 HTTP 서버를 켜고 아래 URL로 접속하세요:</div>
            <pre style="background:#f6f8ff;border-radius:6px;padding:.6rem;color:#0b2b5a">python -m http.server 8000</pre>
            <div style="margin-top:.6rem;display:flex;gap:.5rem;">
              <button id="copyCmd" style="padding:.5rem 1rem;border-radius:.5rem;border:none;background:#1e3c72;color:#fff;cursor:pointer;">명령어 복사</button>
              <button id="openGuide" style="padding:.5rem 1rem;border-radius:.5rem;border:1px solid #ddd;background:#fff;cursor:pointer;">서버 실행 가이드 보기</button>
            </div>
            <div style="margin-top:.6rem;color:#666;font-size:.9rem;">참고: 서버 실행 후 브라우저에서 <code>http://localhost:8000/sales-input.html?user=송훈재</code> 로 접속하세요.</div>
          </div>`;
        document.getElementById('copyCmd').addEventListener('click', () => {
          navigator.clipboard && navigator.clipboard.writeText('python -m http.server 8000');
          alert('명령어가 클립보드에 복사되었습니다. PowerShell에서 붙여넣기 하여 실행하세요.');
        });
        document.getElementById('openGuide').addEventListener('click', () => {
          alert('PowerShell 또는 터미널에서 프로젝트 루트 폴더로 이동한 뒤:\ncd "C:\\Users\\PC\\Desktop\\조경수_업무\\flask-web-app\\cmass-sales-system"; python -m http.server 8000\n그 다음 브라우저에서 http://localhost:8000/sales-input.html?user=송훈재 로 엽니다.');
        });
        // Prevent the rest of the script from running (skip fetch)
        return;
      }
    })();

    // sales_staff.csv 기반 담당자별 지역-학교명 2단 드롭다운 (PapaParse 사용)
    function getStaffFromQuery() {
      const params = new URLSearchParams(window.location.search);
      const user = params.get('user');
      if (!user) return '';
      // canonical lowercase mapping (normalize incoming token to lower case)
      const lowerMap = {
        'songhoonjae': '송훈재 부장',
        'songhunje': '송훈재 부장', // legacy variant
        'limjunho': '임준호 차장',
        'imjunho': '임준호 차장', // legacy variant
        'choyounghwan': '조영환 부장',
        'joyounghwan': '조영환 부장' // legacy variant
      };
      const directMap = {
        // Accept both casing variants used across pages (SongHoonjae vs Songhoonjae)
        'SongHoonjae': '송훈재 부장',
        'Songhoonjae': '송훈재 부장',
        'LimJunho': '임준호 차장',
        'ChoYounghwan': '조영환 부장'
      };
      // canonical key mapping: lowercase/legacy -> canonical token used in links
      const canonicalKeyForLower = {
        'songhoonjae': 'Songhoonjae',
        'songhunje': 'Songhoonjae',
        'limjunho': 'LimJunho',
        'imjunho': 'LimJunho',
        'choyounghwan': 'ChoYounghwan',
        'joyounghwan': 'ChoYounghwan'
      };
      const lower = (user || '').toLowerCase();
      // if a legacy/lowercase token was used, canonicalize the URL to the preferred token
      try {
        const canonical = canonicalKeyForLower[lower] || (directMap[user] ? user : null);
        if (canonical && canonical !== user) {
          const newUrl = window.location.pathname + '?user=' + canonical + (window.location.hash || '');
          history.replaceState(null, '', newUrl);
        }
      } catch (e) { /* ignore replaceState errors in older webviews */ }
      if (lowerMap[lower]) return lowerMap[lower];
      if (directMap[user]) return directMap[user];
      // fallback to returning the raw param so downstream code can still show it
      return user;
    }
    let staffData = [];
  document.addEventListener('DOMContentLoaded', async function() {
      // utility to normalize strings: remove BOM, collapse newlines and excessive spaces but keep internal spaces
      const clean = s => {
        if (s === null || s === undefined) return '';
        let str = String(s);
        // remove leading BOM
        str = str.replace(/^\uFEFF/, '');
        // replace newlines/carriage returns with a single space
        str = str.replace(/[\r\n]+/g, ' ');
        // collapse multiple spaces/tabs into one
        str = str.replace(/\s+/g, ' ').trim();
        return str;
      };
  // derive a normalized staffParam from the query (preserve legacy forms but prefer a canonical mapping)
  // Use getStaffFromQuery() as the canonical source; fall back to empty string.
  // (normalizeStaffImmediate was removed/never defined — avoid calling it.)
  const _rawStaff = (typeof getStaffFromQuery === 'function') ? (getStaffFromQuery() || '') : '';
  staffParam = clean(_rawStaff);

  // Helper: attempt to load staff CSV from common locations and populate `staffData`.
  async function loadStaffCSV() {
    try {
      if (staffData && staffData.length) return;
      const candidates = ['sales-staff.csv', 'sales_staff.csv', 'data/sales-staff.csv', 'data/sales_staff.csv'];
      for (const path of candidates) {
        try {
          const resp = await fetch(path, { cache: 'no-store' });
          if (!resp || !resp.ok) continue;
          const text = await resp.text();
          if (!text) continue;
          // Use PapaParse when available for robust CSV parsing
          if (window.Papa && typeof Papa.parse === 'function') {
            // Some CSV files include a multi-line header or descriptive first line(s).
            // Detect the header row by searching for known column names (Korean or English)
            // and parse only from that line onward so PapaParse can produce the expected keys.
            try {
              const lines = text.split(/\r?\n/);
              const headerCandidates = ['담당자', '학교', '학교명', '지역', 'staff', 'school', 'region'];
              let headerIndex = -1;
              for (let i = 0; i < Math.min(lines.length, 8); i++) {
                const l = (lines[i] || '').toString();
                const lower = l.toLowerCase();
                for (const key of headerCandidates) {
                  if (lower.indexOf(key) !== -1) { headerIndex = i; break; }
                }
                if (headerIndex >= 0) break;
              }
              const csvToParse = (headerIndex >= 0) ? lines.slice(headerIndex).join('\n') : text;
              const res = Papa.parse(csvToParse, { header: true, skipEmptyLines: true });
              staffData = (res && res.data) ? res.data.map(r => ({
                // Accept multiple possible header keys (Korean/English) and normalize them.
                staff: (r.staff || r.name || r['담당자'] || r['이름'] || r['staff'] || '').toString().trim(),
                region: (r.region || r['지역'] || r['sido'] || r['region'] || '').toString().trim(),
                school: (r.school || r['학교'] || r['학교명'] || r['schoolName'] || r['school'] || '').toString().trim(),
                establish: (r.establish || r['설립'] || '').toString().trim(),
                level: (r.level || r['학년'] || '').toString().trim(),
                g1_class: (r.g1_class || r['g1_class'] || r['1학년_반수'] || r['1학년 반수'] || '').toString().trim(),
                g1_students: (r.g1_students || r['g1_students'] || r['1학년_학생수'] || r['1학년 학생수'] || '').toString().trim(),
                feature: (r.feature || r['특성'] || '').toString().trim()
              })) : [];
            } catch (e) {
              console.warn('PapaParse pre-processing failed, falling back to raw parse', e);
              const res = Papa.parse(text, { header: true, skipEmptyLines: true });
              staffData = (res && res.data) ? res.data.map(r => ({
                staff: (r.staff || r.name || r.담당자 || r.이름 || '').toString().trim(),
                region: (r.region || r.지역 || '').toString().trim(),
                school: (r.school || r.학교 || r.schoolName || '').toString().trim(),
                establish: r.establish || r.설립 || '',
                level: r.level || r.학년 || '',
                g1_class: r.g1_class || r['g1_class'] || r['1학년_반수'] || '',
                g1_students: r.g1_students || r['g1_students'] || r['1학년_학생수'] || '',
                feature: r.feature || ''
              })) : [];
            }
          } else {
            // simple CSV parse (handles quoted fields)
            const lines = text.split(/\r?\n/).filter(l => l && l.trim());
            if (!lines.length) continue;
            const hdr = lines.shift().split(/,(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/).map(h => h.replace(/^"|"$/g, '').trim());
            staffData = lines.map(line => {
              const cols = line.split(/,(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/).map(c => c.replace(/^"|"$/g, '').trim());
              const obj = {};
              hdr.forEach((h, i) => { obj[h] = cols[i] || ''; });
              return {
                staff: (obj.staff || obj.name || obj['담당자'] || obj['이름'] || '').toString().trim(),
                region: (obj.region || obj['지역'] || '').toString().trim(),
                school: (obj.school || obj['학교'] || obj['schoolName'] || '').toString().trim(),
                establish: obj.establish || obj['설립'] || '',
                level: obj.level || obj['학년'] || '',
                g1_class: obj.g1_class || obj['g1_class'] || obj['1학년_반수'] || '',
                g1_students: obj.g1_students || obj['g1_students'] || obj['1학년_학생수'] || '',
                feature: obj.feature || ''
              };
            });
          }
          console.log('Loaded staff CSV from', path, 'rows:', staffData.length);
          return;
        } catch (e) {
          /* try next candidate */
          continue;
        }
      }
      console.log('No staff CSV found in candidates; continuing with empty staffData.');
    } catch (e) { console.warn('loadStaffCSV failed', e); }
  }
      console.log('staffParam:', staffParam);
      // initialize generatedSummary textarea with report intro header
      const gen = document.getElementById('generatedSummary');
      if (gen) {
        // if textarea contains the placeholder text, replace with intro
        const cur = (gen.value || '').trim();
        if (!cur || cur === '요약이 여기에 생성됩니다.') {
          // use writeGeneratedSummary replace to ensure readonly handling is consistent
          writeGeneratedSummary(reportIntro(), { replace: true });
        }
      }
  // ensure CSV is loaded before attempting to map regions/schools
  try { await loadStaffCSV(); } catch(e) { /* ignore */ }
  const matchedRowsExact = staffData.filter(d => d.staff === staffParam);
      let matchedRows = matchedRowsExact.slice();
      // normalize staff names (remove common titles like '부장') for tolerant matching
      const normalizeStaff = s => (s||'').toString().replace(/\s*(부장|차장|과장|팀장|대리|사원|선생님|선생)/g, '').trim();
      // tolerant mappings for common latin usernames -> Korean names (keys are lowercase)
      const staffMap = {
        'songhoonjae': '송훈재',
        'choyounghwan': '조영환',
        'limjunho': '임준호'
      };
      // if no exact matches, try mapping or partial contains matches
      if (!matchedRows.length) {
        const lowerParam = (staffParam || '').toString().toLowerCase();
        if (staffMap[lowerParam]) {
          const mapped = staffMap[lowerParam];
          // compare using normalized names so titles like '차장' won't prevent a match
          matchedRows = staffData.filter(d => normalizeStaff(d.staff || '') === normalizeStaff(mapped));
          if (matchedRows.length) {
            console.log('Mapped user param', staffParam, '->', mapped);
            staffParam = mapped;
            // update visible staff label to the mapped canonical Korean name + preserved title if any
            try { document.getElementById('staffInfo').textContent = '담당자: ' + (getStaffFromQuery() || mapped); } catch(e){}
          }
        }
      }
      if (!matchedRows.length) {
        // partial contains match: staff names that include param or vice versa
        matchedRows = staffData.filter(d => {
          const a = (d.staff||'').toString();
          const b = (staffParam||'').toString();
          return (a && a.indexOf(b) > -1) || (b && b.indexOf(a) > -1) || (normalizeStaff(a) && normalizeStaff(a).indexOf(normalizeStaff(b)) > -1) || (normalizeStaff(b) && normalizeStaff(b).indexOf(normalizeStaff(a)) > -1);
        });
        if (matchedRows.length) console.log('Partial-match rows found for', staffParam, matchedRows.length);
      }
      console.log('matchedRows count:', matchedRows.length);
      // Update visible staff header so the UI shows the mapped or provided name
      try {
        const infoEl = document.getElementById('staffInfo');
        if (infoEl) {
          const displayName = (typeof getStaffFromQuery === 'function' && getStaffFromQuery()) ? getStaffFromQuery() : (staffParam || '');
          infoEl.textContent = '담당자: ' + (displayName || '-');
        }
      } catch(e) { /* ignore */ }

      let regions = [...new Set(matchedRows.map(d => d.region))];
          // fallback: if this staff has no mapped regions, show all regions and mark as fallback
              let usedFallback = false;
              if (!regions.length) {
                // If staffData isn't loaded yet (e.g. async CSV parse), avoid noisy warnings.
                // Only warn when staffData exists but contains no mapping for this staff.
                if (staffData && staffData.length) {
                  console.warn('No regions found for', staffParam, '- falling back to full region list');
                } else {
                  // staffData empty -> likely still loading; log a gentle info message instead of warning
                  console.log('staffData not loaded or empty; no staff-region mapping available for', staffParam);
                }
                regions = [...new Set((staffData || []).map(d => d.region))];
                usedFallback = true;
              }
              console.log('regions:', regions);
          // create region buttons
          regions.forEach(region => {
            if (region) {
              const btn = document.createElement('button');
              btn.type = 'button';
              btn.className = 'grid-button';
              btn.dataset.region = region;
              btn.setAttribute('role','option');
              btn.setAttribute('aria-selected','false');
              btn.tabIndex = 0;
              btn.textContent = region;
              btn.title = region;
              regionButtons.appendChild(btn);
            }
          });
          try{ if (typeof updateDraftStatus === 'function') updateDraftStatus(); }catch(e){}
          if (usedFallback) {
            const note = document.createElement('div');
            note.style.fontSize = '0.9rem';
            note.style.color = '#666';
            note.style.marginTop = '0.4rem';
            note.textContent = '※ 해당 담당자에 매핑된 학교가 없어 전체 목록을 표시합니다.';
            regionButtons.parentNode.insertBefore(note, regionButtons.nextSibling);
          }
          // selection state
          let selectedRegion = '';
          let selectedSchool = '';
          const schoolButtons = document.getElementById('schoolButtons');
          // delegate region clicks
          regionButtons.addEventListener('click', (ev) => {
            const b = ev.target.closest('.grid-button');
            if (!b) return;
            selectedRegion = b.dataset.region;
            // update selected style and aria
            regionButtons.querySelectorAll('.grid-button').forEach(x => { x.classList.remove('selected'); x.setAttribute('aria-selected','false'); });
            b.classList.add('selected'); b.setAttribute('aria-selected','true');
            // populate schools for selected region
            schoolButtons.innerHTML = '';
            selectedSchool = '';
            let schools = [...new Set(
  staffData.filter(d => 
    d.region === selectedRegion && (d.staff.includes(staffParam) || normalizeStaff(d.staff) === normalizeStaff(staffParam))
  ).map(d => d.school).filter(Boolean)
)];
            // If there are no staff-specific schools for this staff+region, fall back
            // to listing all known schools in the selected region so the UI is usable.
            if (!schools || schools.length === 0) {
              console.log('SCHOOL_FALLBACK', JSON.stringify({ selectedRegion, staffParam: String(staffParam).slice(0,60) }));
              schools = [...new Set(staffData.filter(d => d.region === selectedRegion).map(d => d.school).filter(Boolean))];
            }
            // If no schools found for this staff in the selected region, fall back to
            // listing all schools in the region so the user can still pick one.
            if (!schools.length) {
              const fallbackSchools = [...new Set(staffData.filter(d => d.region === selectedRegion).map(d => d.school))].filter(s => s && s.trim());
              if (fallbackSchools.length) {
                console.warn('No staff-specific schools found for', staffParam, 'in', selectedRegion, '- falling back to region-wide school list');
                // Use the fallback list as the schools to render
                schools.push(...fallbackSchools);
              }
            }
            schools.forEach(school => {
              if (school) {
                const sb = document.createElement('button');
                sb.type = 'button';
                sb.className = 'grid-button';
                sb.dataset.school = school;
                sb.setAttribute('role','option');
                sb.setAttribute('aria-selected','false');
                sb.tabIndex = 0;
                sb.textContent = school;
                sb.title = school;
                schoolButtons.appendChild(sb);
              }
            });
          });
          // delegate school clicks - show metadata and set hidden inputs
          schoolButtons.addEventListener('click', async (ev) => {
            const b = ev.target.closest('.grid-button');
            if (!b) return;
            selectedSchool = b.dataset.school;
            schoolButtons.querySelectorAll('.grid-button').forEach(x => { x.classList.remove('selected'); x.setAttribute('aria-selected','false'); });
            b.classList.add('selected'); b.setAttribute('aria-selected','true');
            // populate hidden inputs and visible display
            document.getElementById('selectedRegionInput').value = selectedRegion;
            document.getElementById('selectedSchoolInput').value = selectedSchool;
            document.getElementById('displayRegion').textContent = selectedRegion;
            document.getElementById('displaySchool').textContent = selectedSchool;
            document.getElementById('selectedInfo').style.display = 'block';
              // 이어쓰기 관련 코드 삭제됨
            // find metadata row (match by staff, region, school)
            const meta = staffData.find(d => d.staff === staffParam && d.region === selectedRegion && d.school === selectedSchool);
            if (meta) {
              // Step2 metadata panel
              document.getElementById('schoolMeta').style.display = 'block';
              (function(){ const el1 = document.getElementById('metaEstablish'); if(el1) el1.textContent = meta.establish || ''; const el2 = document.getElementById('metaLevel'); if(el2) el2.textContent = meta.level || ''; })();
              document.getElementById('metaG1c').textContent = meta.g1_class || '-';
              document.getElementById('metaG1s').textContent = meta.g1_students || '-';
              document.getElementById('metaG2c').textContent = meta.g2_class || '-';
              document.getElementById('metaG2s').textContent = meta.g2_students || '-';
              document.getElementById('metaG3c').textContent = meta.g3_class || '-';
              document.getElementById('metaG3s').textContent = meta.g3_students || '-';
              // update meta-summary pills
              document.getElementById('metaPillEstablish').textContent = (meta.establish || '-');
              document.getElementById('metaPillLevel').textContent = (meta.level || '-');
              // compute total students where numeric
              const toNum = v => { const n = parseInt((v||'').toString().replace(/[^0-9]/g,''),10); return isNaN(n)?0:n; };
              const totalStudents = toNum(meta.g1_students) + toNum(meta.g2_students) + toNum(meta.g3_students);
              document.getElementById('metaPillStudents').textContent = '총학생수: ' + (totalStudents > 0 ? totalStudents : '-');
              // school feature (학교특성) - show only for 고등 schools
              const featureText = meta.feature || '';
              const showFeature = (meta.level || '').toString().indexOf('고등') > -1 && featureText;
              const metaFeatureEl = document.getElementById('metaPillFeature');
              if (metaFeatureEl) {
                metaFeatureEl.textContent = showFeature ? ('특성: ' + featureText) : '';
                metaFeatureEl.style.display = showFeature ? 'inline-block' : 'none';
              }
              // Inline immediate metadata
              document.getElementById('schoolMetaInline').style.display = 'block';
              (function(){ const i1 = document.getElementById('inlineEstablish'); if(i1) i1.textContent = meta.establish || ''; const i2 = document.getElementById('inlineLevel'); if(i2) i2.textContent = meta.level || ''; })();
              document.getElementById('inlineG1c').textContent = meta.g1_class || '-';
              document.getElementById('inlineG1s').textContent = meta.g1_students || '-';
              document.getElementById('inlineG2c').textContent = meta.g2_class || '-';
              document.getElementById('inlineG2s').textContent = meta.g2_students || '-';
              document.getElementById('inlineG3c').textContent = meta.g3_class || '-';
              document.getElementById('inlineG3s').textContent = meta.g3_students || '-';
              document.getElementById('inlinePillEstablish').textContent = (meta.establish || '-');
              document.getElementById('inlinePillLevel').textContent = (meta.level || '-');
              document.getElementById('inlinePillStudents').textContent = '총학생수: ' + (totalStudents > 0 ? totalStudents : '-');
              const inlineFeatureEl = document.getElementById('inlinePillFeature');
              if (inlineFeatureEl) {
                inlineFeatureEl.textContent = showFeature ? ('특성: ' + featureText) : '';
                inlineFeatureEl.style.display = showFeature ? 'inline-block' : 'none';
              }
            } else {
              document.getElementById('schoolMeta').style.display = 'none';
              document.getElementById('schoolMetaInline').style.display = 'none';
            }
            // focus management: move focus to Next button
            document.getElementById('nextStepBtn').focus();
            try{ if (typeof updateDraftStatus === 'function') updateDraftStatus(); }catch(e){}
          });

          // keyboard navigation for grids (arrow keys)
          function makeGridKeyboardNav(container) {
            container.addEventListener('keydown', (ev) => {
              const keys = ['ArrowRight','ArrowLeft','ArrowDown','ArrowUp'];
              if (!keys.includes(ev.key)) return;
              ev.preventDefault();
              const buttons = Array.from(container.querySelectorAll('.grid-button'));
              if (!buttons.length) return;
              const idx = buttons.indexOf(document.activeElement);
              let next = 0;
              if (ev.key === 'ArrowRight' || ev.key === 'ArrowDown') next = (idx + 1) % buttons.length;
              if (ev.key === 'ArrowLeft' || ev.key === 'ArrowUp') next = (idx - 1 + buttons.length) % buttons.length;
              buttons[next].focus();
            });
          }
          makeGridKeyboardNav(regionButtons);
          makeGridKeyboardNav(schoolButtons);

          // next step button: read selected region/school from button state
          document.getElementById('nextStepBtn').addEventListener('click', function() {
            // 방문일 필수 검사
            const vd = document.getElementById('visitDate');
            if (!vd || !vd.value) {
              alert('방문일을 입력하세요.');
              vd && vd.focus();
              return;
            }
            // `selectedRegion` and `selectedSchool` captured in closure above
            if (!selectedRegion || !selectedSchool) {
              alert('지역과 학교명을 모두 선택하세요.');
              return;
            }
            // set visible fields in step2 if needed (e.g., fill a display or hidden inputs)
            const blocks = document.querySelectorAll('.subject-name');
            if (blocks && blocks.length) {
              // no-op now; could prefill schoolName into a hidden input if desired
            }
            // reset time fields each time we enter step2
            try { resetTimeFields(); } catch(e){}
            // hide step1 / show step2 (user-initiated)
            document.getElementById('step1').style.display = 'none';
            document.getElementById('step2').style.display = 'block';
            // Ensure the top of the newly visible content is shown (some browsers/webviews
            // keep the previous scroll position which causes the bottom of step2 to appear).
            try {
              // Preferred: scroll to top using modern API
              if (typeof window.scrollTo === 'function') window.scrollTo({ top: 0, behavior: 'auto' });
              // Extra: reset document scroll positions for older engines / webviews
              if (document.body) document.body.scrollTop = 0;
              if (document.documentElement) document.documentElement.scrollTop = 0;
            } catch (e) { /* ignore scroll failures */ }
          });
          // ---------------- NEIS timetable integration ----------------
          // load reusable NEIS grid helpers
          (function(){
            // Load neis_grid.js defensively: fetch first and ensure
            // response is JS (not an HTML 404 page) before injecting.
            (async function(){
              try{
                const resp = await fetch('neis_grid.js', { cache: 'no-store' });
                if (!resp || !resp.ok) return;
                const ctype = resp.headers && resp.headers.get ? (resp.headers.get('content-type')||'') : '';
                const text = await resp.text();
                if (ctype.toLowerCase().includes('text/html') || (text && text.trim().startsWith('<'))) {
                  console.warn('Skipping neis_grid.js because response looks like HTML');
                  return;
                }
                // Inject as inline script to avoid executing HTML
                const s = document.createElement('script');
                s.type = 'text/javascript';
                s.text = text;
                document.head.appendChild(s);
              }catch(e){ console.warn('Failed to load neis_grid.js', e); }
            })();
          })();
          const NEIS_KEY = '94bb8b0dc511401387d36eb3f6d10905'; // user-provided key
          // map region labels to NEIS 교육청(atpt) codes.
          // staffData.region values are often detailed (e.g. "경기도수원시권선구"),
          // so resolve by exact match first, then by substring prefix match.
          const regionToAtptCode = { '서울':'B10', '인천':'I10', '경기':'J10', '서울특별시':'B10', '인천광역시':'I10', '경기도':'J10' };
          function resolveAtptCodeForRegion(regionLabel){
            if (!regionLabel) return '';
            // 1) Prefer CSV-derived mapping if available
            try{
              const csvMap = window.atptCsvMap || {};
              // CSV 기반 매핑은 정확한 키(정확한 지역/교육청명)가 있을 때만 우선 사용
              if (csvMap[regionLabel]) return csvMap[regionLabel];
            } catch(e){ /* ignore csv map errors */ }
            // 2) fall back to bundled regionToAtptCode
            if (regionToAtptCode[regionLabel]) return regionToAtptCode[regionLabel];
            const keys = Object.keys(regionToAtptCode).sort((a,b)=>b.length-a.length);
            for (const k of keys){ if (regionLabel.indexOf(k) !== -1) return regionToAtptCode[k]; }
            if (regionLabel.indexOf('경기') !== -1) return regionToAtptCode['경기'];
            if (regionLabel.indexOf('서울') !== -1) return regionToAtptCode['서울'];
            if (regionLabel.indexOf('인천') !== -1) return regionToAtptCode['인천'];
            return '';
          }

          function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

          function makeNeisUrl(kind, atptCode, sdSchulCode, year, semester, pIndex=1, pSize=1000){
            const endpoint = (kind === 'high') ? 'hisTimetable' : 'misTimetable';
            const params = new URLSearchParams({ KEY: NEIS_KEY, type: 'json', pIndex: String(pIndex), pSize: String(pSize), ATPT_OFCDC_SC_CODE: atptCode, SD_SCHUL_CODE: sdSchulCode, AY: String(year), SEM: String(semester) });
            return `https://open.neis.go.kr/hub/${endpoint}?` + params.toString();
          }

          async function fetchNeisTimetable(kind, atptCode, sdSchulCode, year, semester){
            const url = makeNeisUrl(kind, atptCode, sdSchulCode, year, semester);
            const progress = document.getElementById('timetableProgress');
            if (progress) { progress.style.display = 'block'; progress.textContent = `요청 중: ${sdSchulCode} ...`; }
            try{
              // Debug: log which identifiers we're using for this NEIS request.
              let matched = {};
              try{
                matched = staffData.find(d => d.school === sdSchulCode) || staffData.find(d => d.school && sdSchulCode && d.school.indexOf(sdSchulCode)!==-1) || {};
                const infoFromMap = (window.schoolInfoCodeMap && window.schoolInfoCodeMap[sdSchulCode]) ? window.schoolInfoCodeMap[sdSchulCode] : null;
                console.log('NEIS request', { kind, atptCode, sdSchulCode, year, semester, matchedInfoCode: matched.infoCode || null, infoFromMap, matchedSido: matched.sido || null, matchedOfc: matched.ofc || null });
              } catch(e){ console.warn('NEIS debug log failed', e); }

              // primary request
              console.log('NEIS fetch URL (primary):', url);
              let res = await fetch(url);
              const resText = await res.text();
              console.log('NEIS response (primary) status:', res.status);
              console.log('NEIS response (primary) body (truncated 4k):', resText && resText.substring ? resText.substring(0,4096) : resText);
              if (!res.ok) throw new Error('HTTP ' + res.status + ' - ' + (resText||'') );
              let j = null;
              try{ j = JSON.parse(resText); } catch(e){ console.warn('failed to parse primary NEIS response as JSON', e); j = null; }
              const rootKey = (kind === 'high') ? 'hisTimetable' : 'misTimetable';
              if (!j || !j[rootKey]) {
                // no data block at all
                // 1) Try to resolve NEIS's numeric SD_SCHUL_CODE via schoolInfo endpoint and retry
                try{
                  const schoolInfoUrl = `https://open.neis.go.kr/hub/schoolInfo?KEY=${NEIS_KEY}&type=json&pIndex=1&pSize=10&ATPT_OFCDC_SC_CODE=${encodeURIComponent(atptCode)}&SCHUL_NM=${encodeURIComponent(sdSchulCode)}`;
                  console.log('NEIS attempting schoolInfo lookup to resolve SD_SCHUL_CODE:', schoolInfoUrl);
                  const siRes = await fetch(schoolInfoUrl);
                  const siText = await siRes.text();
                  console.log('NEIS schoolInfo response status:', siRes.status);
                  console.log('NEIS schoolInfo response body (truncated 4k):', siText && siText.substring ? siText.substring(0,4096) : siText);
                  if (siRes.ok){
                    let siJson = null;
                    try{ siJson = JSON.parse(siText); } catch(e){ siJson = null; }
                    const siBlock = siJson && siJson.schoolInfo;
                    const siRows = (Array.isArray(siBlock) && siBlock.length>1 && siBlock[1].row) ? siBlock[1].row : [];
                    if (siRows && siRows.length){
                      const found = siRows[0];
                      const neisSchCode = found.SD_SCHUL_CODE || found.SD_SCHUL_CODE && found.SD_SCHUL_CODE.toString();
                      if (neisSchCode && neisSchCode !== sdSchulCode){
                        console.log('NEIS resolved SD_SCHUL_CODE via schoolInfo:', neisSchCode, '- retrying timetable');
                        const retryUrl2 = makeNeisUrl(kind, atptCode, neisSchCode, year, semester);
                        try{
                          console.log('NEIS fetch URL (schoolInfo-retry):', retryUrl2);
                          const retryRes2 = await fetch(retryUrl2);
                          const retryText2 = await retryRes2.text();
                          console.log('NEIS response (schoolInfo-retry) status:', retryRes2.status);
                          console.log('NEIS response (schoolInfo-retry) body (truncated 4k):', retryText2 && retryText2.substring ? retryText2.substring(0,4096) : retryText2);
                          if (retryRes2.ok){
                            let retryJson2 = null;
                            try{ retryJson2 = JSON.parse(retryText2); } catch(e){ retryJson2 = null; }
                            const retryBlock2 = retryJson2 && retryJson2[rootKey];
                            const retryRows2 = (Array.isArray(retryBlock2) && retryBlock2.length>1 && retryBlock2[1].row) ? retryBlock2[1].row : [];
                            if (retryRows2 && retryRows2.length) return { ok:true, rows: retryRows2 };
                          }
                        } catch(e){ console.warn('NEIS schoolInfo-retry failed', e); }
                      }
                    }
                  }
                } catch(e){ console.warn('NEIS schoolInfo lookup failed', e); }

                // 2) If CSV provides an infoCode for this school, try retrying with that code as SD_SCHUL_CODE once.
                const fallbackCode = (matched && matched.infoCode) ? matched.infoCode : (window.schoolInfoCodeMap && window.schoolInfoCodeMap[sdSchulCode]) || null;
                if (fallbackCode && fallbackCode !== sdSchulCode){
                  console.log('NEIS primary returned no block; retrying with fallback SD_SCHUL_CODE=', fallbackCode);
                  const retryUrl = makeNeisUrl(kind, atptCode, fallbackCode, year, semester);
                  try{
                    console.log('NEIS fetch URL (retry):', retryUrl);
                    const retryRes = await fetch(retryUrl);
                    const retryText = await retryRes.text();
                    console.log('NEIS response (retry) status:', retryRes.status);
                    console.log('NEIS response (retry) body (truncated 4k):', retryText && retryText.substring ? retryText.substring(0,4096) : retryText);
                    if (retryRes.ok){
                      let retryJson = null;
                      try{ retryJson = JSON.parse(retryText); } catch(e){ retryJson = null; }
                      const retryBlock = retryJson && retryJson[rootKey];
                      const retryRows = (Array.isArray(retryBlock) && retryBlock.length>1 && retryBlock[1].row) ? retryBlock[1].row : [];
                      if (retryRows && retryRows.length) return { ok:true, rows: retryRows };
                    }
                  } catch(e){ console.warn('NEIS retry failed', e); }
                }
                return { ok:false, msg: '데이터 없음' };
              }
              // NEIS JSON often: { endpoint: [ { head: [...] }, { row: [...] } ] }
              const block = j[rootKey];
              const rows = (Array.isArray(block) && block.length > 1 && block[1].row) ? block[1].row : [];
              // if rows empty but we have a matched.infoCode different from sdSchulCode, try one more time with that code
              if ((!rows || rows.length===0) && matched && matched.infoCode && matched.infoCode !== sdSchulCode){
                const fallback = matched.infoCode;
                console.log('NEIS returned no rows; attempting fallback SD_SCHUL_CODE=', fallback);
                try{
                  const retryUrl = makeNeisUrl(kind, atptCode, fallback, year, semester);
                  console.log('NEIS fetch URL (fallback):', retryUrl);
                  const retryRes = await fetch(retryUrl);
                  const retryText = await retryRes.text();
                  console.log('NEIS response (fallback) status:', retryRes.status);
                  console.log('NEIS response (fallback) body (truncated 4k):', retryText && retryText.substring ? retryText.substring(0,4096) : retryText);
                  if (retryRes.ok){
                    let retryJson = null;
                    try{ retryJson = JSON.parse(retryText); } catch(e){ retryJson = null; }
                    const retryBlock = retryJson && retryJson[rootKey];
                    const retryRows = (Array.isArray(retryBlock) && retryBlock.length>1 && retryBlock[1].row) ? retryBlock[1].row : [];
                    if (retryRows && retryRows.length) return { ok:true, rows: retryRows };
                  }
                } catch(e){ console.warn('NEIS fallback fetch failed', e); }
              }
              return { ok:true, rows };
            } catch(e){
              return { ok:false, msg: e && e.message ? e.message : String(e) };
            } finally{
              if (progress) progress.textContent = '';
            }
          }

          function renderTimetableRows(rows, title, containerId){
            const container = document.getElementById(containerId || 'timetableContainer');
            if (!container) return;
            const wrapper = document.createElement('div');
            wrapper.style.marginTop = '8px';
            const heading = document.createElement('h4'); heading.textContent = title; heading.style.margin='8px 0';
            wrapper.appendChild(heading);
            if (!rows || !rows.length){
              const p = document.createElement('div'); p.textContent = '해당 학교의 시간표 데이터가 없습니다.'; p.style.color='#666'; wrapper.appendChild(p); container.appendChild(wrapper); return;
            }
            const table = document.createElement('table'); table.style.width='100%'; table.style.borderCollapse='collapse'; table.style.fontSize='11px';
            const thead = document.createElement('thead'); const tbody = document.createElement('tbody');
            const keys = Object.keys(rows[0]);
            const trh = document.createElement('tr');
            keys.forEach(k=>{ const th=document.createElement('th'); th.textContent = k; th.style.border='1px solid #e6eefc'; th.style.padding='6px'; th.style.background='#f7fbff'; th.style.textAlign='left'; trh.appendChild(th); });
            thead.appendChild(trh);
            rows.forEach(r=>{ const tr=document.createElement('tr'); keys.forEach(k=>{ const td=document.createElement('td'); td.textContent = r[k] || ''; td.style.border='1px solid #f2f6ff'; td.style.padding='6px'; tr.appendChild(td); }); tbody.appendChild(tr); });
            table.appendChild(thead); table.appendChild(tbody); wrapper.appendChild(table);
            // CSV download button
            const csv = Papa.unparse(rows);
            const dl = document.createElement('a'); dl.href = 'data:text/csv;charset=utf-8,' + encodeURIComponent(csv); dl.download = title.replace(/\s+/g,'_') + '.csv'; dl.textContent = 'CSV 다운로드'; dl.style.display = 'inline-block'; dl.style.marginTop='6px'; dl.style.color='#0b3a72'; wrapper.appendChild(dl);
            container.appendChild(wrapper);
          }

          // Render timetable as weekday × period × class grid (thin wrapper that delegates to neisGrid)
          function renderTimetableGrid(rows, title, opts={}){
            try{
              // The "방문요일만 보기" UI was removed; default to false unless explicitly provided in opts
              const visitOnly = (opts && opts.showOnlyVisitWeekday !== undefined) ? opts.showOnlyVisitWeekday : false;
              const visitDateVal = opts.visitDate || (document.getElementById('visitDate')||{}).value || null;
              const visitHour = (document.getElementById('visitStartHour')||{}).value || '';
              const visitMinute = (document.getElementById('visitStartMinute')||{}).value || '';
              const visitTimeVal = (visitHour!=='' && visitMinute!=='') ? pad2(visitHour) + ':' + pad2(visitMinute) : (opts.visitTime || null);
              const moduleOpts = { showOnlyVisitWeekday: visitOnly, visitDate: visitDateVal, visitTime: visitTimeVal, periodTimes: opts.periodTimes };
              const containerId = (opts && opts.containerId) ? opts.containerId : 'timetableContainer';
              if (window.neisGrid && typeof window.neisGrid.renderGridTo === 'function'){
                window.neisGrid.renderGridTo(containerId, rows, title, moduleOpts);
              } else {
                // fallback to previous row-table rendering
                renderTimetableRows(rows, title, containerId);
              }
            } catch(e){ console.warn('renderTimetableGrid error', e); renderTimetableRows(rows, title); }
          }

          // button: fetch selected school's timetable
          const btnSingle = document.getElementById('btnFetchSelectedTimetable');
          if (btnSingle) btnSingle.addEventListener('click', async ()=>{
            const year = document.getElementById('neisYear').value || '2025';
            const sem = document.getElementById('neisSemester').value || '2';
            const sd = document.getElementById('selectedSchoolInput').value || '';
            const atpt = resolveAtptCodeForRegion(selectedRegion) || '';
            if (!sd){ alert('먼저 학교를 선택하세요.'); return; }
            if (!atpt){ if (!confirm('선택된 지역의 교육청 코드가 매핑되지 않았습니다. 계속 진행하시겠습니까?')) return; }
              const timetableContainerEl = document.getElementById('timetableContainer');
              if (timetableContainerEl) { timetableContainerEl.innerHTML = ''; timetableContainerEl.style.display = 'none'; }
              const closeBtnEl = document.getElementById('btnCloseTimetable'); if (closeBtnEl) closeBtnEl.style.display = 'none';
            // decide kind by meta.level if possible
            const meta = staffData.find(d=>d.region===selectedRegion && d.school===sd && d.staff===staffParam) || {};
            const kind = (meta.level && meta.level.indexOf('고등')>-1) ? 'high' : 'middle';
            const res = await fetchNeisTimetable(kind, atpt || '', sd, year, sem);
            if (!res.ok){ alert('데이터를 가져오지 못했습니다: ' + (res.msg||'')); return; }
            // If a visit date is selected on the form, show only that weekday's timetable.
            const visitDateVal = (document.getElementById('visitDate')||{}).value || null;
            const vh = (document.getElementById('visitStartHour')||{}).value || '';
            const vm = (document.getElementById('visitStartMinute')||{}).value || '';
            const visitTimeVal = (vh!=='' && vm!=='') ? pad2(vh) + ':' + pad2(vm) : null;
            const visitOnly = !!visitDateVal; // true when a visit date was entered on the page
            renderTimetableGrid(res.rows, `${selectedRegion} - ${sd} (${year} ${sem}학기)`, { showOnlyVisitWeekday: visitOnly, visitDate: visitDateVal, visitTime: visitTimeVal });
            // show the close button and ensure timetable container is visible
            try{ const tc = document.getElementById('timetableContainer'); if (tc) tc.style.display = 'block'; const cb = document.getElementById('btnCloseTimetable'); if (cb) cb.style.display = 'inline-block'; }catch(e){}
          });

          // Inline panel fetch handler (for the small inline school info card)
          const btnInline = document.getElementById('btnFetchSelectedTimetableInline');
          if (btnInline) btnInline.addEventListener('click', async ()=>{
            const year = document.getElementById('inlineNeisYear').value || '2025';
            const sem = document.getElementById('inlineNeisSemester').value || '2';
            const sd = (document.getElementById('selectedSchoolInput')||{}).value || '';
            const atpt = resolveAtptCodeForRegion(selectedRegion) || '';
            if (!sd){ alert('먼저 학교를 선택하세요.'); return; }
            if (!atpt){ if (!confirm('선택된 지역의 교육청 코드가 매핑되지 않았습니다. 계속 진행하시겠습니까?')) return; }
            const timetableContainerEl = document.getElementById('timetableContainerInline');
            if (timetableContainerEl) { timetableContainerEl.innerHTML = ''; timetableContainerEl.style.display = 'none'; }
            const closeBtnEl = document.getElementById('btnCloseTimetableInline'); if (closeBtnEl) closeBtnEl.style.display = 'none';
            const meta = staffData.find(d=>d.region===selectedRegion && d.school===sd && d.staff===staffParam) || {};
            const kind = (meta.level && meta.level.indexOf('고등')>-1) ? 'high' : 'middle';
            const res = await fetchNeisTimetable(kind, atpt || '', sd, year, sem);
            if (!res.ok){ alert('데이터를 가져오지 못했습니다: ' + (res.msg||'')); return; }
            const visitDateVal = (document.getElementById('visitDate')||{}).value || null;
            const vh = (document.getElementById('visitStartHour')||{}).value || '';
            const vm = (document.getElementById('visitStartMinute')||{}).value || '';
            const visitTimeVal = (vh!=='' && vm!=='') ? pad2(vh) + ':' + pad2(vm) : null;
            const visitOnly = !!visitDateVal;
            renderTimetableGrid(res.rows, `${selectedRegion} - ${sd} (${year} ${sem}학기)`, { showOnlyVisitWeekday: visitOnly, visitDate: visitDateVal, visitTime: visitTimeVal, containerId: 'timetableContainerInline' });
            try{ const tc = document.getElementById('timetableContainerInline'); if (tc) tc.style.display = 'block'; const cb = document.getElementById('btnCloseTimetableInline'); if (cb) cb.style.display = 'inline-block'; }catch(e){}
          });

          // Note: region-wide fetch UI removed. If you need bulk fetching later, reintroduce a controlled UI and
          // a server-side proxy to avoid client-side API key exposure.
          // --- duration buttons and time calculation ---
          // create duration buttons 10,20,...,90
          const durationContainer = document.getElementById('durationButtons');

          // Close timetable button handler
          const btnCloseTimetable = document.getElementById('btnCloseTimetable');
          if (btnCloseTimetable){
            btnCloseTimetable.addEventListener('click', ()=>{
              try{
                const tc = document.getElementById('timetableContainer'); if (tc) { tc.innerHTML = ''; tc.style.display = 'none'; }
                btnCloseTimetable.style.display = 'none';
                const progress = document.getElementById('timetableProgress'); if (progress) progress.textContent = '';
              }catch(e){ console.warn('close timetable failed', e); }
            });
          }
          // Inline close button handler
          const btnCloseTimetableInlineEl = document.getElementById('btnCloseTimetableInline');
          if (btnCloseTimetableInlineEl){
            btnCloseTimetableInlineEl.addEventListener('click', ()=>{
              try{
                const tc = document.getElementById('timetableContainerInline'); if (tc) { tc.innerHTML = ''; tc.style.display = 'none'; }
                btnCloseTimetableInlineEl.style.display = 'none';
                const progress = document.getElementById('timetableProgressInline'); if (progress) progress.textContent = '';
              }catch(e){ console.warn('close inline timetable failed', e); }
            });
          }
          const durationValues = [10,20,30,40,50,60,70,80,90];
          durationValues.forEach(v => {
            const db = document.createElement('button');
            db.type = 'button';
            db.className = 'grid-button';
            db.dataset.minutes = String(v);
            db.textContent = v + '분';
            db.title = v + '분';
            durationContainer.appendChild(db);
          });

          // support both old input (#visitStart) and new selects (#visitStartHour/#visitStartMinute)
          const visitStartInput = document.getElementById('visitStart');
          const visitStartHour = document.getElementById('visitStartHour');
          const visitStartMinute = document.getElementById('visitStartMinute');
          const visitEndInput = document.getElementById('visitEnd');
          const visitDurationInput = document.getElementById('visitDuration');
          const selectedDurationInput = document.getElementById('selectedDurationInput');
          const clearDurationBtn = document.getElementById('clearDuration');

          function pad2(n){ return (n<10? '0' : '') + n; }
          function computeEndFromStartAndMinutes(startValue, minutes){
            if (!startValue) return '';
            // startValue is 'HH:MM'
            const parts = startValue.split(':');
            if (parts.length < 2) return '';
            let hh = parseInt(parts[0],10);
            let mm = parseInt(parts[1],10);
            if (isNaN(hh) || isNaN(mm)) return '';
            const total = hh*60 + mm + Number(minutes);
            const endHH = Math.floor((total % (24*60)) / 60);
            const endMM = total % 60;
            return pad2(endHH) + ':' + pad2(endMM);
          }

          // reset time-related fields (start selects, duration buttons/inputs, end input)
          function resetTimeFields() {
            try {
              const vsh = document.getElementById('visitStartHour');
              const vsm = document.getElementById('visitStartMinute');
              const vdur = document.getElementById('visitDuration');
              const sdur = document.getElementById('selectedDurationInput');
              const durContainer = document.getElementById('durationButtons');
              const vend = document.getElementById('visitEnd');
              if (vsh) vsh.value = pad2(8);
              if (vsm) vsm.value = pad2(0);
              if (vdur) vdur.value = '';
              if (sdur) sdur.value = '';
              if (durContainer) durContainer.querySelectorAll('.grid-button').forEach(b=>b.classList.remove('selected'));
              if (vend) vend.value = '';
            } catch(e) { console.warn('resetTimeFields error', e); }
          }
          // initialize time fields on page load
          try { resetTimeFields(); } catch(e){}

          // populate hour/minute selects (00-23, 00-59) and set default to current time
          if (visitStartHour && visitStartMinute) {
            // clear any existing options
            visitStartHour.innerHTML = '';
            visitStartMinute.innerHTML = '';
            // start hours at 08시 (skip early-morning hours)
            for (let h = 8; h < 24; h++){
              const o = document.createElement('option'); o.value = pad2(h); o.textContent = pad2(h) + '시'; visitStartHour.appendChild(o);
            }
            for (let m = 0; m < 60; m += 5){
              const o = document.createElement('option'); o.value = pad2(m); o.textContent = pad2(m) + '분'; visitStartMinute.appendChild(o);
            }
            const now = new Date();
            // default hour set to 08 on landing
            visitStartHour.value = pad2(8);
            // round minutes to nearest 5-minute interval and clamp (e.g., 58 -> 55)
            let roundedMin = Math.round(now.getMinutes() / 5) * 5;
            if (roundedMin >= 60) roundedMin = 55;
            visitStartMinute.value = pad2(roundedMin);
          }

          // click handler for duration buttons
          durationContainer.addEventListener('click', (ev) => {
            const b = ev.target.closest('.grid-button');
            if (!b) return;
            const minutes = Number(b.dataset.minutes || 0);
            // style selected
            durationContainer.querySelectorAll('.grid-button').forEach(x => x.classList.remove('selected'));
            b.classList.add('selected');
            // set numeric input and hidden
            visitDurationInput.value = minutes;
            selectedDurationInput.value = minutes;
            // compute end time if start present (support old input or new selects)
            const startVal = visitStartInput ? visitStartInput.value : (visitStartHour && visitStartMinute ? (visitStartHour.value + ':' + visitStartMinute.value) : '');
            const endVal = computeEndFromStartAndMinutes(startVal, minutes);
            if (endVal) visitEndInput.value = endVal;
          });

          // when start time changes, recompute end if duration exists
          const onStartChange = () => {
            const minutes = Number(selectedDurationInput.value || visitDurationInput.value || 0);
            if (minutes > 0) {
              const startVal = visitStartInput ? visitStartInput.value : (visitStartHour && visitStartMinute ? (visitStartHour.value + ':' + visitStartMinute.value) : '');
              const endVal = computeEndFromStartAndMinutes(startVal, minutes);
              if (endVal) visitEndInput.value = endVal;
            }
          };
          if (visitStartInput) visitStartInput.addEventListener('change', onStartChange);
          if (visitStartHour) visitStartHour.addEventListener('change', onStartChange);
          if (visitStartMinute) visitStartMinute.addEventListener('change', onStartChange);

          // allow manual numeric input of duration (keeps buttons unselected)
          visitDurationInput.addEventListener('input', () => {
            const v = Number(visitDurationInput.value || 0);
            selectedDurationInput.value = v > 0 ? v : '';
            // clear selected button states if not equal to a button value
            durationContainer.querySelectorAll('.grid-button').forEach(x => x.classList.toggle('selected', Number(x.dataset.minutes) === v));
            if (v > 0) {
              const startVal = visitStartInput ? visitStartInput.value : (visitStartHour && visitStartMinute ? (visitStartHour.value + ':' + visitStartMinute.value) : '');
              const endVal = computeEndFromStartAndMinutes(startVal, v);
              if (endVal) visitEndInput.value = endVal;
            }
          });

          clearDurationBtn.addEventListener('click', () => {
            visitDurationInput.value = '';
            selectedDurationInput.value = '';
            visitEndInput.value = '';
            durationContainer.querySelectorAll('.grid-button').forEach(x => x.classList.remove('selected'));
          });
          
          // contact formatting helper: turn '12345678' -> '010-1234-5678'
          function formatContact(suffix) {
            const digits = (suffix || '').toString().replace(/\D+/g,'').slice(0,8);
            if (!digits) return '';
            if (digits.length <=4) return '010-' + digits;
            return '010-' + digits.slice(0,4) + '-' + digits.slice(4);
          }

          // when contact inputs change, update formatted span
          document.getElementById('subjectsBlock').addEventListener('input', function(e){
            if (e.target && e.target.classList && e.target.classList.contains('contact-suffix')){
              const cleaned = (e.target.value||'').replace(/\D+/g,'').slice(0,8);
              if (cleaned !== e.target.value) e.target.value = cleaned;
              const parent = e.target.closest('.subject-block') || e.target.parentNode;
              const fmt = parent.querySelector('.contact-formatted');
              if (fmt) fmt.textContent = formatContact(cleaned);
            }
          });

          // copy-to-clipboard for contact buttons
          document.getElementById('subjectsBlock').addEventListener('click', function(e){
            if (e.target && e.target.classList && e.target.classList.contains('copy-contact')){
              const sb = e.target.closest('.subject-block');
              if (!sb) return;
              const suffix = sb.querySelector('.contact-suffix') ? sb.querySelector('.contact-suffix').value : '';
              const formatted = formatContact(suffix);
              if (!formatted) { alert('연락처가 입력되어 있지 않습니다.'); return; }
              navigator.clipboard && navigator.clipboard.writeText(formatted);
              // small feedback
              e.target.textContent = '복사됨';
              setTimeout(()=> e.target.textContent = '복사', 1200);
            }
          });
          // subject choice buttons: set hidden .subject-name value and toggle selected style
          document.getElementById('subjectsBlock').addEventListener('click', function(e){
            const btn = e.target.closest('.subject-choice');
            if (!btn) return;
            const sb = btn.closest('.subject-block');
            if (!sb) return;
            // set hidden input value
            const hidden = sb.querySelector('.subject-name');
            if (hidden) hidden.value = btn.dataset.subject || '';
            // toggle selected styling among siblings
            const parent = sb.querySelector('.subjects');
            if (parent) parent.querySelectorAll('.subject-choice').forEach(x => x.classList.remove('selected'));
            btn.classList.add('selected');
            // update buttons that depend on selected subject (정보 -> info-extra, 진로 -> camp button)
            setTimeout(() => { try{ updateInfoButtons(); updateSpecialMeetingButtons(); }catch(e){console.warn('update buttons failed',e);} }, 0);
          });
          // number subject blocks on initial load
          if (typeof renumberSubjectBlocks === 'function') renumberSubjectBlocks();
        });
    // 과목/선생님 추가 기능
    document.getElementById('addSubjectBtn').addEventListener('click', function() {
      // create new subject-block by cloning the canonical template when available
      const tpl = document.getElementById('subject-template');
      let block;
      if (tpl && tpl.content) {
        block = tpl.content.querySelector('.subject-block').cloneNode(true);
      } else if (tpl && tpl.innerHTML) {
        // If template exists but content isn't available (edge case), clone from its innerHTML to preserve exact structure
        try {
          const tmp = document.createElement('div');
          tmp.innerHTML = tpl.innerHTML;
          const candidate = tmp.querySelector('.subject-block');
          if (candidate) block = candidate.cloneNode(true);
        } catch(e) { /* fall through to programmatic builder below */ }
      }
      if (!block) {
        // final fallback: build a simple block programmatically to avoid relying on innerHTML when template is missing
        block = document.createElement('div');
        block.className = 'subject-block';

        // hidden subject name
        const subjHidden = document.createElement('input'); subjHidden.type='hidden'; subjHidden.className='subject-name'; subjHidden.required = true; block.appendChild(subjHidden);

        // subjects button grid
        const subjectsDiv = document.createElement('div'); subjectsDiv.className = 'subjects';
        subjectsDiv.style.display = 'grid'; subjectsDiv.style.gridTemplateColumns = 'repeat(7,1fr)'; subjectsDiv.style.gap = '8px'; subjectsDiv.style.marginBottom = '8px';
        ['정보','진로','보건','미술','체육','도서관사서','특성화','기타'].forEach(s => {
          const b = document.createElement('button'); b.type='button'; b.className='grid-button subject-choice'; b.dataset.subject = s; b.textContent = s; subjectsDiv.appendChild(b);
        });
        block.appendChild(subjectsDiv);

        // teacher name
        const teacherInput = document.createElement('input'); teacherInput.type='text'; teacherInput.className='teacher-name'; teacherInput.placeholder='선생님 이름'; teacherInput.required = true; block.appendChild(teacherInput);

        // publisher select
        const pub = document.createElement('select'); pub.className = 'publisher';
        [{v:'',t:'출판사 선택'},{v:'씨마스',t:'씨마스'},{v:'천재',t:'천재'},{v:'비상',t:'비상'}].forEach(opt => { const o = document.createElement('option'); o.value = opt.v; o.textContent = opt.t; pub.appendChild(o); });
        block.appendChild(pub);

        // conversation textarea
        const ta = document.createElement('textarea'); ta.className='conversation-detail'; ta.rows = 2; ta.placeholder = '특이사항'; block.appendChild(ta);
      }
      // ensure remove button exists and is wired
      try {
        let rem = block.querySelector('.removeSubjectBtn');
        if (!rem) {
          rem = document.createElement('button'); rem.type='button'; rem.className='removeSubjectBtn'; rem.textContent='삭제'; rem.style='margin:0.5rem 0 1rem 0;padding:0.5rem 1rem;font-size:1rem;border-radius:0.7rem;background:#ff9800;color:#fff;border:none;cursor:pointer;';
          block.appendChild(rem);
        }
        rem.onclick = function() { block.remove(); if (typeof renumberSubjectBlocks === 'function') renumberSubjectBlocks(); };
      } catch(e) { /* non-fatal */ }
      // insert the new block directly under the first subject block (so it appears as #2)
      const subjectsContainer = document.getElementById('subjectsBlock');
      const firstBlock = subjectsContainer.querySelector('.subject-block');
      if (firstBlock && firstBlock.parentNode === subjectsContainer) {
        firstBlock.insertAdjacentElement('afterend', block);
      } else {
        subjectsContainer.appendChild(block);
      }
      // renumber after adding
      if (typeof renumberSubjectBlocks === 'function') renumberSubjectBlocks();
    });
    // sanitize contact input: only digits, max 8
    document.getElementById('subjectsBlock').addEventListener('input', function(e) {
      if (e.target && e.target.classList && e.target.classList.contains('contact-suffix')) {
        // remove non-digits and limit to 8
        const cleaned = (e.target.value || '').replace(/\D+/g, '').slice(0,8);
        if (cleaned !== e.target.value) e.target.value = cleaned;
      }
    });
    // 정보 과목 선택 시 추가 버튼 표시 (동적 subject-block에도 적용)
    function updateInfoButtons() {
      // Toggle the 'info' extra buttons per subject-block so each added teacher shows the same UI as the first block.
      document.querySelectorAll('.subject-block').forEach(block => {
        try {
          const sel = block.querySelector('.subject-name');
          const extra = block.querySelector('.info-extra-buttons');
          if (!extra) return;
          const val = sel ? (sel.value || '').trim() : '';
          extra.style.display = (val === '정보') ? 'flex' : 'none';
        } catch(e) { /* ignore per-block errors */ }
      });
    }
        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('subjectsBlock').addEventListener('change', function(e) {
                if (e.target.classList.contains('subject-name')) {
                    updateInfoButtons();
                }
            });
            // 과목/선생님 추가 시에도 이벤트 적용
            document.getElementById('addSubjectBtn').addEventListener('click', function() {
                setTimeout(updateInfoButtons, 100);
            });
        });
          // Special meeting buttons: ensure 단행본안내 exists (no duplicates), 캠프안내 shows only for '진로'
          // and add 교구재안내 next to 단행본안내 when '정보' exists; add 워크북안내 for '진로'.
          function updateSpecialMeetingButtons(){
            try{
              const subjects = Array.from(document.querySelectorAll('.subject-name')).map(s => (s.value||'').trim());
              const hasJinro = subjects.some(v => v === '진로');
              const hasInfo = subjects.some(v => v === '정보');
              // For each subject-block, ensure its primary .meeting-buttons container has a single 단행본안내 and additional buttons as needed.
              // This prevents duplicating the same buttons in the 'info-extra-buttons' area which is a secondary container.
              document.querySelectorAll('.subject-block').forEach(block => {
                const container = block.querySelector('.meeting-buttons'); // first/primary meeting-buttons within the block
                if (!container) return;
                // normalize existing '단행본안내' buttons: keep first, remove duplicates and ensure it has class book-btn
                const existingBooks = Array.from(container.querySelectorAll('.meeting-btn')).filter(x=>x.textContent && x.textContent.trim() === '단행본안내');
                if (existingBooks.length > 1){
                  // keep first, remove rest
                  for (let i=1;i<existingBooks.length;i++){ existingBooks[i].remove(); }
                }
                let book = container.querySelector('.meeting-btn.book-btn');
                if (!book) book = container.querySelector('.meeting-btn') && Array.from(container.querySelectorAll('.meeting-btn')).find(x=>x.textContent.trim()==='단행본안내');
                if (!book){
                  book = document.createElement('button'); book.type='button'; book.className='meeting-btn book-btn'; book.textContent='단행본안내';
                  const chat = Array.from(container.querySelectorAll('.meeting-btn')).find(x=>x.textContent.trim()==='채팅방소개');
                  if (chat && chat.parentNode === container) chat.insertAdjacentElement('afterend', book);
                  else container.appendChild(book);
                } else {
                  // ensure correct class
                  book.classList.add('book-btn');
                }

                // 교구재안내 (정보 전용) - only in the primary container
                let edu = container.querySelector('.edu-kit-btn');
                if (!edu){ edu = document.createElement('button'); edu.type='button'; edu.className='meeting-btn edu-kit-btn'; edu.textContent='교구재안내'; edu.style.display='none'; }
                if (!edu.parentNode || edu.parentNode !== container) {
                  if (book && book.parentNode === container) book.insertAdjacentElement('afterend', edu);
                  else container.appendChild(edu);
                }
                edu.style.display = hasInfo ? '' : 'none';

                // 캠프안내 (toggle visibility based on hasJinro) - primary container only
                let camp = container.querySelector('.camp-btn');
                if (!camp){
                  camp = document.createElement('button'); camp.type='button'; camp.className='meeting-btn camp-btn'; camp.textContent='캠프안내'; camp.style.display='none'; container.appendChild(camp);
                }
                camp.style.display = hasJinro ? '' : 'none';

                // 워크북안내 (진로 전용) - primary container only
                let wb = container.querySelector('.workbook-btn');
                if (!wb){ wb = document.createElement('button'); wb.type='button'; wb.className='meeting-btn workbook-btn'; wb.textContent='워크북안내'; wb.style.display='none'; }
                if (!wb.parentNode || wb.parentNode !== container) {
                  if (camp && camp.parentNode === container) camp.insertAdjacentElement('afterend', wb);
                  else container.appendChild(wb);
                }
                wb.style.display = hasJinro ? '' : 'none';
              });
            }catch(e){ console.warn('updateSpecialMeetingButtons failed', e); }
          }
          // ensure special buttons exist on load and when DOM mutates
          document.addEventListener('DOMContentLoaded', function(){ setTimeout(updateSpecialMeetingButtons, 60); const mo = new MutationObserver(()=> setTimeout(updateSpecialMeetingButtons,40)); mo.observe(document.body, { childList:true, subtree:true }); });
    // 영업일지 입력
    // delegated handler: toggle meeting button selection (visual only)
    document.getElementById('subjectsBlock').addEventListener('click', function(e){
      const mb = e.target.closest('.meeting-btn');
      if (!mb) return;
      const block = mb.closest('.subject-block');
      if (!block) return;
      // toggle selected state; multiple selections allowed
      mb.classList.toggle('selected');
      // do NOT write markers into the conversation textarea anymore (UI only)
      // keep visibility logic for info-extra-buttons in case a '정보' subject exists
    });

    // helper: send a visit to the backend API (/api/visits) as a single-item visits array
    // This ensures the server will persist a per-entry document in `visit_entries` so
    // entries show up when querying by date (useEntries=true).
    function sendToServer(visit) {
      try {
        // Wrap visit into the expected payload shape: { staff, visits: [ visit ] }
        const staff = (typeof getStaffFromQuery === 'function') ? (getStaffFromQuery() || ((document.getElementById('staffInfo')||{}).textContent || '').replace(/^담당자:\s*/,'')) : '';
        const payload = { staff: staff || '', visits: [ visit ] };
        // non-blocking POST; attach server id to local visit when available
        fetch('/api/visits', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        }).then(resp => {
          if (!resp.ok) throw new Error('HTTP ' + resp.status);
          return resp.json();
        }).then(data => {
          try { console.log('Server saved visit:', data); } catch(e){}
          if (data && data.id) {
            // store returned id for reference
            visit.server_id = data.id;
          }
        }).catch(err => {
          try { console.warn('Failed to send visit to server:', err); } catch(e){}
          // don't block user; optionally notify them
        });
      } catch (e) { try{console.warn('sendToServer error', e);}catch(_){} }
    }

    document.getElementById('salesForm').addEventListener('submit', function(e) {
      e.preventDefault();
      // 방문일 필수 (인라인 에러)
      const vd = document.getElementById('visitDate');
      clearFieldError(vd);
      if (!vd || !vd.value) { showFieldError(vd, '방문일을 입력하세요.'); vd && vd.focus(); return; }
      // Build a visit object from current form and add to dayVisits
      const visitObj = buildCurrentVisitObject();
      // must have school (inline)
      if (!visitObj.school) { const sb = document.querySelector('#schoolButtons .grid-button') || document.getElementById('schoolButtons'); showFieldError(sb || document.getElementById('schoolButtons'), '학교를 선택한 뒤 저장하세요.'); return; }
      // require start/end times
      clearFieldError(document.getElementById('visitStart'));
      clearFieldError(document.getElementById('visitEnd'));
      if (!visitObj.visitStart || !visitObj.visitEnd) {
        if (!visitObj.visitStart) {
          const vsEl = document.getElementById('visitStart') || document.getElementById('visitStartHour') || document.getElementById('visitStartMinute');
          if (vsEl) showFieldError(vsEl, '방문 시작 시간을 입력하세요.');
        }
        if (!visitObj.visitEnd) {
          const ve = document.getElementById('visitEnd');
          if (ve) { showFieldError(ve, '방문 종료 시간을 입력하세요.'); ve.focus(); ve.scrollIntoView({ behavior: 'smooth', block: 'center' }); }
        }
        return;
      }
  const ta = document.getElementById('generatedSummary');
  const defaultHint = '요약이 여기에 생성됩니다.';
  // debug logging
  try { console.log('submit: visitObj=', visitObj); console.log('submit: dayVisits length before=', dayVisits.length); } catch(e){}
      if (editingVisitIndex >= 0) {
        // update existing visit
        dayVisits[editingVisitIndex] = visitObj;
        resetEditState();
        renderVisitsList();
        // rebuild the textarea from all visits so the accumulated text stays consistent
        if (ta) {
          const rebuilt = dayVisits.map((v,i) => formatVisitText(v,i)).join('\n');
          writeGeneratedSummary(rebuilt, { replace: true });
        }
        // start autosave after submit/edit so generatedSummary is kept in sync
        try { if (window.__cmassStartAutoSave) window.__cmassStartAutoSave(); } catch(e){}
        alert('방문 내용이 수정되어 저장되었습니다.');
        // send updated visit to server (best-effort)
        try { sendToServer(visitObj); } catch(e){}
      } else {
        dayVisits.push(visitObj);
        renderVisitsList();
        // append this visit's formatted text to the generatedSummary textarea
        if (ta) {
          // debug log
          try { console.log('submit: textarea current value length=', (ta.value||'').length); } catch(e){}
          // prepare formatted text and append via robust writer
          const formatted = formatVisitText(visitObj, dayVisits.length - 1);
          try { console.log('submit: formatted text=', formatted); } catch(e){}
          // if default hint present, replace; otherwise append
          if ((ta.value||'').trim() === defaultHint) writeGeneratedSummary(formatted, { replace: true });
          else writeGeneratedSummary(formatted, { replace: false });
          // start autosave after a new visit is appended
          try { if (window.__cmassStartAutoSave) window.__cmassStartAutoSave(); } catch(e){}
        } else {
          try { console.warn('submit: generatedSummary textarea not found'); } catch(e){}
        }
        // prepare the form for the next visit while keeping the date
        resetFormForNextVisit();
        alert('현재 방문이 저장되었습니다. 다음 방문을 입력하세요.');
        // send created visit to server (best-effort)
        try { sendToServer(visitObj); } catch(e){}
      }
    });
    // add a small numeric badge to each subject-block so user can distinguish blocks
    function renumberSubjectBlocks(){
          const blocks = Array.from(document.querySelectorAll('.subject-block'));
          blocks.forEach((b,idx) => {
            // numeric badge
            let badge = b.querySelector('.subject-index');
            if (!badge) {
              badge = document.createElement('div');
              badge.className = 'subject-index';
              b.insertBefore(badge, b.firstChild);
            }
            badge.textContent = String(idx+1);

            // Ensure accessible labels are associated with inputs inside each subject-block.
            try {
              // contact suffix input
              const contact = b.querySelector('.contact-suffix');
              if (contact) {
                const cid = 'contact-suffix-' + (idx+1);
                contact.id = cid;
                // try to find the label that refers to 연락처 within this block
                const labels = Array.from(b.querySelectorAll('label'));
                const contactLabel = labels.find(l => (l.textContent||'').indexOf('연락처') !== -1);
                if (contactLabel) contactLabel.htmlFor = cid;
              }

              // followUp select
              const follow = b.querySelector('.followUpSelect');
              if (follow) {
                const fid = 'followup-' + (idx+1);
                follow.id = fid;
                const labels = Array.from(b.querySelectorAll('label'));
                const followLabel = labels.find(l => (l.textContent||'').indexOf('후속') !== -1);
                if (followLabel) followLabel.htmlFor = fid;
              }

              // teacher name input - associate if there is a preceding label (optional)
              const teacher = b.querySelector('.teacher-name');
              if (teacher) {
                const tid = 'teacher-name-' + (idx+1);
                // only set if not already set to avoid clobbering any pre-assigned ids
                if (!teacher.id) teacher.id = tid;
                const labels = Array.from(b.querySelectorAll('label'));
                const teacherLabel = labels.find(l => (l.textContent||'').indexOf('선생님') !== -1);
                if (teacherLabel) teacherLabel.htmlFor = teacher.id;
              }
            } catch (e) { /* non-fatal: continue numbering even if label wiring fails */ }
          });
    }
    // 뒤로 버튼: Step2 → Step1로 복귀
    const backBtnEl = document.getElementById('backBtn');
    if (backBtnEl) {
      backBtnEl.addEventListener('click', function(){
        const s2 = document.getElementById('step2'); if (s2) s2.style.display = 'none';
        const s1 = document.getElementById('step1'); if (s1) s1.style.display = 'block';
        // restore focus to Next button for quick navigation
        const next = document.getElementById('nextStepBtn'); if (next) next.focus();
      });
    }

    // Generate a human-friendly summary from current form state
    function generateSummary(){
      const date = document.getElementById('visitDate') ? document.getElementById('visitDate').value : '';
      const staff = document.getElementById('staffInfo') ? document.getElementById('staffInfo').textContent.replace('담당자: ','') : '';
      const region = document.getElementById('displayRegion') ? document.getElementById('displayRegion').textContent : '';
      const school = document.getElementById('displaySchool') ? document.getElementById('displaySchool').textContent : '';
      const start = (document.getElementById('visitStartHour') && document.getElementById('visitStartMinute')) ? (document.getElementById('visitStartHour').value + ':' + document.getElementById('visitStartMinute').value) : '';
      const end = document.getElementById('visitEnd') ? document.getElementById('visitEnd').value : '';
      const blocks = Array.from(document.querySelectorAll('.subject-block'));
      let out = '';
      out += (date ? `□ 일시: ${date}\n\n` : '');
      out += (staff ? `담당자: ${staff}\n` : '');
      if (region || school) out += `대상: ${region} / ${school}\n`;
      if (start || end) out += `방문: ${start} ~ ${end} (${start && end ? calcMinutesInterval(start,end) + '분' : ''})\n\n`;
      out += '세부업무:\n\n';
      blocks.forEach((b, idx) => {
        const subj = b.querySelector('.subject-name') ? b.querySelector('.subject-name').value : '';
        const teacher = b.querySelector('.teacher-name') ? b.querySelector('.teacher-name').value : '';
        const pub = b.querySelector('.publisher') ? b.querySelector('.publisher').value : '';
        const meetings = Array.from(b.querySelectorAll('.meeting-btn.selected')).map(x => x.textContent.trim());
        const follow = b.querySelector('.followUpSelect') ? b.querySelector('.followUpSelect').value : '';
        const contact = b.querySelector('.contact-suffix') ? b.querySelector('.contact-suffix').value : '';
        const notes = b.querySelector('.conversation-detail') ? b.querySelector('.conversation-detail').value : '';
        out += `${idx+1}. ${subj} (${teacher}${pub? ' / '+pub : ''})\n`;
        if (meetings.length) out += `- 진행: ${meetings.join(', ')}\n`;
  // contact is intentionally omitted from the on-page summary; it's kept for backend only
        if (follow) out += `- 후속조치: ${follow}\n`;
        if (notes) out += `- 특이사항: ${notes}\n`;
        out += '\n';
      });
      // summary stats
      const totalSchools = document.querySelectorAll('#schoolButtons .grid-button.selected').length ? 1 : 0; // simple heuristic
      out += `※ 특이사항 ※\n- 방문학교 : ${totalSchools} 개교\n`;
      // auto-tags: generate from current form visit object and append
      try{
        const maxTags = parseInt(document.getElementById('optMaxTags')?.value) || 8;
        const visitObj = (typeof buildCurrentVisitObject === 'function') ? buildCurrentVisitObject() : null;
        if (visitObj) {
          const tags = buildAutoTags([visitObj], maxTags);
          if (tags && tags.length) out += `\n자동 태그: ${tags.join(', ')}`;
        }
      }catch(e){ console.warn('generateSummary: autotag failed', e); }
      // set into textarea
      const ta = document.getElementById('generatedSummary'); if (ta) ta.value = out;
    }
    function calcMinutesInterval(start, end){
      if (!start || !end) return '';
      const [sh, sm] = start.split(':').map(n=>parseInt(n,10));
      const [eh, em] = end.split(':').map(n=>parseInt(n,10));
      const s = sh*60 + sm; const e = eh*60 + em; let diff = e - s; if (diff < 0) diff += 24*60; return diff;
    }
  document.getElementById('genSummaryBtn')?.addEventListener('click', generateSummary);

  // --- Auto-save feature: after user clicks '입력 완료' enable live autosave of the generated summary
  (function(){
    const AUTO_SAVE_PREFIX = 'cmass_autosave_';
    let autoSaveActive = false;
    let autoSaveDebounce = null;
    let autoSaveIntervalId = null;
    let midnightTimeoutId = null;

    function pad2num(n){ return (n<10? '0' : '') + String(n); }
    function todayKey(){ const d=new Date(); return AUTO_SAVE_PREFIX + d.getFullYear() + '-' + pad2num(d.getMonth()+1) + '-' + pad2num(d.getDate()); }

    function persistGeneratedSummary(){ try{
      const ta = document.getElementById('generatedSummary'); if(!ta) return;
      const payload = { text: ta.value || '', ts: Date.now() };
      localStorage.setItem(todayKey(), JSON.stringify(payload));
    } catch(e){ /* ignore storage errors */ } }

    function loadAutosavedForToday(){ try{
      const raw = localStorage.getItem(todayKey()); if(!raw) return false;
      const parsed = JSON.parse(raw || '{}'); const ta = document.getElementById('generatedSummary'); if(!ta) return false;
      // only populate if user hasn't unlocked manual edit (keep UX predictable)
      try { if (ta.hasAttribute('readonly')) writeGeneratedSummary(parsed.text || '', { replace: true }); }
      catch(e){ ta.value = parsed.text || ''; }
      return true;
    } catch(e){ return false; } }

    function clearAutosaveForToday(){ try{ localStorage.removeItem(todayKey()); }catch(e){} const ta = document.getElementById('generatedSummary'); if(ta) writeGeneratedSummary('', { replace: true }); }

    function scheduleMidnightReset(){ try{ if (midnightTimeoutId) clearTimeout(midnightTimeoutId); const now = new Date(); const next = new Date(now.getFullYear(), now.getMonth(), now.getDate()+1); const ms = next - now; midnightTimeoutId = setTimeout(()=>{ clearAutosaveForToday(); scheduleMidnightReset(); }, ms); }catch(e){} }

    function startAutoSave(){ if (autoSaveActive) return; autoSaveActive = true;
      // seed immediately
      generateSummary(); persistGeneratedSummary();
      const form = document.getElementById('salesForm');
      if (!form) return;
      const handler = function(){ if (autoSaveDebounce) clearTimeout(autoSaveDebounce); autoSaveDebounce = setTimeout(()=>{ const ta = document.getElementById('generatedSummary'); if (ta && ta.hasAttribute('readonly')) { generateSummary(); persistGeneratedSummary(); } }, 400); };
      form.addEventListener('input', handler);
      form.addEventListener('change', handler);
      // periodic backup
      autoSaveIntervalId = setInterval(()=>{ const ta = document.getElementById('generatedSummary'); if(ta && ta.hasAttribute('readonly')) persistGeneratedSummary(); }, 15000);
      // if user toggles edit mode back to readonly, immediately persist current generated text
      const editBtn = document.getElementById('summaryEditToggleBtn'); if(editBtn){ editBtn.addEventListener('click', ()=>{ setTimeout(()=>{ const ta = document.getElementById('generatedSummary'); if(ta && ta.hasAttribute('readonly')){ generateSummary(); persistGeneratedSummary(); } }, 50); }); }
      scheduleMidnightReset();
    }

    function stopAutoSave(){ if(!autoSaveActive) return; autoSaveActive = false; if(autoSaveIntervalId) clearInterval(autoSaveIntervalId); if(midnightTimeoutId) clearTimeout(midnightTimeoutId); }

    // expose startAutoSave for use after submit
    window.__cmassStartAutoSave = startAutoSave;

  // persist visits array for today (so back-navigation / rotation won't lose appended visits)
  function persistDayVisits(){ try{ const key = todayKey() + '_visits'; const payload = { visits: (window.dayVisits || []), ts: Date.now() }; localStorage.setItem(key, JSON.stringify(payload)); }catch(e){} }
  function loadDayVisits(){ try{ const key = todayKey() + '_visits'; const raw = localStorage.getItem(key); if(!raw) return false; const parsed = JSON.parse(raw||'{}'); if (parsed && Array.isArray(parsed.visits)) { window.dayVisits = parsed.visits; try{ renderVisitsList(); const ta = document.getElementById('generatedSummary'); if(ta){ const rebuilt = (window.dayVisits || []).map((v,i)=> formatVisitText(v,i)).join('\n'); writeGeneratedSummary(rebuilt, { replace: true }); } }catch(e){} return true; } }catch(e){} return false; }

  // Handles:
  // - already 'YYYY-MM-DD' strings (returned as-is)
  // - ISO strings like '2025-10-25T00:00:00.000Z' (returns '2025-10-25')
  // - other parseable date formats (falls back to constructing a Date and using UTC ISO date)
  function normalizeDateForInput(val){
    if (!val && val !== 0) return '';
    try{
      const s = String(val).trim();
      if (/^\d{4}-\d{2}-\d{2}$/.test(s)) return s;
      // common ISO with time component
      const m = s.match(/^(\d{4}-\d{2}-\d{2})T/);
      if (m && m[1]) return m[1];
      // fallback: try Date parsing and return UTC yyyy-mm-dd
      const d = new Date(s);
      if (!isNaN(d.getTime())) return d.toISOString().slice(0,10);
    }catch(e){}
    return '';
  }

  // 이어쓰기 관련 코드 전체 삭제됨

  // ensure we persist current state on pagehide / beforeunload and when orientation changes
  function persistAllNow(){ try{ persistGeneratedSummary(); persistDayVisits(); }catch(e){} }
  window.addEventListener('pagehide', persistAllNow);
  window.addEventListener('beforeunload', persistAllNow);
  window.addEventListener('visibilitychange', function(){ if (document.visibilityState === 'hidden') persistAllNow(); });
  // also persist before/after resize/orientation to reduce risk of loss during rotation
  window.addEventListener('orientationchange', persistAllNow);
  window.addEventListener('resize', function(){ /* small debounce not needed here */ persistAllNow(); });

  // load today's autosaved content and any persisted visit list on load if present
  document.addEventListener('DOMContentLoaded', function(){ loadAutosavedForToday(); loadDayVisits(); scheduleMidnightReset(); });
  })();

  // Allow user to manually edit the generated summary and prevent overwrites.
  document.addEventListener('DOMContentLoaded', function(){
    const ta = document.getElementById('generatedSummary');
    const editBtn = document.getElementById('summaryEditToggleBtn');
    const regenBtn = document.getElementById('summaryRegenerateBtn');
    if (ta) {
      ta.addEventListener('input', function(){
        // ignore programmatic input events triggered by writeGeneratedSummary
        if (_suppressSummaryInputHandler) return;
        // only consider manual edits when the textarea is editable
        if (!ta.hasAttribute('readonly')) {
          manualSummaryEdited = true;
          if (editBtn) editBtn.textContent = '수정 완료';
        }
      });
    }
    // ensure the edit button shows the default '수정' label on initial load
    if (editBtn) editBtn.textContent = '수정';
    if (editBtn) {
      editBtn.addEventListener('click', function(){
        if (!ta) return;
        if (ta.hasAttribute('readonly')) {
          // enter edit mode: allow editing of summary, teacher name and conversation fields
          ta.removeAttribute('readonly');
          ta.focus();
          document.querySelectorAll('.teacher-name, .conversation-detail').forEach(el=>{
            try{ el.removeAttribute('readonly'); el.removeAttribute('disabled'); }catch(e){}
          });
          editBtn.textContent = '수정 완료';
        } else {
          // exit edit mode: lock summary and teacher/conversation fields again
          ta.setAttribute('readonly','');
          document.querySelectorAll('.teacher-name, .conversation-detail').forEach(el=>{
            try{ el.setAttribute('readonly',''); }catch(e){}
          });
          // keep manualSummaryEdited true if the user changed anything
          editBtn.textContent = '수정';
        }
      });
    }
    if (regenBtn) {
      regenBtn.addEventListener('click', async function(){
        try{
          const ok = await showConfirmModal('양식 내용을 모두 지우시겠습니까?');
          if (!ok) return;
        }catch(e){ /* ignore */ }
        // clear the entire form (keep visitDate/staff per resetFormForNextVisit logic)
        try {
          if (typeof resetFormForNextVisit === 'function') resetFormForNextVisit();
        } catch(e){}
        manualSummaryEdited = false;
        try { if (typeof writeGeneratedSummary === 'function') writeGeneratedSummary('', { replace: true }); } catch(e){}
        try { if (typeof clearAutosaveForToday === 'function') clearAutosaveForToday(); } catch(e){}
        // ensure textarea locked and edit button reset
        if (ta) ta.setAttribute('readonly','');
        if (editBtn) editBtn.textContent = '수정';
        try{ showToast('양식이 초기화되었습니다.'); }catch(e){}
      });
    }
    // temporary save button (임시저장)
    try {
      const tempSaveBtn = document.getElementById('summaryTempSaveBtn');
      if (tempSaveBtn) {
        tempSaveBtn.addEventListener('click', function(){
          try {
            const v = (typeof buildCurrentVisitObject === 'function') ? buildCurrentVisitObject() : null;
            const key = (typeof todayKey === 'function') ? (todayKey() + '_draft') : ('draft_' + String(new Date().toISOString()).slice(0,10));
            localStorage.setItem(key, JSON.stringify({ visit: v, ts: Date.now() }));
            try { persistGeneratedSummary(); } catch(e){}
            try { persistDayVisits(); } catch(e){}
            try{ showToast('임시저장되었습니다.'); }catch(e){ }
          } catch(e){ console.warn('temp save failed', e); try{ showToast('임시저장에 실패했습니다.'); }catch(err){} }
        });
      }
    } catch(e){}
  });
    // Ensure canonical subject buttons exist in all subject rows and normalize grid columns to 7.
    (function ensureCanonicalSubjectsAndGrid(){
      function ensure() {
        try{
          document.querySelectorAll('.subjects').forEach(s => {
            try{
              const st = s.getAttribute('style') || '';
              // normalize older 4- and 5-column definitions to 7 columns
              if (st.indexOf('repeat(4,1fr)') !== -1) {
                s.setAttribute('style', st.replace('repeat(4,1fr)', 'repeat(7,1fr)'));
              }
              if (st.indexOf('repeat(5,1fr)') !== -1) {
                s.setAttribute('style', st.replace('repeat(5,1fr)', 'repeat(7,1fr)'));
              }
              // ensure canonical subjects: 정보, 진로, 보건, 미술, 체육, 특성화, 기타
              const subjectsNeeded = [
                { key: '정보', label: '정보' },
                { key: '진로', label: '진로' },
                { key: '보건', label: '보건' },
                { key: '미술', label: '미술' },
                { key: '체육', label: '체육' },
                { key: '특성화', label: '특성화' },
                { key: '기타', label: '기타' }
              ];
              // add missing buttons in canonical order if absent
              subjectsNeeded.forEach(sub => {
                if (!s.querySelector('[data-subject="' + sub.key + '"]')){
                  const btn = document.createElement('button');
                  btn.type = 'button'; btn.className = 'grid-button subject-choice'; btn.dataset.subject = sub.key; btn.textContent = sub.label;
                  s.appendChild(btn);
                }
              });
            }catch(e){/* ignore per-row errors */}
          });
          }catch(e){console.warn('ensureCanonicalSubjectsAndGrid failed', e);}    
        }
      // run once on load and observe DOM changes to keep it consistent
      setTimeout(ensure, 80);
      const mo = new MutationObserver(() => { setTimeout(ensure, 40); });
      mo.observe(document.body, { childList: true, subtree: true });
    })();
  </script>
  <script>
    // Runtime fix: convert any lingering duplicate-meeting-button IDs into classes to avoid duplicate IDs
    (function normalizeMeetingButtonIds(){
      try{
        document.addEventListener('DOMContentLoaded', ()=>{
          ['main-meeting-buttons','info-extra-buttons'].forEach(id => {
            try{
              const nodes = Array.from(document.querySelectorAll('#' + id));
              nodes.forEach(n => {
                n.classList.add(id);
                n.removeAttribute('id');
              });
            }catch(e){}
          });
        });
      }catch(e){/* ignore */}
    })();
  </script>
</body>
</html>

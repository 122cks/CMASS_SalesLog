<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="manifest" href="/manifest.json">
  <meta name="theme-color" content="#1e3c72">
  <title>영업일지 입력</title>
  <script src="/collectFormData.js"></script>
  <script>
    // Hard guard: prevent external scripts from wiping core CMASS nodes or replacing the body entirely.
    (function(){
      const LOG_PREFIX = '[cmass hard-guard]';
      const PROTECTED_ATTR = 'data-cmass-protect';
      const PROTECTED_IDS = new Set(['step1','step2','salesForm','cmass-debug-banner','cmass-debug-overlay-top','cmass-body-inspector','cmass-error-overlay','cmass-landscape-overlay']);

      function isProtectedTarget(node){
        try{
          if (!node) return false;
          if (node === document.body || node === document.documentElement) return true;
          if (node.nodeType !== Node.ELEMENT_NODE) return false;
          if (PROTECTED_IDS.has(node.id)) return true;
          if (node.hasAttribute && node.hasAttribute(PROTECTED_ATTR)) return true;
        }catch(e){}
        return false;
      }

      try {
        const originalRemoveChild = Node.prototype.removeChild;
        Node.prototype.removeChild = function(child){
          if (child === document.body || isProtectedTarget(child)) {
            console.warn(LOG_PREFIX, 'blocked removeChild', child && child.id ? ('#'+child.id) : child);
            return child;
          }
          return originalRemoveChild.call(this, child);
        };

        const originalReplaceChild = Node.prototype.replaceChild;
        Node.prototype.replaceChild = function(newChild, oldChild){
          if (oldChild === document.body || isProtectedTarget(oldChild)) {
            console.warn(LOG_PREFIX, 'blocked replaceChild', oldChild && oldChild.id ? ('#'+oldChild.id) : oldChild);
            return oldChild;
          }
          return originalReplaceChild.call(this, newChild, oldChild);
        };

        const originalRemove = Element.prototype.remove;
        Element.prototype.remove = function(){
          if (this === document.body || isProtectedTarget(this)) {
            console.warn(LOG_PREFIX, 'blocked remove()', this && this.id ? ('#'+this.id) : this);
            return this;
          }
          return originalRemove.call(this);
        };

        const originalReplaceChildren = Element.prototype.replaceChildren;
        if (typeof originalReplaceChildren === 'function') {
          Element.prototype.replaceChildren = function(...nodes){
            if (this === document.body || isProtectedTarget(this)) {
              console.warn(LOG_PREFIX, 'blocked replaceChildren on', this && this.id ? ('#'+this.id) : this);
              return this;
            }
            return originalReplaceChildren.apply(this, nodes);
          };
        }

        const originalReplaceWith = Element.prototype.replaceWith;
        if (typeof originalReplaceWith === 'function') {
          Element.prototype.replaceWith = function(...nodes){
            if (this === document.body || isProtectedTarget(this)) {
              console.warn(LOG_PREFIX, 'blocked replaceWith on', this && this.id ? ('#'+this.id) : this);
              return this;
            }
            return originalReplaceWith.apply(this, nodes);
          };
        }

        const innerDesc = Object.getOwnPropertyDescriptor(Element.prototype, 'innerHTML');
        if (innerDesc && innerDesc.configurable) {
          Object.defineProperty(Element.prototype, 'innerHTML', {
            configurable: true,
            enumerable: innerDesc.enumerable,
            get: innerDesc.get,
            set: function(value){
              if (this === document.body || isProtectedTarget(this)) {
                console.warn(LOG_PREFIX, 'blocked innerHTML overwrite on', this && this.id ? ('#'+this.id) : this);
                return;
              }
              return innerDesc.set.call(this, value);
            }
          });
        }

        const textDesc = Object.getOwnPropertyDescriptor(Node.prototype, 'textContent');
        if (textDesc && textDesc.configurable) {
          Object.defineProperty(Node.prototype, 'textContent', {
            configurable: true,
            enumerable: textDesc.enumerable,
            get: textDesc.get,
            set: function(value){
              if (this === document.body || (this.nodeType === Node.ELEMENT_NODE && isProtectedTarget(this))) {
                console.warn(LOG_PREFIX, 'blocked textContent overwrite on', this && this.id ? ('#'+this.id) : this);
                return;
              }
              return textDesc.set.call(this, value);
            }
          });
        }
      } catch (err) {
        console.warn(LOG_PREFIX, 'failed to install hard guard', err);
      }
    })();
  </script>
  <!-- cmass-deploy-marker: 2025-11-02T00:00:00Z -->
  <!-- Load external deps. PapaParse removed in favor of a small in-file toCSV helper. -->
  <script src="/neis_grid.js" defer></script>
  <!-- Early removal of any legacy redirect banners or links to the input page.
    This runs immediately in the head and observes DOM mutations to remove
    any nodes (or anchors) that mention deprecated URLs so users don't see
    stray "Redirecting to input(.html)" messages even briefly. -->
  <script>
    // Lightweight, robust debug + meta helper (rewritten to avoid syntax issues).
    (function(){
      function updateDebugOverlay(){
        try{
          const ov = document.getElementById('cmass-debug-overlay');
          if (!ov) return;
          const s = document.getElementById('dbgStaff'); if (s) s.textContent = (window._cmass_staffParam || (typeof getStaffFromQuery === 'function' ? getStaffFromQuery() : '')) || '-';
          const r = document.getElementById('dbgRegion'); if (r) r.textContent = (window.selectedRegion || window.selectedRegion || '-') ;
          const sc = document.getElementById('dbgSchool'); if (sc) sc.textContent = (window.selectedSchool || (document.getElementById('selectedSchoolInput')||{}).value || '-') ;
          const pm = document.getElementById('dbgMeta');
          const meta = window._cmass_lastFoundMeta || null;
          if (pm) pm.textContent = meta ? JSON.stringify(meta, null, 2) : '(없음)';
          ov.style.display = 'block';
        }catch(e){ console.warn('updateDebugOverlay failed', e); }
      }

      document.addEventListener('click', function(ev){ if (ev.target && ev.target.id === 'dbgHide'){ const el = document.getElementById('cmass-debug-overlay'); if(el) el.style.display='none'; } });
      window.updateDebugOverlay = updateDebugOverlay;
    })();
  </script>

  <script>
    // Draft save / load keyed by 방문일|담당자|지역|학교
    (function(){
      // Remove common legacy redirects if present
      function removeLegacyRedirects(){
        try{
          const walker = document.createTreeWalker(document.body, NodeFilter.SHOW_TEXT, null, false);
          const toRemove = [];
          while(walker.nextNode()){
            const t = walker.currentNode;
            if(/Redirecting to\s*input(\.html)?/i.test(t.nodeValue || '')) toRemove.push(t);
          }
          toRemove.forEach(n => n.parentNode && n.parentNode.removeChild(n));
          const anchors = Array.from(document.querySelectorAll('a[href*="/input"]'));
          anchors.forEach(a => a.remove());
        }catch(e){ /* tolerate */ }
      }

      // Apply meta when available: normalize keys and write to small span ids.
      function applyMeta(meta){
        try{
          console.log('[applyMeta] 호출됨, 메타:', meta);
          if(!meta) { console.warn('[applyMeta] 메타 데이터가 없음'); return; }
          window._cmass_lastFoundMeta = meta;
          // Ensure inline/detailed meta panels are visible when we have meta
          try{
            const inline = document.getElementById('schoolMetaInline');
            const full = document.getElementById('schoolMeta');
            console.log('[applyMeta] DOM 요소:', { inline: !!inline, full: !!full });
            // Remove any explicit 'hidden' utility class (which uses !important) so
            // inline styles can show the panel. Setting style.display alone doesn't
            // override .hidden { display:none !important }.
            if(inline){ 
              console.log('[applyMeta] inline 표시 전 classList:', inline.classList.toString());
              inline.classList.remove('hidden'); 
              inline.style.display = 'block'; 
              console.log('[applyMeta] inline 표시 후 classList:', inline.classList.toString(), 'display:', inline.style.display);
            }
            if(full){ full.classList.remove('hidden'); full.style.display = 'block'; }
          }catch(e){ console.warn('applyMeta show panels failed', e); }

          // helper to resolve multiple possible key names for a value
          function pickMeta(obj, candidates){
            if(!obj) return null;
            for(const k of candidates){ if(typeof obj[k] !== 'undefined' && obj[k] !== null && String(obj[k]).trim() !== '') return obj[k]; }
            return null;
          }

          // populate summary pills (establish / level / students / feature)
          try{
            // broaden candidate keys to match headers present in sales_staff.csv and other sources
            const est = pickMeta(meta, ['설립','설립구분','establish','established','establishment','설립형태']);
            const lvl = pickMeta(meta, ['급','학교급','학교급코드','level','schoolLevel','급별']);
            const tot = pickMeta(meta, ['총학생수','학생수계','studentsTotal','totalStudents','총학생','학생수']);
            const feat = pickMeta(meta, ['특성','학교특성','특성화','특성화고 구분','특성화고','feature','special']);
            console.log('[applyMeta] 추출된 값:', { est, lvl, tot, feat });
            const inlineEst = document.getElementById('inlinePillEstablish'); if(inlineEst) inlineEst.textContent = est ? ('설립: ' + String(est)) : '설립: -';
            const inlineLvl = document.getElementById('inlinePillLevel'); if(inlineLvl) inlineLvl.textContent = lvl ? ('급: ' + String(lvl)) : '급: -';
            const inlineTot = document.getElementById('inlinePillStudents'); if(inlineTot) inlineTot.textContent = tot ? ('총학생수: ' + String(tot)) : '총학생수: -';
            const inlineFeat = document.getElementById('inlinePillFeature'); if(inlineFeat) { inlineFeat.style.display = feat ? '' : 'none'; if(feat) inlineFeat.textContent = '특성: ' + String(feat); }
            console.log('[applyMeta] DOM 업데이트 완료:', { 
              inlineEst: inlineEst?.textContent, 
              inlineLvl: inlineLvl?.textContent, 
              inlineTot: inlineTot?.textContent 
            });

            const midEst = document.getElementById('metaPillEstablish'); if(midEst) midEst.textContent = est ? ('설립: ' + String(est)) : '설립: -';
            const midLvl = document.getElementById('metaPillLevel'); if(midLvl) midLvl.textContent = lvl ? ('급: ' + String(lvl)) : '급: -';
            const midTot = document.getElementById('metaPillStudents'); if(midTot) midTot.textContent = tot ? ('총학생수: ' + String(tot)) : '총학생수: -';
            const midFeat = document.getElementById('metaPillFeature'); if(midFeat) { midFeat.style.display = feat ? '' : 'none'; if(feat) midFeat.textContent = '특성: ' + String(feat); }
          }catch(e){ console.error('[applyMeta] 필드 업데이트 실패:', e); }
          const grades = [1,2,3];
          grades.forEach(g => {
            // Prefer canonical keys created by parseSchoolMetaCsv (g1c, g1s, g1avg)
            const canonicalClassKey = `g${g}c`;
            const canonicalStudentKey = `g${g}s`;
            const canonicalAvgKey = `g${g}avg`;

            let c = null, s = null, avg = null;
            if (meta && typeof meta[canonicalClassKey] !== 'undefined') c = Number(meta[canonicalClassKey]) || c;
            if (meta && typeof meta[canonicalStudentKey] !== 'undefined') s = Number(meta[canonicalStudentKey]) || s;
            if (meta && typeof meta[canonicalAvgKey] !== 'undefined') avg = Number(meta[canonicalAvgKey]) || avg;

            // Fallback to older header name heuristics only if canonical missing
            if ((c === null || Number.isNaN(c)) || (s === null || Number.isNaN(s))) {
              const classKeys = [ `${g}학년학급수`, `${g}학년_학급수`, `${g}학급수`, `${g}학급`, `${g}GradeClassCount` ];
              const studentKeys = [ `${g}학년학생수`, `${g}학년_학생수`, `${g}학생수`, `${g}학생`, `${g}GradeStudentCount` ];
              const avgKeys = [ `${g}학년학급당학생수`, `${g}학급당학생수`, `${g}학급당`, `${g}AvgStudentsPerClass` ];

              for(const k of classKeys) if(meta[k] !== undefined && (c === null || Number.isNaN(c))){ c = Number(meta[k]) || c; }
              for(const k of studentKeys) if(meta[k] !== undefined && (s === null || Number.isNaN(s))){ s = Number(meta[k]) || s; }
              for(const k of avgKeys) if(meta[k] !== undefined && (avg === null || Number.isNaN(avg))){ avg = Number(meta[k]) || avg; }
            }

            // If class count missing but students+avg present, estimate (avoid double counting by only estimating when missing)
            if((c === null || Number.isNaN(c)) && (s !== null && !Number.isNaN(s) && avg !== null && !Number.isNaN(avg) && avg > 0)){
              c = Math.max(1, Math.round(s / avg));
            }

            const idClass = 'inlineG' + g + 'c';
            const idStudent = 'inlineG' + g + 's';
            const elc = document.getElementById(idClass);
            const els = document.getElementById(idStudent);
            if(elc) elc.textContent = (c === null || Number.isNaN(c)) ? '-' : String(c);
            if(els) els.textContent = (s === null || Number.isNaN(s)) ? '-' : String(s);
            // also populate metaG* ids for the detailed panel if present
            const midc = document.getElementById('metaG' + g + 'c');
            const mids = document.getElementById('metaG' + g + 's');
            if(midc) midc.textContent = (c === null || Number.isNaN(c)) ? '-' : String(c);
            if(mids) mids.textContent = (s === null || Number.isNaN(s)) ? '-' : String(s);
          });
          // ensure debug overlay also updates visibility
          if (typeof window.updateDebugOverlay === 'function') window.updateDebugOverlay();
        }catch(e){ console.warn('applyMeta error', e); }
      }

      // Watch for dbgMeta content changes (some code writes JSON there)
      function watchDbgMeta(){
        try{
          const dbg = document.getElementById('dbgMeta');
          if(!dbg) return;
          const mo = new MutationObserver(()=>{
            try{
              const txt = (dbg.textContent || '').trim();
              if(txt && txt !== '(없음)'){
                try{ const parsed = JSON.parse(txt); if(parsed) applyMeta(parsed); }catch(e){}
              }
            }catch(e){}
          });
          mo.observe(dbg, { childList: true, characterData: true, subtree: true });
        }catch(e){}
      }

      // initialize when DOM ready
      document.addEventListener('DOMContentLoaded', function(){ removeLegacyRedirects(); watchDbgMeta(); if(window._cmass_lastFoundMeta) applyMeta(window._cmass_lastFoundMeta); });

  // expose for tests / external code
  window.applyMeta = applyMeta;
    })();
  </script>

  <style>
    /* moved inline CSS into a style block to avoid parser errors */
    /* default to visible in CSS and control visibility via the .hidden class
       This avoids JS needing to manipulate inline styles and reduces specificity bugs */
    #schoolMetaInline, #schoolMeta {
      display:block;
      padding:22px 20px;
      border-radius:14px;
      background:linear-gradient(180deg,#ffffff 0%, #f7f8ff 100%);
      border:1px solid #e2e8ff;
      box-shadow:0 18px 48px rgba(10,28,64,0.12);
      color:#071a2e;
      font-size:16.5px;
      line-height:1.6;
      margin-top:1rem;
      position:relative;
      overflow:visible;
    }
    /* utility class to hide elements regardless of other stylesheet rules */
    .hidden { display:none !important; }
    /* accent stripe on the left (wider for better affordance) */
    #schoolMetaInline::before, #schoolMeta::before {
      content: '';
      position: absolute;
      left: 0;
      top: 8px;
      bottom: 8px;
      width: 10px;
      border-radius: 8px;
      background: linear-gradient(180deg,#556ee8,#6b4bb0);
      box-shadow: 0 4px 14px rgba(80,90,160,0.08);
    }
    #schoolMetaInline h4, #schoolMeta h4 { margin:0 0 .6rem 18px; font-size:19px; color:#06203f; font-weight:900 }
    .grade-rows { display:block; margin-top:12px; }
    .grade-row { display:grid; grid-template-columns:120px 1fr; gap:12px; align-items:center; margin:8px 0; }
    .grade-row .grade-label { font-weight:900; color:#0d304f; font-size:15px }
    .grade-row .grade-value { color:#072042; font-size:15px; display:flex; gap:8px; align-items:baseline }
    .grade-row .grade-value span { font-weight:900; color:#0b2b5a; font-size:17px }
    .meta-key { font-weight:900; font-size:15px; color:#092b4a; }
    .grade-row .small-note { color:#4e5b73; font-size:13px; margin-left:6px }
    .meta-summary { display:flex; gap:14px; margin:8px 12px 6px 12px; }
    .meta-summary .meta-pill { background:#f3f6ff; padding:.45rem .7rem; border-radius:10px; border:1px solid #e0e8ff; color:#082044; font-weight:800; font-size:14px }
  </style>
  <style>
  table.timetable { border-collapse:collapse; width:100%; font-size:11px; line-height:1.12; }
  /* compact cells to reduce wrapping in timetable; use !important to override inline JS styles */
  .timetable-wrapper table.timetable th,
  .timetable-wrapper table.timetable td { border:1px solid #e6eefc; padding:4px 6px !important; font-size:11px !important; vertical-align:top; }
  /* Force single-line cells: prevent wrapping, show ellipsis when truncated, allow horizontal scroll */
  .timetable-wrapper table.timetable th,
  .timetable-wrapper table.timetable td {
    white-space: nowrap !important;
    overflow: hidden !important;
    text-overflow: ellipsis !important;
    max-width: 260px; /* reasonable cap to help ellipsis; adjust as needed */
  }
  /* For narrow mobile screens, cap width tighter */
  @media (max-width:600px) {
    .timetable-wrapper table.timetable th,
    .timetable-wrapper table.timetable td { max-width: 140px; }
  }
  /* sticky header row and sticky first column (반/학급 or 교시) within the scroll wrapper */
  .timetable-wrapper table.timetable thead th { position:sticky; top:0; background:#f7fbff; z-index:3; }
  .timetable-wrapper table.timetable th:first-child,
  .timetable-wrapper table.timetable td:first-child { position:sticky; left:0; background:#f7fbff; z-index:2; }
  /* ensure the top-left corner cell stays above both header and first column */
  .timetable-wrapper table.timetable thead th:first-child { z-index:4; }
  /* Mobile tweaks: slightly smaller font and tighter padding for narrow screens */
  @media (max-width:600px) {
    .timetable-wrapper table.timetable { font-size:10px; }
    .timetable-wrapper table.timetable th,
    .timetable-wrapper table.timetable td { padding:3px 5px !important; font-size:10px !important; }
    .timetable-wrapper { max-height:60vh; }
  }
  .current-period { background:#ffeaa7 !important; border:1px solid #f1c40f !important; }
  </style>
  <style>
  /* Remove all step-related styles */
  .btn-grid { display:grid; grid-template-columns:repeat(3, minmax(0, 1fr)); gap:.5rem; margin-bottom:.7rem; }
    .selector-btn { position:relative; display:flex; flex-direction:column; align-items:center; justify-content:center; gap:6px; padding:.8rem 1rem; border-radius:.8rem; border:1px solid #d6dbe8; background:#fff; color:#12325a; font-weight:700; text-align:center; cursor:pointer; transition:background .2s ease, border-color .2s ease, box-shadow .2s ease; min-height:70px; min-width:0; }
  .selector-btn .selector-label { display:block; font-weight:800; font-size:1.2rem; line-height:1.18; white-space:nowrap; width:100%; text-align:center; overflow:hidden; }
    .selector-btn:hover { border-color:#92ace0; box-shadow:0 6px 18px rgba(30,60,114,0.18); }
    .selector-btn.is-active { border-color:#1e3c72; background:linear-gradient(135deg,#1e3c72,#274b9f); color:#fff; box-shadow:0 12px 28px rgba(30,60,114,0.32); }
    .empty-message { padding:.85rem; border-radius:.75rem; border:1px dashed #d6dbe8; background:#f7f9ff; color:#324156; font-size:.9rem; }
    @media (max-width:520px) {
      .btn-grid { grid-template-columns:repeat(auto-fill,minmax(140px,1fr)); }
      .selector-btn { min-height:58px; padding:.6rem .8rem; }
    }
    @media (min-width:720px) {
      /* Larger viewports can safely scale button typography a bit more */
      .selector-btn .selector-label { font-size:1.3rem; }
    }
  /* Controls layout for visit start selects and friendliness buttons */
  .visit-start-row { display:flex; gap:0.6rem; align-items:center; }
  /* Use grid for friend buttons so we can force 3-up at our breakpoint like subjects */
  .friend-btn-row { display:grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap:12px; align-items:center; }
  .friend-btn-row .friend-btn { width:100%; box-sizing:border-box; justify-self:stretch; }

  /* Make the start hour/minute selects and friendliness buttons align to a 530px width when space allows */
  @media (min-width:530px) {
      /* constrain parent width and let controls share the space */
      #visitTimeSection > div > .visit-start-row, #visitTimeSection .visit-start-row { max-width:530px; width:100%; }
      #visitTimeSection select#visitStartHour,
      #visitTimeSection select#visitStartMinute {
        box-sizing: border-box;
        width: calc(50% - 6px);
        min-width: 0;
      }

      .friend-btn-row { max-width:530px; width:100%; }
      .friend-btn-row .friend-btn {
        box-sizing: border-box;
        flex: 1 1 0;
        min-width: 0;
        padding:.7rem 1rem;
        font-weight:800;
        width: calc((530px - 24px) / 3);
      }
    }

    /* At ~530px ensure selector grids (regions/schools) show 3 items per row and use larger buttons */
    @media (min-width:530px) {
      /* Force a stable 3-column layout at the 530px breakpoint.
         Use minmax(0, 1fr) so long words or internal min-widths don't prevent
         the grid from creating 3 tracks. Make it !important to beat any
         inline or earlier rules that may interfere. */
      .btn-grid { grid-template-columns: repeat(3, minmax(0, 1fr)) !important; gap:12px; }
      .btn-grid .selector-btn { min-height:72px; padding:.9rem 1rem; min-width:0; }
      .btn-grid .selector-label { font-size:1.12rem; font-weight:800; }
    }

    /* On small screens make friend buttons wrap and still be large touch targets */
    @media (max-width:539px) {
      .friend-btn-row { display:flex; gap:0.6rem; flex-wrap:wrap; }
      .friend-btn-row .friend-btn { flex:1 1 calc(50% - 0.6rem); }
      #visitTimeSection select#visitStartHour, #visitTimeSection select#visitStartMinute { min-width:110px; width:48%; }
    }
   /* Meeting buttons: 3 items per row on all screens */
   .meeting-buttons.selector-grid { display:grid; grid-template-columns: repeat(3, 1fr); gap:12px; align-items:center; max-width:530px; width:100%; margin:0 auto; }
   .meeting-buttons.selector-grid .selector-btn { box-sizing:border-box; width:100%; min-width:0; padding:0.85rem 1rem; min-height:72px; justify-self:stretch; }
    .meeting-buttons.selector-grid .selector-label { font-size:1.05rem; font-weight:900; }
    @media (max-width:420px) {
      .meeting-buttons.selector-grid .selector-label { font-size:0.98rem; }
    }
    /* Subject choice and friend buttons: 3 items per row */
    .subject-choice-group { display:grid; grid-template-columns: repeat(3, 1fr); gap:0.6rem; }
    .subject-choice-group .subject-choice-btn {
      padding: 0.85rem 1rem !important;
      font-size: 1.05rem !important;
      min-height: 60px;
    }
    .friend-btn-row { display:grid; grid-template-columns: repeat(3, 1fr); gap:0.6rem; }
    .friend-btn-row .friend-btn {
      padding: 0.85rem 1rem !important;
      font-size: 1.05rem !important;
      min-height: 60px;
    }
    /* Visit duration buttons keep flex layout */
    #visitDurationButtons { display:flex; flex-wrap:wrap; gap:0.6rem; }
    #visitDurationButtons .duration-btn {
      flex: 1 1 calc(50% - 0.6rem);
      min-width: 140px;
      padding: 0.85rem 1rem !important;
      font-size: 1.05rem !important;
    }
    @media (max-width:420px) {
      .subject-choice-group .subject-choice-btn,
      .friend-btn-row .friend-btn,
      #visitDurationButtons .duration-btn { font-size:0.98rem !important; }
    }
  </style>
  <style id="pinProceed-style">#pinProceed{margin-top:12px;padding:.7rem 1rem;border-radius:.8rem;border:none;background:#1e3c72;color:#fff;font-weight:800;cursor:pointer}</style>
  <script>
    // Lightweight modal confirm and toast helpers to replace native confirm/alert
    (function(){
      function ensureModal() {
        if (document.getElementById('cmass-confirm-modal')) return;
        const tpl = document.createElement('div');
        tpl.id = 'cmass-confirm-modal';
        tpl.style.display = 'none';
        tpl.innerHTML = '\n          <div class="cmass-modal-backdrop" style="position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.5);z-index:99999">\n            <div class="cmass-modal-card" style="background:#fff;color:#072042;padding:18px;border-radius:10px;max-width:420px;width:92%;box-shadow:0 12px 30px rgba(2,6,23,0.35);text-align:center">\n              <div id="cmass-modal-msg" style="margin-bottom:14px;white-space:pre-wrap;text-align:left"></div>\n              <div style="text-align:right">\n                <button id="cmass-modal-no" class="alt-btn" style="margin-right:8px;padding:8px 12px;border-radius:8px">취소</button>\n                <button id="cmass-modal-yes" style="padding:8px 12px;border-radius:8px;background:#1e88e5;color:#fff;border:none">확인</button>\n              </div>\n            </div>\n          </div>';
        document.body.appendChild(tpl);
      }
      window.showConfirmModal = function(message){
        ensureModal();
        const root = document.getElementById('cmass-confirm-modal');
        const msg = root.querySelector('#cmass-modal-msg');
        const yes = root.querySelector('#cmass-modal-yes');
        const no = root.querySelector('#cmass-modal-no');
        msg.textContent = message || '';
        root.style.display = '';
        return new Promise((resolve)=>{
          function cleanup(val){ root.style.display = 'none'; yes.removeEventListener('click', onYes); no.removeEventListener('click', onNo); resolve(val); }
          function onYes(){ cleanup(true); }
          function onNo(){ cleanup(false); }
          yes.addEventListener('click', onYes);
          no.addEventListener('click', onNo);
        });
      };
    })();
  </script>
  
  <!-- Firebase SDK -->
  <script type="module">
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
    import { getFirestore, collection, addDoc, serverTimestamp, query, where, getDocs, updateDoc, doc } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';

    const firebaseConfig = {
      apiKey: "AIzaSyARdXNfFCUShNeFXV8cTDzFbKa4GId5EvU",
      authDomain: "cmass-sales.firebaseapp.com",
      projectId: "cmass-sales",
      storageBucket: "cmass-sales.firebasestorage.app",
      messagingSenderId: "918981476485",
      appId: "1:918981476485:web:7939150e23500e2703a9ec",
      measurementId: "G-9188JJXRWX"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    // Export to global scope for use in other scripts
    window.firebaseDb = db;
    window.firestoreCollection = collection;
    window.firestoreAddDoc = addDoc;
    window.firestoreServerTimestamp = serverTimestamp;
    window.firestoreQuery = query;
    window.firestoreWhere = where;
    window.firestoreGetDocs = getDocs;
    window.firestoreUpdateDoc = updateDoc;
    window.firestoreDoc = doc;
    
    console.log('[Firebase] Initialized successfully');
  </script>
</head>
<body>
  <!-- Temporary: attempt to unregister any existing service-workers on first load to avoid serving stale cached HTML/assets -->
  <script>
    (function(){
      try{
        if ('serviceWorker' in navigator) {
          navigator.serviceWorker.getRegistrations().then(function(regs){ regs.forEach(r=>{ try{ r.unregister(); }catch(e){} }); }).catch(()=>{});
        }
      }catch(e){}
    })();
  </script>
  <!-- Guard against external extensions wiping the body: watch for removals and restore tracked nodes -->
  <script data-cmass-role="body-guard">
    (function(){
      const LOG_PREFIX = '[cmass body-guard]';
      const guardScript = document.currentScript;

      function installBodyGuard(){
        try{
          const body = document.body;
          if (!body) return;

          const trackedList = [];
          const trackedSet = new Set();

          function shouldTrack(node){
            if (!node) return false;
            const nodeType = node.nodeType;
            if (node === guardScript) return false;
            if (nodeType === Node.ELEMENT_NODE) {
              const el = node;
              if (el.hasAttribute && el.hasAttribute('data-cmass-role') && el.getAttribute('data-cmass-role') === 'body-guard') return false;
              if (el.id && el.id.toLowerCase().includes('glasp')) return false;
              if (el.classList) {
                for (let i = 0; i < el.classList.length; i++){
                  if (el.classList[i].toLowerCase().includes('glasp')) return false;
                }
              }
              return true;
            }
            if (nodeType === Node.TEXT_NODE) {
              return !!(node.nodeValue && node.nodeValue.trim());
            }
            return false;
          }

          function trackNodes(nodes){
            if (!nodes || !nodes.length) return;
            nodes.forEach(node => {
              if (!shouldTrack(node)) return;
              if (!trackedSet.has(node)){
                trackedSet.add(node);
                trackedList.push(node);
              }
            });
          }

          trackNodes(Array.from(body.childNodes));

          let restoring = false;
          const observer = new MutationObserver(mutations => {
            if (restoring) return;
            let shouldRestore = false;

            for (const mutation of mutations) {
              if (mutation.type !== 'childList') continue;
              trackNodes(Array.from(mutation.addedNodes || []));

              const removed = mutation.removedNodes || [];
              for (let i = 0; i < removed.length; i++){
                const node = removed[i];
                if (trackedSet.has(node)){
                  shouldRestore = true;
                  break;
                }
              }
              if (shouldRestore) break;
            }

            if (!shouldRestore) {
              if (!body.firstChild) shouldRestore = true;
            }

            if (!shouldRestore) return;

            restoring = true;
            requestAnimationFrame(() => {
              try{
                trackedList.forEach(node => {
                  if (!node || node === guardScript) return;
                  if (!node.isConnected) {
                    body.appendChild(node);
                  }
                });
                console.warn(LOG_PREFIX, 'Restored missing body content');
              }catch(err){
                console.warn(LOG_PREFIX, 'restore failed', err);
              }finally{
                restoring = false;
              }
            });
          });

          observer.observe(body, { childList: true });
          window._cmassBodyGuard = { observer, tracked: trackedList };
        }catch(err){
          console.warn(LOG_PREFIX, 'failed to install', err);
        }
      }

      installBodyGuard();
    })();
  </script>
  <!-- Diagnostic overlay removed -->
  <script>
    // Mapping merge mode helpers: persist choice in localStorage and expose toggle UI
    (function(){
      function getMappingOverrides(){
        try{
          const stored = localStorage.getItem('cmass_mappingOverridesCsv');
          if (stored !== null) return (stored === '1' || stored === 'true');
        }catch(e){}
        if (window.CMASS_OPTIONS && typeof window.CMASS_OPTIONS.mappingOverridesCsv !== 'undefined') return !!window.CMASS_OPTIONS.mappingOverridesCsv;
        // Default: mapping 우선 (요청에 따라 기본을 매핑 우선으로 변경)
        return true;
      }
      function setMappingOverrides(v){ try{ localStorage.setItem('cmass_mappingOverridesCsv', v ? '1':'0'); }catch(e){} }
      function updateMergeToggleUI(){ const btn = document.getElementById('cmass-merge-toggle'); if(!btn) return; const val = getMappingOverrides(); btn.textContent = val ? '매핑 우선' : 'CSV 우선'; btn.setAttribute('aria-pressed', val ? 'true' : 'false'); }
      document.addEventListener('DOMContentLoaded', function(){ try{ updateMergeToggleUI(); const btn = document.getElementById('cmass-merge-toggle'); if(btn){ btn.addEventListener('click', function(){ try{ const cur = getMappingOverrides(); setMappingOverrides(!cur); updateMergeToggleUI(); try{ if (typeof showToast === 'function') showToast('병합 모드가 변경되었습니다. 페이지를 새로고침합니다.', 1400); }catch(e){} setTimeout(()=>location.reload(), 600); }catch(e){ console.warn('merge toggle failed', e); } }); } }catch(e){} });
      // expose getter for other scripts
      try{ window.getCMASSMappingOverrides = getMappingOverrides; }catch(e){}
    })();
  </script>
  <!-- Global diagnostic handlers removed to avoid automatic error-overlay activation -->
  <script>
    // Canonicalize legacy lowercase user tokens to canonical tokens so address bar shows consistent URLs.
    (function canonUserParam(){
      try {
        const params = new URLSearchParams(window.location.search);
        const user = params.get('user');
        if (!user) return;

        const canonMap = {
          'songhunje': 'Songhoonjae',
          'songhoonjae': 'Songhoonjae',
          'limjunho': 'LimJunho',
          'imjunho': 'LimJunHo',
          'joyounghwan': 'ChoYounghwan',
          'choyounghwan': 'ChoYounghwan'
        };

        const lower = String(user).trim().toLowerCase();
        const mapped = canonMap[lower];
        if (mapped && mapped !== user) {
          params.set('user', mapped);
          const newUrl = window.location.pathname + '?' + params.toString();
          history.replaceState(null, '', newUrl);
        }
      } catch (e) {
        console.warn('canonUserParam error', e);
      }
    })();
  </script>
  <script>
    // Derive and display staff label based on the ?user= query parameter.
    (function initStaffLabel(){
      const legacyToCanonical = {
        'songhunje': 'Songhoonjae',
        'songhoonjae': 'Songhoonjae',
        'limjunho': 'LimJunho',
        'imjunho': 'LimJunho',
        'joyounghwan': 'ChoYounghwan',
        'choyounghwan': 'ChoYounghwan'
      };
      const labelMap = {
        'Songhoonjae': { label: '송훈재 부장', base: '송훈재' },
        'LimJunho': { label: '임준호 차장', base: '임준호' },
        'ChoYounghwan': { label: '조영환 부장', base: '조영환' }
      };

      function normalizeToken(token){
        if (!token) return '';
        const trimmed = token.trim();
        if (!trimmed) return '';
        const lower = trimmed.toLowerCase();
        return legacyToCanonical[lower] || trimmed;
      }

      function resolveLabel(token){
        if (!token) return '';
        const canonical = normalizeToken(token);
        const mapped = labelMap[canonical];
        if (mapped && mapped.label) return mapped.label;
        // fallback: if canonical already looks like Korean name, use as-is
        if (/^[가-힣\s]+$/.test(canonical)) return canonical;
        return canonical;
      }

      function stripTitle(label){
        if (!label) return '';
        return label.replace(/\s*(부장|차장|과장|대리|팀장|선생님|선생)$/g, '').trim();
      }

      function applyStaff(label){
        try{
          const infoEl = document.getElementById('staffInfo');
          if (infoEl) infoEl.textContent = '담당자: ' + (label || '-');
          const dbg = document.getElementById('dbgStaff');
          if (dbg) dbg.textContent = label || '-';
        }catch(err){ console.warn('applyStaff failed', err); }
      }

      document.addEventListener('DOMContentLoaded', function(){
        try{
          const params = new URLSearchParams(window.location.search);
          const userParam = params.get('user') || '';
          const canonicalToken = normalizeToken(userParam);
          const label = resolveLabel(canonicalToken);
          window._cmass_staffToken = canonicalToken || '';
          window._cmass_staffParam = label || '';
          window._cmass_staffBase = stripTitle(label) || '';
          applyStaff(label);
          if (typeof updateTopline === 'function') updateTopline();
          if (typeof window.updateDebugOverlay === 'function') window.updateDebugOverlay();
        }catch(err){ console.warn('initStaffLabel failed', err); }
      });
    })();
  </script>

  <script>
    // Update topline display: "담당자 - 방문일 - 지역 - 학교"
    (function(){
      window.updateTopline = function(){
        try{
          const staff = window._cmass_staffParam || '-';
          const visitDate = (document.getElementById('visitDate')?.value || '').trim();
          const region = window.selectedRegion || '-';
          const school = window.selectedSchool || '-';
          
          const text = `${staff} - ${visitDate || '-'} - ${region} - ${school}`;
          
          // Update both Step1 and Step2 toplines
          const topline = document.getElementById('cmass-topline');
          if (topline) topline.textContent = text;
          
          const toplineCopies = document.querySelectorAll('.cmass-topline-copy');
          toplineCopies.forEach(el => {
            if (el) el.textContent = text;
          });
        }catch(e){
          console.warn('updateTopline failed', e);
        }
      };

      // Update on visitDate change
      document.addEventListener('DOMContentLoaded', function(){
        const visitDateInput = document.getElementById('visitDate');
        if (visitDateInput) {
          visitDateInput.addEventListener('change', function(){
            if (typeof updateTopline === 'function') updateTopline();
          });
        }
      });
    })();
  </script>
  <div style="width:95vw;max-width:640px;margin:0 auto 8px;display:flex;align-items:center;justify-content:space-between;gap:12px;">
  <h2 style="margin:0;flex:0 0 auto">영업일지 입력</h2>
  <button id="goFrontBtn" type="button" style="background:#1e3c72;color:#fff;border:none;padding:.6rem .9rem;border-radius:.8rem;font-weight:800;cursor:pointer;box-shadow:0 8px 22px rgba(18,50,90,0.12);white-space:nowrap;">뒤로 가기</button>
  </div>
  <script>
    (function(){
      // Remove any leftover redirect banner or links that mention the old .html legacy URL
      function removeLegacyRedirectBanner(){
        try{
          const walkers = Array.from(document.querySelectorAll('a, p, div, span'));
          walkers.forEach(el => {
            try{
              const txt = (el.textContent || '').toString();
              if (/redirecting to/i.test(txt) && /input(\.html)?/i.test(txt)) {
                el.remove();
                return;
              }
              if (el.tagName.toLowerCase() === 'a' && el.getAttribute('href') && /input(\.html)?/i.test(el.getAttribute('href'))) {
                el.remove();
                return;

              }
            }catch(e){}
          });
          Array.from(document.body.childNodes).forEach(n => {
            try{
              if (n.nodeType === Node.TEXT_NODE && /Redirecting to\s+input(\.html)?/i.test(n.textContent||'')) {
                if (n.parentNode) n.parentNode.removeChild(n);
              }
            }catch(e){}
          });
        }catch(e){/* ignore */}
      }

      function navigateBackToFront(){
        const query = window.location.search || '';
        const fallbackUrl = '/front' + query;

        const cleanup = () => document.removeEventListener('visibilitychange', onVisibility, false);
        let navigated = false;
        const onVisibility = () => { navigated = true; cleanup(); };
        document.addEventListener('visibilitychange', onVisibility, false);

        const goFallback = () => {
          cleanup();
          try{ window.location.assign(fallbackUrl); }catch(e){ window.location.href = fallbackUrl; }
        };

        try{
          if (window.history && window.history.length > 1) {
            history.back();
            setTimeout(() => { if (!navigated) goFallback(); }, 450);
          } else {
            goFallback();

          }
        }catch(e){
          goFallback();
        }
      }

      document.addEventListener('DOMContentLoaded', function(){
        removeLegacyRedirectBanner();
        const btn = document.getElementById('goFrontBtn');

        if (btn) {
          btn.addEventListener('click', function(ev){
            ev.preventDefault();
            navigateBackToFront();
          });
        }
      });
    })();
  </script>


  <div id="mainContent" style="display:block;" data-cmass-protect="1">
    <form>
  <!-- single-line topline moved here so it sits between '뒤로 가기' and the 방문일 selector -->
  <div id="cmass-topline" style="margin:0 0 8px 0;color:#12325a;font-weight:700;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">&nbsp;</div>
  
  <!-- Visit accumulation status -->
  <div style="display:flex;gap:0.5rem;align-items:center;margin-bottom:0.8rem;">
    <div id="visitAccumStatus" style="flex:1;padding:0.5rem;background:#f0f7ff;border-radius:0.6rem;font-size:0.9rem;color:#1e3c72;">누적: 0개 학교</div>
    <button type="button" id="resetVisitListBtn" style="padding:0.5rem 0.8rem;border-radius:0.6rem;border:1px solid #d6dbe8;background:#fff;color:#666;font-size:0.85rem;">새 보고서</button>
  </div>
  
  <label for="visitDate">방문일</label>
  <input type="date" id="visitDate" name="visitDate" required style="padding:.7rem;border-radius:.8rem;border:1px solid #d6dbe8;margin-bottom:.6rem;" />
  <div id="staffInfo" style="font-size:1.2rem;font-weight:bold;margin-bottom:1rem;">담당자: -</div>
  <label>지역</label>
  <div style="display:flex;gap:.5rem;margin-bottom:.6rem;align-items:center;">
    <input id="searchInput" type="search" placeholder="지역 또는 학교 검색" style="flex:1;padding:.7rem;border-radius:.8rem;border:1px solid #d6dbe8;" aria-label="지역 또는 학교 검색" />
    <button type="button" id="searchClear" style="padding:.6rem .8rem;border-radius:.8rem;border:1px solid #d6dbe8;background:#fff;">지우기</button>
  </div>
  <div id="regionButtons" class="btn-grid" role="listbox" aria-label="지역 선택"></div>
    <label>학교명</label>
    <div id="schoolButtons" class="btn-grid" role="listbox" aria-label="학교명 선택"></div>

    <!-- inline school metadata shown immediately after selecting a school -->
  <div id="schoolMetaInline" class="meta-card hidden">
      <h4>학교 정보</h4>
      <div class="meta-summary">
        <div class="meta-pill" id="inlinePillEstablish">설립: -</div>

        <div class="meta-pill" id="inlinePillLevel">급: -</div>
        <div class="meta-pill" id="inlinePillStudents">총학생수: -</div>
        <div class="meta-pill" id="inlinePillFeature" style="display:none;">특성: -</div>
      </div>
      <div class="grade-rows">
        <div class="grade-row"><div class="grade-label">1학년:</div><div class="grade-value"><span id="inlineG1c"></span> 학급 / <span id="inlineG1s"></span> 학생</div></div>
        <div class="grade-row"><div class="grade-label">2학년:</div><div class="grade-value"><span id="inlineG2c"></span> 학급 / <span id="inlineG2s"></span> 학생</div></div>
        <div class="grade-row"><div class="grade-label">3학년:</div><div class="grade-value"><span id="inlineG3c"></span> 학급 / <span id="inlineG3s"></span> 학생</div></div>
      </div>

      <!-- Inline NEIS timetable controls for quick lookup when selecting from the list -->
      <div style="margin-top:12px;padding-top:8px;border-top:1px dashed #e6eefc;">
        <label style="font-weight:900;display:block;margin-bottom:6px;">시간표 가져오기 (NEIS)</label>
        <div style="display:flex;gap:.5rem;flex-wrap:wrap;align-items:center;">
          <select id="inlineNeisYear" style="padding:.45rem;border-radius:.5rem;border:1px solid #d6dbe8;"> 
            <option value="2025">2025</option>
            <option value="2024">2024</option>
            <option value="2023">2023</option>
          </select>
          <select id="inlineNeisSemester" style="padding:.45rem;border-radius:.5rem;border:1px solid #d6dbe8;">
            <option value="1">1학기</option>
            <option value="2" selected>2학기</option>
          </select>

          <button type="button" id="btnFetchSelectedTimetableInline" class="meeting-btn" style="margin-left:6px;">선택 학교 시간표 보기</button>
          <button type="button" id="btnCloseTimetableInline" class="meeting-btn" style="margin-left:6px;background:#fff;color:#12325a;border:1px solid #d6dbe8;display:none;">시간표 닫기</button>
        </div>
        <div id="timetableProgressInline" style="margin-top:8px;color:#175;display:none;font-size:13px;"></div>
        <div id="timetableContainerInline" style="margin-top:10px;"></div>
      </div>
    </div>
      
      <!-- Action buttons section -->
      <div style="background:#f8f9fa;padding:1.2rem;border-radius:1rem;margin-top:1.5rem;border:1px solid #e0e8f5;">
        <h4 style="margin:0 0 0.8rem 0;font-size:1.05rem;color:#1e3c72;font-weight:800;">퇴근보고 관리</h4>
        
        <button type="button" id="copyKakaoBtn" style="width:100%;padding:0.8rem;border-radius:0.8rem;border:1px solid #ffd9b3;background:#fff;color:#b25700;font-weight:800;margin-bottom:0.6rem;">카톡으로 복사</button>
        
        <button type="button" id="saveToServerBtn" style="width:100%;padding:0.8rem;border-radius:0.8rem;border:1px solid #c8e6c9;background:#fff;color:#2e7d32;font-weight:800;margin-bottom:0.6rem;">서버에 저장</button>
        
        <div style="display:flex;gap:0.6rem;">
          <button type="button" id="generateSummaryBtn" style="flex:1;padding:0.8rem;border-radius:0.8rem;border:1px solid #4CAF50;background:#4CAF50;color:#fff;font-weight:800;">요약 생성</button>
          <button type="button" id="clearSummaryBtn" style="flex:1;padding:0.8rem;border-radius:0.8rem;border:1px solid #e0e0e0;background:#f5f5f5;color:#666;font-weight:700;">내용 전체지우기</button>
        </div>
        
        <div style="margin-top:0.6rem;font-size:0.85rem;color:#666;">
          퇴근보고 시간 설정: 퇴근 시각 기준 + 30분
        </div>
        
        <textarea id="generatedSummary" readonly rows="8" style="width:100%;margin-top:0.8rem;padding:0.8rem;border-radius:0.6rem;border:1px solid #d6dbe8;background:#fafafa;font-size:0.9rem;color:#333;resize:vertical;">요약이 여기에 생성됩니다.</textarea>
      </div>
      
      <button type="button" id="nextStepBtn" style="width:100%;margin:1rem 0 0 0;padding:1rem;font-size:1.1rem;border-radius:1rem;background:#1e3c72;color:#fff;font-weight:bold;border:none;cursor:pointer;">다음</button>
    </form>
  </div>

  <script>
    // Step navigation: Next button (Step1 -> Step2)
    (function(){
      document.addEventListener('DOMContentLoaded', function(){
        const nextBtn = document.getElementById('nextStepBtn');
        const backBtn = document.getElementById('backBtn');
        const step1 = document.getElementById('step1');
        const step2 = document.getElementById('step2');

        if (nextBtn) {
          nextBtn.addEventListener('click', function(){
            // Validate Step1 inputs
            const visitDate = document.getElementById('visitDate')?.value;
            const region = window.selectedRegion || '';
            const school = window.selectedSchool || '';
            const userParam = new URLSearchParams(window.location.search).get('user') || '';

            if (!visitDate) {
              alert('방문일을 선택해주세요.');
              return;
            }
            if (!region) {
              alert('지역을 선택해주세요.');
              return;
            }
            if (!school) {
              alert('학교를 선택해주세요.');
              return;
            }

            // Navigate to input-next.html with parameters
            const params = new URLSearchParams({
              school: school,
              region: region,
              date: visitDate,
              user: userParam
            });
            
            window.location.href = '/input-next?' + params.toString();
          });
        }

        if (backBtn) {
          backBtn.addEventListener('click', function(){
            console.log('[BACK] 뒤로 돌아가기 클릭');
            
            // Show Step1, hide Step2
            if (step1) step1.style.display = 'block';
            if (step2) step2.style.display = 'none';
            
            // Remove body class to hide step2-only content
            document.body.classList.remove('cmass-step2');
            
            // Mark that we're back in Step1
            window._isStep2Active = false;
            console.log('[BACK] _isStep2Active = false');
            
            // Clear any pending draft auto-save timer
            if (window.draftTimer) {
              clearTimeout(window.draftTimer);
              window.draftTimer = null;
              console.log('[BACK] Draft auto-save timer cleared');
            }

            // Scroll to top
            window.scrollTo(0, 0);
          });
        }
      });
    })();
  </script>

  <!-- Topline copy for Step2: mirrors #cmass-topline in Step1 -->
  <div class="cmass-topline-copy" style="margin:0 0 8px 0;color:#12325a;font-weight:700;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">&nbsp;</div>
      <!-- hidden fields to submit selected region/school -->
      <input type="hidden" id="selectedRegionInput" name="region">
      <input type="hidden" id="selectedSchoolInput" name="schoolName">
      <!-- school metadata panel (Step2) -->
      <div id="schoolMeta" class="meta-card">
        <h4>학교 정보</h4>
        <div class="meta-summary">
          <div class="meta-pill" id="metaPillEstablish">설립: -</div>

          <div class="meta-pill" id="metaPillLevel">급: -</div>
          <div class="meta-pill" id="metaPillStudents">총학생수: -</div>
          <div class="meta-pill" id="metaPillFeature" style="display:none;">특성: -</div>
        </div>
        <div class="grade-rows">
          <div class="grade-row"><div class="grade-label">1학년:</div><div class="grade-value"><span id="metaG1c"></span> 학급 / <span id="metaG1s"></span> 학생</div></div>
          <div class="grade-row"><div class="grade-label">2학년:</div><div class="grade-value"><span id="metaG2c"></span> 학급 / <span id="metaG2s"></span> 학생</div></div>

          <div class="grade-row"><div class="grade-label">3학년:</div><div class="grade-value"><span id="metaG3c"></span> 학급 / <span id="metaG3s"></span> 학생</div></div>
        </div>
      <!-- NEIS timetable controls -->
      <div style="margin-top:12px;padding-top:8px;border-top:1px dashed #e6eefc;">
        <label style="font-weight:900;display:block;margin-bottom:6px;">시간표 가져오기 (NEIS)</label>
        <div style="display:flex;gap:.5rem;flex-wrap:wrap;align-items:center;">
          <select id="neisYear" style="padding:.45rem;border-radius:.5rem;border:1px solid #d6dbe8;"> 
            <option value="2025">2025</option>
            <option value="2024">2024</option>
            <option value="2023">2023</option>
          </select>
          <select id="neisSemester" style="padding:.45rem;border-radius:.5rem;border:1px solid #d6dbe8;">
            <option value="1">1학기</option>
            <option value="2" selected>2학기</option>
          </select>
          <button type="button" id="btnFetchSelectedTimetable" class="meeting-btn" style="margin-left:6px;">선택 학교 시간표 보기</button>
          <button type="button" id="btnCloseTimetable" class="meeting-btn" style="margin-left:6px;background:#fff;color:#12325a;border:1px solid #d6dbe8;display:none;">시간표 닫기</button>
        </div>
        <div id="timetableProgress" style="margin-top:8px;color:#175;display:none;font-size:13px;"></div>
        <div id="timetableContainer" style="margin-top:10px;"></div>

      </div>
    </div>

    <section id="visitTimeSection" style="margin-top:1.2rem;padding:1rem;border:1px solid #e6eefc;border-radius:1rem;background:#f9fbff;">
      <h4 style="margin:0 0 0.8rem 0;font-size:1.05rem;font-weight:800;color:#12325a;">방문 일정</h4>
      <div style="display:flex;flex-direction:column;gap:0.8rem;">
        <div>
          <label for="visitStartHour" style="display:block;font-weight:700;margin-bottom:0.4rem;">방문 시작 시간</label>
          <div class="visit-start-row" style="display:flex;gap:0.6rem;flex-wrap:wrap;align-items:center;">
            <select id="visitStartHour" name="visitStartHour" style="padding:0.65rem;border-radius:0.8rem;border:1px solid #d6dbe8;min-width:100px;">
              <option value="">시 선택</option>
              <option value="08">08시</option>
              <option value="09">09시</option>
              <option value="10">10시</option>
              <option value="11">11시</option>
              <option value="12">12시</option>
              <option value="13">13시</option>
              <option value="14">14시</option>
              <option value="15">15시</option>
              <option value="16">16시</option>
              <option value="17">17시</option>
              <option value="18">18시</option>
            </select>
            <select id="visitStartMinute" name="visitStartMinute" style="padding:0.65rem;border-radius:0.8rem;border:1px solid #d6dbe8;min-width:100px;">
              <option value="">분 선택</option>
              <option value="00">00분</option>
              <option value="05">05분</option>
              <option value="10">10분</option>
              <option value="15">15분</option>
              <option value="20">20분</option>
              <option value="25">25분</option>
              <option value="30">30분</option>
              <option value="35">35분</option>
              <option value="40">40분</option>
              <option value="45">45분</option>
              <option value="50">50분</option>
              <option value="55">55분</option>
            </select>
          </div>
        </div>
        <div>
          <label style="display:block;font-weight:700;margin-bottom:0.4rem;">총 방문 시간(분)</label>
          <div id="visitDurationButtons" style="display:flex;flex-wrap:wrap;gap:0.6rem;margin-bottom:0.4rem;">
            <button type="button" class="duration-btn" data-duration="10" style="flex:0 0 auto;padding:0.65rem 1rem;border-radius:0.85rem;border:1px solid #d6dbe8;background:#fff;font-weight:700;color:#1e3c72;">10분</button>
            <button type="button" class="duration-btn" data-duration="20" style="flex:0 0 auto;padding:0.65rem 1rem;border-radius:0.85rem;border:1px solid #d6dbe8;background:#fff;font-weight:700;color:#1e3c72;">20분</button>
            <button type="button" class="duration-btn" data-duration="30" style="flex:0 0 auto;padding:0.65rem 1rem;border-radius:0.85rem;border:1px solid #d6dbe8;background:#fff;font-weight:700;color:#1e3c72;">30분</button>
            <button type="button" class="duration-btn" data-duration="40" style="flex:0 0 auto;padding:0.65rem 1rem;border-radius:0.85rem;border:1px solid #d6dbe8;background:#fff;font-weight:700;color:#1e3c72;">40분</button>
            <button type="button" class="duration-btn" data-duration="50" style="flex:0 0 auto;padding:0.65rem 1rem;border-radius:0.85rem;border:1px solid #d6dbe8;background:#fff;font-weight:700;color:#1e3c72;">50분</button>
            <button type="button" class="duration-btn" data-duration="60" style="flex:0 0 auto;padding:0.65rem 1rem;border-radius:0.85rem;border:1px solid #d6dbe8;background:#fff;font-weight:700;color:#1e3c72;">60분</button>
            <button type="button" class="duration-btn" data-duration="70" style="flex:0 0 auto;padding:0.65rem 1rem;border-radius:0.85rem;border:1px solid #d6dbe8;background:#fff;font-weight:700;color:#1e3c72;">70분</button>
            <button type="button" class="duration-btn" data-duration="80" style="flex:0 0 auto;padding:0.65rem 1rem;border-radius:0.85rem;border:1px solid #d6dbe8;background:#fff;font-weight:700;color:#1e3c72;">80분</button>
            <button type="button" class="duration-btn" data-duration="90" style="flex:0 0 auto;padding:0.65rem 1rem;border-radius:0.85rem;border:1px solid #d6dbe8;background:#fff;font-weight:700;color:#1e3c72;">90분</button>
          </div>
          <div style="display:flex;gap:0.5rem;align-items:center;flex-wrap:wrap;">
            <input type="number" id="visitDurationInput" name="visitDurationMinutes" min="0" step="5" placeholder="직접 입력" style="width:110px;padding:0.6rem;border-radius:0.8rem;border:1px solid #d6dbe8;" />
            <button type="button" id="resetVisitTimeBtn" style="padding:0.55rem 0.9rem;border-radius:0.8rem;border:1px solid #d6dbe8;background:#fff;color:#1e3c72;">지우기</button>
          </div>
        </div>
        <div>
          <label for="visitEndTime" style="display:block;font-weight:700;margin-bottom:0.4rem;">방문 종료 시간 (자동 계산)</label>
          <input type="text" id="visitEndTime" name="visitEndTime" readonly style="width:160px;padding:0.65rem;border-radius:0.8rem;border:1px solid #d6dbe8;background:#f6f9ff;font-weight:700;color:#12325a;" />
        </div>
      </div>
    </section>

    <section class="subject-section" style="margin-top:1.5rem;">
      <h4 style="margin:0 0 0.8rem 0;font-size:1.05rem;font-weight:800;color:#12325a;">과목/선생님별 영업기록</h4>
      <div id="subjectsBlock" class="subject-blocks" style="display:flex;flex-direction:column;gap:1rem;"></div>
    </section>

      <button type="button" id="addSubjectBtn" style="width:100%;margin:0.8rem 0 1rem 0;padding:1rem;font-size:1.1rem;border-radius:1rem;background:#e3eafc;color:#1e3c72;font-weight:bold;border:none;cursor:pointer;">과목/선생님 추가</button>
      <!-- Back / Submit controls moved here so they appear between '과목/선생님 추가' and the step2-only panel -->
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:0.6rem;margin-top:0.6rem;">
        <button type="button" id="backBtn" style="padding:1rem;border-radius:1rem;border:1px solid #d6dbe8;background:#fff;color:#1e3c72;font-weight:700;cursor:pointer;">뒤로 돌아가기</button>
        <button type="submit" class="btn-submit" style="padding:1rem;border-radius:1rem;border:1px solid #1e3c72;background:#1e3c72;color:#fff;font-weight:700;cursor:pointer;">입력 완료</button>
      </div>
  </form>
  </div>

  <script>
    // Visit time and meeting buttons event handlers
    (function(){
      'use strict';
      
      document.addEventListener('DOMContentLoaded', function(){
        // Visit duration buttons
        const durationBtns = document.querySelectorAll('.duration-btn');
        const durationInput = document.getElementById('visitDurationInput');
        const visitStartHour = document.getElementById('visitStartHour');
        const visitStartMinute = document.getElementById('visitStartMinute');
        const visitEndTime = document.getElementById('visitEndTime');
        const resetBtn = document.getElementById('resetVisitTimeBtn');

        // Calculate end time
        function calculateEndTime(){
          const hour = visitStartHour?.value || '';
          const minute = visitStartMinute?.value || '';
          const duration = durationInput?.value || '';
          
          if (!hour || !minute || !duration) {
            if (visitEndTime) visitEndTime.value = '';
            return;
          }
          
          const startMinutes = parseInt(hour) * 60 + parseInt(minute);
          const endMinutes = startMinutes + parseInt(duration);
          const endHour = Math.floor(endMinutes / 60);
          const endMin = endMinutes % 60;
          
          if (visitEndTime) {
            visitEndTime.value = `${String(endHour).padStart(2,'0')}:${String(endMin).padStart(2,'0')}`;
          }
        }

        // Duration button clicks
        durationBtns.forEach(btn => {
          btn.addEventListener('click', function(){
            const value = this.dataset.duration || '';
            
            // Toggle selection
            const isActive = this.classList.contains('is-active');
            durationBtns.forEach(b => {
              b.classList.remove('is-active');
              b.style.background = '#fff';
              b.style.color = '#1e3c72';
              b.style.borderColor = '#d6dbe8';
            });
            
            if (!isActive) {
              this.classList.add('is-active');
              this.style.background = '#1e3c72';
              this.style.color = '#fff';
              this.style.borderColor = '#1e3c72';
              if (durationInput) durationInput.value = value;
            } else {
              if (durationInput) durationInput.value = '';
            }
            
            calculateEndTime();
          });
        });

        // Duration input change
        if (durationInput) {
          durationInput.addEventListener('input', function(){
            const value = this.value || '';
            
            // Clear button selection if manually typing
            durationBtns.forEach(b => {
              const btnValue = b.dataset.duration || '';
              if (btnValue === value) {
                b.classList.add('is-active');
                b.style.background = '#1e3c72';
                b.style.color = '#fff';
                b.style.borderColor = '#1e3c72';
              } else {
                b.classList.remove('is-active');
                b.style.background = '#fff';
                b.style.color = '#1e3c72';
                b.style.borderColor = '#d6dbe8';
              }
            });
            
            calculateEndTime();
          });
        }

        // Time selects change
        [visitStartHour, visitStartMinute].forEach(el => {
          if (el) el.addEventListener('change', calculateEndTime);
        });

        // Reset button
        if (resetBtn) {
          resetBtn.addEventListener('click', function(){
            if (visitStartHour) visitStartHour.value = '';
            if (visitStartMinute) visitStartMinute.value = '';
            if (durationInput) durationInput.value = '';
            if (visitEndTime) visitEndTime.value = '';
            
            durationBtns.forEach(b => {
              b.classList.remove('is-active');
              b.style.background = '#fff';
              b.style.color = '#1e3c72';
              b.style.borderColor = '#d6dbe8';
            });
          });
        }

        // Meeting buttons (영업활동) - setup for each subject block
        function setupMeetingButtons(block){
          if (!block) return;
          
          const meetingBtns = block.querySelectorAll('.meeting-btn');
          meetingBtns.forEach(btn => {
            // Remove old listeners by cloning
            const newBtn = btn.cloneNode(true);
            btn.parentNode.replaceChild(newBtn, btn);
            
            newBtn.addEventListener('click', function(){
              const isActive = this.classList.contains('is-active');
              
              if (isActive) {
                this.classList.remove('is-active');
                this.style.background = '#fff';
                this.style.color = '#1e3c72';
                this.style.borderColor = '#d6dbe8';
              } else {
                this.classList.add('is-active');
                this.style.background = '#1e3c72';
                this.style.color = '#fff';
                this.style.borderColor = '#1e3c72';
              }
            });
          });
        }

        // Setup meeting buttons for all existing subject blocks
        const subjectBlocks = document.querySelectorAll('.subject-block');
        subjectBlocks.forEach(setupMeetingButtons);

        // Watch for new subject blocks
        const observer = new MutationObserver(function(mutations){
          mutations.forEach(function(mutation){
            mutation.addedNodes.forEach(function(node){
              if (node.nodeType === 1 && node.classList.contains('subject-block')){
                setupMeetingButtons(node);
              }
            });
          });
        });

        const subjectsBlock = document.getElementById('subjectsBlock');
        if (subjectsBlock) {
          observer.observe(subjectsBlock, { childList: true });
        }

        // Expose setup function globally for manual calls
        window.setupMeetingButtons = setupMeetingButtons;
      });
    })();
  </script>

  <script>
    (function(){
      'use strict';
      let regionContainer;
      let schoolContainer;
      let searchInput;
      let searchClearBtn;
      let hiddenRegionInput;
      let hiddenSchoolInput;

      let allRegions = [];
      let staffScopedRegions = [];
      let visibleRegions = [];
  let staffToken = '';
  let resizeFitTimer = null;

      function fitSelectorLabels(){
        requestAnimationFrame(() => {
          const labels = document.querySelectorAll('.selector-btn .selector-label');
          labels.forEach((label) => {
            try {
              label.style.fontSize = '';
              const btn = label.closest('.selector-btn');
              if (!btn) return;
              const btnStyles = window.getComputedStyle(btn);
              const available = btn.clientWidth - ((parseFloat(btnStyles.paddingLeft) || 0) + (parseFloat(btnStyles.paddingRight) || 0));
              if (available <= 0) return;
              const computed = window.getComputedStyle(label);
              let size = parseFloat(computed.fontSize) || 15;
              const minSize = 10;
              label.style.fontSize = size + 'px';
              while (label.scrollWidth > available && size > minSize){
                size -= 0.5;
                label.style.fontSize = size + 'px';
              }
              if (label.scrollWidth > available) label.style.fontSize = minSize + 'px';
            } catch (err) {
              /* ignore measurement errors */
            }
          });
        });
      }

      const normalizeStaff = (name) => (name || '').replace(/\s+/g, '').toLowerCase();

      const cloneRegion = (region, overrideSchools) => {
        const sourceSchools = overrideSchools || region.schools || [];
        const schools = sourceSchools.map((s) => ({ name: s.name, staff: (s.staff || []).slice() }));
        const staff = dedupeStaff(schools.flatMap((s) => s.staff || []));
        return { name: region.name, schools, staff };
      };

      document.addEventListener('DOMContentLoaded', init);

      window.addEventListener('resize', () => {
        clearTimeout(resizeFitTimer);
        resizeFitTimer = setTimeout(fitSelectorLabels, 80);
      });

      async function init(){
        regionContainer = document.getElementById('regionButtons');
        schoolContainer = document.getElementById('schoolButtons');
        if (!regionContainer || !schoolContainer) return;

        searchInput = document.getElementById('searchInput');
        searchClearBtn = document.getElementById('searchClear');
        hiddenRegionInput = document.getElementById('selectedRegionInput');
        hiddenSchoolInput = document.getElementById('selectedSchoolInput');

        staffToken = determineStaffToken();
        allRegions = await loadRegionData();
        if (!allRegions.length){
          regionContainer.innerHTML = '<div class="empty-message">담당자 CSV를 불러오지 못했습니다.</div>';
          schoolContainer.innerHTML = '';
          return;
        }

        staffScopedRegions = filterRegionsByStaff(allRegions, staffToken);
        visibleRegions = staffScopedRegions.slice();
        renderState();
        attachSearchHandlers();
      }

      async function loadRegionData(){
        const regions = await fetchCsvRegions().catch(() => []);
        return Array.isArray(regions) ? regions : [];
      }


      function dedupeStaff(list){
        const seen = new Set();
        const out = [];
        (list || []).forEach((name) => {
          const trimmed = (name || '').trim();
          const key = normalizeStaff(trimmed);
          if (!trimmed || seen.has(key)) return;
          seen.add(key);
          out.push(trimmed);
        });
        return out;
      }

      function findHeaderIndex(header, candidates){
        if (!Array.isArray(header)) return -1;
        for (let i = 0; i < header.length; i += 1){
          const cell = (header[i] || '').trim();
          if (!cell) continue;
          if (candidates.some((name) => (name || '').trim() === cell)) return i;
        }
        return -1;
      }

      async function fetchCsvRegions(){
        const rows = await fetchCsvRows().catch(() => []);
        if (!rows || !rows.length) return [];
        const header = rows[0];
        const idxRegion = findHeaderIndex(header, ['region','지역']);
        const idxSchool = findHeaderIndex(header, ['school','학교','학교명']);
        let idxStaff = findHeaderIndex(header, ['staff','담당자']);
        if (idxStaff === -1) idxStaff = header.findIndex((h) => /staff/i.test((h || '').trim()));
        if (idxRegion === -1 || idxSchool === -1){
          console.warn('CSV header missing required columns', header);
          return [];
        }

        const regionMap = new Map();
        for (let i = 1; i < rows.length; i += 1){
          const row = rows[i];
          if (!row) continue;
          const regionName = (row[idxRegion] || '').trim();
          const schoolName = (row[idxSchool] || '').trim();
          if (!regionName || !schoolName) continue;
          const staffName = idxStaff >= 0 ? (row[idxStaff] || '').trim() : '';
          if (!regionMap.has(regionName)) regionMap.set(regionName, { name: regionName, schools: [], staffSet: new Set() });
          const region = regionMap.get(regionName);
          const staffList = staffName ? [staffName] : [];
          region.schools.push({ name: schoolName, staff: staffList });
          staffList.forEach((s) => region.staffSet.add(s));
        }

        const regions = Array.from(regionMap.values()).map((region) => {
          region.schools.sort((a, b) => a.name.localeCompare(b.name, 'ko', { sensitivity: 'base' }));
          return {
            name: region.name,
            schools: region.schools.map((s) => ({ name: s.name, staff: dedupeStaff(s.staff) })),
            staff: dedupeStaff(Array.from(region.staffSet))
          };
        });

        regions.sort((a, b) => a.name.localeCompare(b.name, 'ko', { sensitivity: 'base' }));
        return regions;
      }

      async function fetchCsvRows(){
        console.log('[fetchCsvRows] 시작');
        try{
          if (window._cmass_cachedCsvRows && Array.isArray(window._cmass_cachedCsvRows)){
            console.log('[fetchCsvRows] 캐시에서 리턴:', window._cmass_cachedCsvRows.length, '행');
            return window._cmass_cachedCsvRows.map((row) => Array.isArray(row) ? row.slice() : row);
          }
        }catch(cacheErr){ console.warn('[fetchCsvRows] 캐시 읽기 실패:', cacheErr); }
        const candidates = ['/sales_staff.csv','/sales_staff.deployed.csv','/sales_staff_live.csv'];
        console.log('[fetchCsvRows] 후보 파일:', candidates);
        let lastError = null;
        for (const path of candidates){
          console.log('[fetchCsvRows] 시도:', path);
          try{
            const res = await fetch(path, { cache: 'no-store' }).catch(() => null);
            console.log('[fetchCsvRows]', path, 'fetch 결과:', res ? res.ok : 'null');
            if (!res || !res.ok){ lastError = res ? res.status : 'fetch-failed'; console.log('[fetchCsvRows]', path, '실패 - status:', lastError); continue; }
            const ct = (res.headers.get('content-type') || '').toLowerCase();
            console.log('[fetchCsvRows]', path, 'content-type:', ct);
            if (!(ct.includes('csv') || ct.includes('text/plain') || ct.includes('application/octet-stream'))){
              lastError = `unexpected-content-type:${ct}`;
              console.log('[fetchCsvRows]', path, '실패 - 잘못된 content-type');
              continue;
            }
            const text = await res.text();
            console.log('[fetchCsvRows]', path, 'text 길이:', text ? text.length : 0, 'trim 후:', text ? text.trim().length : 0);
            if (!text || !text.trim()){ lastError = 'empty'; console.log('[fetchCsvRows]', path, '실패 - 빈 텍스트'); continue; }
            console.log('[fetchCsvRows]', path, 'parseCsv 호출 전...');
            const parsed = parseCsv(text);
            console.log('[fetchCsvRows]', path, 'parseCsv 결과:', parsed ? parsed.length + '행' : 'null');
            if (parsed && parsed.length){
              console.log('[fetchCsvRows] ✅ 성공!', path, '- 총', parsed.length, '행 파싱됨');
              console.log('[fetchCsvRows] 첫 3행:', parsed.slice(0,3));
              try{ window._cmass_cachedCsvRows = parsed; }catch(setErr){ console.warn('[fetchCsvRows] 캐시 저장 실패:', setErr); }
              return parsed.map((row) => Array.isArray(row) ? row.slice() : row);
            } else {
              console.warn('[fetchCsvRows]', path, '파싱 결과 없음 또는 빈 배열');
            }
          }catch(err){
            console.error('[fetchCsvRows]', path, '예외 발생:', err);
            lastError = err;
          }
        }
        console.error('[fetchCsvRows] ❌ 모든 후보 파일 실패. lastError:', lastError);
        try{ window._cmass_lastCsvError = lastError; }catch(e){ /* ignore */ }
        return null;
      }

      function parseCsv(text){
        // Remove UTF-8 BOM if present — some CSVs include \uFEFF which breaks header comparisons
        try{ text = (text || '').replace(/^\uFEFF/, ''); }catch(e){}
        const rows = [];
        let cur = [];
        let field = '';
        let inQuotes = false;
        for (let i = 0; i < text.length; i += 1){
          const ch = text[i];
          if (inQuotes){
            if (ch === '"'){
              if (text[i + 1] === '"'){ field += '"'; i += 1; continue; }
              inQuotes = false; continue;
            }
            field += ch; continue;
          }
          if (ch === '"'){ inQuotes = true; continue; }
          if (ch === ','){ cur.push(field); field = ''; continue; }
          if (ch === '\r') continue;
          if (ch === '\n'){ cur.push(field); rows.push(cur); cur = []; field = ''; continue; }
          field += ch;
        }
        if (field !== '' || cur.length) { cur.push(field); rows.push(cur); }
        return rows;
      }

      function determineStaffToken(){
        const base = (window._cmass_staffBase || '').trim();
        if (base) return base;
        const raw = (window._cmass_staffParam || '').replace(/\s*(부장|차장|과장|대리|팀장|선생님|선생)$/g, '').trim();
        return raw || '';
      }

      function filterRegionsByStaff(regions, staffName){
        if (!staffName) return regions.map((r) => cloneRegion(r));
        const norm = normalizeStaff(staffName);
        const filtered = [];
        regions.forEach((region) => {
          const matches = (region.schools || []).filter((school) =>
            (school.staff || []).some((s) => normalizeStaff(s) === norm)
          );
          if (matches.length) filtered.push(cloneRegion(region, matches));
        });
        return filtered;
      }

      function attachSearchHandlers(){
        if (!searchInput) return;
        let timer = null;
        searchInput.addEventListener('input', () => {
          clearTimeout(timer);
          timer = setTimeout(() => applySearch(searchInput.value || ''), 140);
        });
        if (searchClearBtn){
          searchClearBtn.addEventListener('click', () => {
            searchInput.value = '';
            applySearch('');
            searchInput.focus();
          });
        }
      }

      function applySearch(keyword){
        const trimmed = (keyword || '').trim().toLowerCase();
        const baseList = staffScopedRegions.map((r) => cloneRegion(r));
        if (!trimmed){
          visibleRegions = baseList;
        } else {
          const filtered = [];
          baseList.forEach((region) => {
            const regionMatch = region.name.toLowerCase().includes(trimmed);
            const matchedSchools = region.schools.filter((school) => {
              if (school.name && school.name.toLowerCase().includes(trimmed)) return true;
              return (school.staff || []).some((s) => (s || '').toLowerCase().includes(trimmed));
          });
          if (regionMatch) filtered.push(cloneRegion(region));
          else if (matchedSchools.length) filtered.push(cloneRegion(region, matchedSchools));
        });
        visibleRegions = filtered;
      }

      if (!visibleRegions.some((r) => r.name === window.selectedRegion)){
        window.selectedRegion = '';
        if (hiddenRegionInput) hiddenRegionInput.value = '';
        window.selectedSchool = '';
        if (hiddenSchoolInput) hiddenSchoolInput.value = '';
      }
      renderState();
    }      function renderState(){
        let activeRegion = findRegion(window.selectedRegion, visibleRegions);
        if (!activeRegion && visibleRegions.length){
          activeRegion = visibleRegions[0];
          window.selectedRegion = activeRegion.name;
          if (hiddenRegionInput) hiddenRegionInput.value = activeRegion.name;
        }
        if (activeRegion){
          const hasSchool = activeRegion.schools.some((s) => s.name === window.selectedSchool);
          if (!hasSchool){
            window.selectedSchool = '';
            if (hiddenSchoolInput) hiddenSchoolInput.value = '';
          }
        } else {
          window.selectedSchool = '';
          if (hiddenSchoolInput) hiddenSchoolInput.value = '';
        }
        renderRegions();
        renderSchools(activeRegion);
        toggleInlineMeta(!!window.selectedSchool);
  try{ if (typeof updateTopline === 'function') updateTopline(); }catch(e){ /* ignore */ }
  try{ if (typeof window.updateDebugOverlay === 'function') window.updateDebugOverlay(); }catch(e){ /* ignore */ }
        fitSelectorLabels();
      }

      function toggleInlineMeta(show){
        const inline = document.getElementById('schoolMetaInline');
        if (!inline) return;
          // Toggle visibility by adding/removing the .hidden class instead
          // of manipulating inline styles. This keeps CSS and JS responsibilities
          // clearer and avoids specificity issues.
          try{ inline.classList.toggle('hidden', !show); }catch(e){}
      }

      function renderRegions(){
        regionContainer.innerHTML = '';
        if (!visibleRegions.length){
          regionContainer.innerHTML = '<div class="empty-message">담당으로 등록된 지역이 없습니다. 매핑 정보를 확인해주세요.</div>';
          return;
        }
        const frag = document.createDocumentFragment();
        visibleRegions.forEach((region) => {
          const btn = buildSelectorButton(region.name, region.staff);
          btn.dataset.region = region.name;
          if (window.selectedRegion === region.name) {
            btn.classList.add('is-active');
            btn.setAttribute('aria-pressed', 'true');
          } else {
            btn.setAttribute('aria-pressed', 'false');
          }
          if (staffToken && region.staff.some((s) => normalizeStaff(s) === normalizeStaff(staffToken))) btn.classList.add('assigned');
          btn.addEventListener('click', () => selectRegion(region.name));
          frag.appendChild(btn);
        });
        regionContainer.appendChild(frag);
      }

      function renderSchools(region){
        schoolContainer.innerHTML = '';
        if (!region){
          schoolContainer.innerHTML = visibleRegions.length ? '<div class="empty-message">지역을 먼저 선택하세요.</div>' : '<div class="empty-message">담당으로 등록된 학교가 없습니다.</div>';
          return;
        }
        if (!region.schools.length){
          schoolContainer.innerHTML = '<div class="empty-message">등록된 학교가 없습니다.</div>';
          return;
        }
        const frag = document.createDocumentFragment();
        region.schools.forEach((school) => {
          const btn = buildSelectorButton(school.name, school.staff);
          btn.dataset.school = school.name;
          if (window.selectedSchool === school.name){
            btn.classList.add('is-active');
            btn.setAttribute('aria-pressed', 'true');
          } else {
            btn.setAttribute('aria-pressed', 'false');
          }
          if (staffToken && (school.staff || []).some((s) => normalizeStaff(s) === normalizeStaff(staffToken))) btn.classList.add('assigned');
          btn.addEventListener('click', () => selectSchool(region.name, school.name));
          frag.appendChild(btn);
        });
        schoolContainer.appendChild(frag);
      }

      function buildSelectorButton(label, staffList){
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'selector-btn';
        const labelSpan = document.createElement('span');
        labelSpan.className = 'selector-label';
        labelSpan.textContent = label;
        btn.appendChild(labelSpan);
        return btn;
      }

      function selectRegion(name){
        window.selectedRegion = name;
        if (hiddenRegionInput) hiddenRegionInput.value = name;
        window.selectedSchool = '';
        if (hiddenSchoolInput) hiddenSchoolInput.value = '';
        renderState();
      }

      function selectSchool(regionName, schoolName){
        console.log('[SELECT] ===== 학교 선택됨 =====');
        console.log('[SELECT] 지역:', regionName, '학교:', schoolName);
        console.log('[SELECT] applyMappingIfPresent 존재?', typeof window.applyMappingIfPresent);
        
        // Cancel any previous school selection timer
        if(window._schoolSelectionTimer) {
          clearTimeout(window._schoolSelectionTimer);
          console.log('[SELECT] Cancelled previous selection timer');
        }
        
        // Clear any pending auto-save timers
        if(window.draftTimer) {
          clearTimeout(window.draftTimer);
          console.log('[SELECT] Cleared pending auto-save timer');
        }
        
        // Set flag to prevent auto-save during school selection
        if(typeof window._isSelectingSchool !== 'undefined') window._isSelectingSchool = true;
        
        window.selectedRegion = regionName;
        if (hiddenRegionInput) hiddenRegionInput.value = regionName;
        window.selectedSchool = schoolName;
        if (hiddenSchoolInput) hiddenSchoolInput.value = schoolName;
        renderState();
        
        console.log('[SELECT] applyMappingIfPresent 호출 직전...');
        try{
          if (typeof window.applyMappingIfPresent === 'function') {
            console.log('[SELECT] applyMappingIfPresent 호출 시작');
            window.applyMappingIfPresent(regionName, schoolName).catch((err) => {
              console.error('[SELECT] applyMappingIfPresent Promise rejected:', err);
            });
          } else {
            console.error('[SELECT] ❌ window.applyMappingIfPresent가 함수가 아님!', typeof window.applyMappingIfPresent);
          }
        }catch(err){ console.error('[SELECT] ❌ applyMappingIfPresent invocation failed', err); }
        
        // Note: Draft loading is now ONLY done when clicking "Next" button
        // Keep auto-save blocked while in Step1
        if(!window._isStep2Active) {
          console.log('[SELECT] Keeping auto-save blocked (Step1)');
        } else {
          // Re-enable auto-save if we're in Step2 (changing school while in Step2)
          window._schoolSelectionTimer = setTimeout(() => {
            if(window._isStep2Active && typeof window._isSelectingSchool !== 'undefined') {
              window._isSelectingSchool = false; 
              console.log('[SELECT] Auto-save re-enabled (Step2)');
            }
          }, 500);
        }
      }

      function findRegion(name, collection){
        if (!name) return null;
        const list = collection || [];
        for (let i = 0; i < list.length; i += 1){
          if (list[i].name === name) return list[i];
        }
        return null;
      }
    })();
  </script>

  <script>
    // Apply school metadata from CSV mapping files
    (function(){
      window.applyMappingIfPresent = async function(region, school){
        // Normalize and guard against empty or whitespace-only inputs
        try { region = (region || '').toString().trim(); } catch(e) { region = ''; }
        try { school = (school || '').toString().trim(); } catch(e) { school = ''; }
        if (!region || !school) {
          console.log('[Mapping] empty region or school - skipping applyMappingIfPresent', { region, school });
          return;
        }

        // Prevent duplicate application for the same region+school.
        // This avoids double-fetching/applying CSV metadata when the
        // selection handler is invoked multiple times in quick succession.
        try {
          const mapKey = `${region}::${school}`;
          // If a mapping fetch for this key is already in progress, skip.
          if (window._cmass_mappingInProgress === mapKey) {
            console.log('[Mapping] mapping already in progress for', mapKey, ' — skipping duplicate call');
            return;
          }
          // If we've already applied metadata for this exact key, skip re-applying.
          if (window._cmass_lastAppliedMappingKey === mapKey) {
            console.log('[Mapping] mapping already applied for', mapKey, ' — skipping');
            return;
          }
          // Mark as in-progress
          window._cmass_mappingInProgress = mapKey;
        } catch (guardErr) {
          // non-fatal
        }

        try {
          // Try to fetch per-school metadata CSVs first
          const schoolKey = (school || '').replace(/\s+/g, '_');
          const candidates = schoolKey ? [
            `/school_meta/${schoolKey}.csv`,
            `/school_mappings/${schoolKey}.csv`,
            `/mappings/${schoolKey}.csv`
          ] : [];

          let metaData = null;
          for (const path of candidates){
            try{
              const res = await fetch(path, { cache: 'no-store' }).catch(() => null);
              if (!res || !res.ok){ lastError = res ? res.status : 'fetch-failed'; continue; }
              const ct = (res.headers.get('content-type') || '').toLowerCase();
              if (!(ct.includes('csv') || ct.includes('text/plain') || ct.includes('application/octet-stream'))){
                lastError = `unexpected-content-type:${ct}`;
                continue;
              }
              const text = await res.text();
              if (!text || !text.trim()){ lastError = 'empty'; continue; }
              // Prefer small per-school CSV parser to return canonical meta
              const m = (typeof parseSchoolMetaCsv === 'function') ? parseSchoolMetaCsv(text) : null;
              if (m) { metaData = m; console.log('[Mapping] Found metadata for', school, 'at', path); break; }
            }catch(e){
              console.warn('[Mapping] per-school fetch failed for', path, e);
            }
          }
          // Fallback: if no per-school CSV, try the consolidated sales_staff.csv you provided

          // Fallback: if no per-school CSV, try the consolidated sales_staff.csv you provided
          if (!metaData) {
            try {
              console.log('[Mapping] attempting consolidated CSV search using fetchCsvRows()');
              const rows = (typeof fetchCsvRows === 'function') ? await fetchCsvRows().catch(() => null) : null;
              if (rows && rows.length >= 2){
                const headers = (rows[0] || []).map(h => (h || '').trim());

                // detect school column robustly
                let schoolColIndex = -1;
                schoolColIndex = headers.findIndex(h => /^school$/i.test(h) || /^학교$/i.test(h));
                if (schoolColIndex < 0) schoolColIndex = headers.findIndex(h => /\bschool\b/i.test(h));
                if (schoolColIndex < 0) schoolColIndex = headers.findIndex(h => /(^|\s|_)학교(\s|_|$)/i.test(h));
                if (schoolColIndex < 0) schoolColIndex = headers.findIndex(h => /school|학교/i.test(h));

                console.log('[Mapping] consolidated headers count', headers.length, 'sample', headers.slice(0,8));
                console.log('[Mapping] detected schoolColIndex', schoolColIndex);

                function normalizeForMatch(name){
                  if (!name) return '';
                  try{ name = String(name); }catch(e){ name = ''; }
                  try{ if (name.normalize) name = name.normalize('NFKC'); }catch(e){}
                  name = name.replace(/\(.+?\)/g, '');
                  name = name.replace(/[\p{P}\p{S}\s]+/gu, '');
                  name = name.replace(/(고등학교|중학교|초등학교|학교)$/,'');
                  return name.toLowerCase();
                }

                const normTarget = normalizeForMatch(school || '');
                console.log('[Mapping] normTarget for lookup:', normTarget);

                if (schoolColIndex >= 0){
                  let mismatchCount = 0;
                  for (let i = 1; i < rows.length; i++){
                    const row = rows[i] || [];
                    if (!Array.isArray(row) || row.length === 0) continue;
                    if (row.length !== headers.length) mismatchCount += 1;
                    const name = (row[schoolColIndex] || '').trim();
                    const normRow = normalizeForMatch(name);
                    if (i < 6) console.log('[Mapping] sample row', i, 'name:', name, 'normRow:', normRow);
                    if (!name) continue;
                    // exact normalized match
                    if (normRow === normTarget && normTarget){
                      const parsed = {};
                      headers.forEach((h, idx) => { if (typeof row[idx] !== 'undefined' && String(row[idx]).trim() !== '') parsed[h] = row[idx]; });
                      metaData = parsed; console.log('[Mapping] Found metadata for', school, 'in consolidated CSV (row', i, ')'); break;
                    }
                    // substring / token heuristics
                    if (normRow && normTarget){
                      const shortLen = Math.min([...normRow].length, [...normTarget].length);
                      const isSubstr = (normRow.includes(normTarget) || normTarget.includes(normRow));
                      if (isSubstr && shortLen >= 2){ const parsed = {}; headers.forEach((h, idx) => { if (typeof row[idx] !== 'undefined' && String(row[idx]).trim() !== '') parsed[h] = row[idx]; }); metaData = parsed; console.log('[Mapping] Found metadata (partial match) for', school, 'in consolidated CSV (row', i, ')'); break; }
                      try{ const tokensRow = (normRow || '').split(/[^\p{L}\p{N}]+/u).filter(Boolean); const tokensTarget = (normTarget || '').split(/[^\p{L}\p{N}]+/u).filter(Boolean); const shared = tokensRow.filter(t => tokensTarget.includes(t)); if (!metaData && shared.length && shared.some(t => [...t].length >= 2)){ const parsed = {}; headers.forEach((h, idx) => { if (typeof row[idx] !== 'undefined' && String(row[idx]).trim() !== '') parsed[h] = row[idx]; }); metaData = parsed; console.log('[Mapping] Found metadata (token match) for', school, 'in consolidated CSV (row', i, ')', 'shared:', shared); break; } }catch(e){}
                    }
                  }
                  if (mismatchCount) console.log('[Mapping] total rows with length mismatch:', mismatchCount);
                } else {
                  console.warn('[Mapping] could not detect school column in consolidated CSV headers', headers);
                }
              } else {
                console.log('[Mapping] consolidated CSV parsed but no rows found');
              }
            } catch (e) {
              console.warn('[Mapping] consolidated CSV read failed', e);
            }
          }

          if (metaData) {
            // Store and apply the metadata
            window._cmass_lastFoundMeta = metaData;
            try{
              if (typeof window.applyMeta === 'function') window.applyMeta(metaData);
              // Mark this mapping as applied so subsequent identical calls will be no-ops
              try{ window._cmass_lastAppliedMappingKey = `${region}::${school}`; }catch(e){}
            }catch(e){ console.warn('[Mapping] applyMeta failed', e); }
          } else {
            console.log('[Mapping] No metadata found for', school);
          }
        } catch(err) {
          console.warn('[Mapping] Error loading metadata:', err);
        } finally {
          // Clear in-progress flag for this mapping so future different selections can run.
          try{
            const mapKeyClear = `${region}::${school}`;
            if (window._cmass_mappingInProgress === mapKeyClear) window._cmass_mappingInProgress = null;
          }catch(e){}
        }
      };

      function parseSchoolMetaCsv(csvText) {
        if (!csvText || !csvText.trim()) return null;
        
        try {
          const lines = csvText.split(/\r?\n/).filter(l => l.trim());
          if (lines.length < 2) return null;
          
          const headers = lines[0].split(',').map(h => h.trim());
          const values = lines[1].split(',').map(v => v.trim());
          
          const meta = {};
          headers.forEach((header, idx) => {
            if (values[idx]) {
              meta[header] = values[idx];
            }
          });

          // Create canonical alias keys and numeric per-grade totals so consumers
          // can rely on stable names (g1c,g1s,g1avg,g2c,... totalClasses,totalStudents)
          try{
            function findKey(obj, patterns){
              const keys = Object.keys(obj||{});
              for(const p of patterns){
                const re = (typeof p === 'string') ? new RegExp(p,'i') : p;
                for(const k of keys){ if(re.test(k)) return k; }
              }
              return null;
            }

            // staff 담당자
            const staffKey = findKey(meta, ['^staff$','담당자','담당']);
            if (staffKey && !meta.staff) meta.staff = meta[staffKey];

            // 특성화고 담당자 (specialized highschool contact)
            const specialContactKey = findKey(meta, ['특성화.*담당자','특성화고 담당자','특성화 담당자','특성화고 담당']);
            if (specialContactKey && !meta.specialContact) meta.specialContact = meta[specialContactKey];

            // 학교 특성 / 특성화 flag
            const specialFlagKey = findKey(meta, ['특성화','학교특성','특성화고 구분','특성화구분']);
            if (specialFlagKey && !meta.special) meta.special = meta[specialFlagKey];

            // region/code canonical keys
            const regionKey = findKey(meta, ['^region$','지역','시도교육청','교육지원청']);
            if (regionKey && !meta.region) meta.region = meta[regionKey];
            const codeKey = findKey(meta, ['정보공시학교코드','school code','code','학교코드']);
            if (codeKey && !meta.schoolCode) meta.schoolCode = meta[codeKey];

            // Populate numeric canonical grade keys by scanning headers for patterns
            const keys = headers.slice();
            for (let i = 0; i < keys.length; i++){
              const h = (keys[i] || '').trim();
              const hl = h.toLowerCase();
              const v = (values[i] || '').trim();
              if (!v) continue;

              // per-grade class counts (1학년 학급수 등.)
              if (/1\D*학년|\b1학년\b/i.test(h) && /학급/.test(h)) meta.g1c = Number(v) || meta.g1c;
              if (/2\D*학년|\b2학년\b/i.test(h) && /학급/.test(h)) meta.g2c = Number(v) || meta.g2c;
              if (/3\D*학년|\b3학년\b/i.test(h) && /학급/.test(h)) meta.g3c = Number(v) || meta.g3c;

              // per-grade student counts
              if (/1\D*학년|\b1학년\b/i.test(h) && /학생/.test(h)) meta.g1s = Number(v) || meta.g1s;
              if (/2\D*학년|\b2학년\b/i.test(h) && /학생/.test(h)) meta.g2s = Number(v) || meta.g2s;
              if (/3\D*학년|\b3학년\b/i.test(h) && /학생/.test(h)) meta.g3s = Number(v) || meta.g3s;

              // per-grade avg students per class
              if (/1\D*학년|\b1학년\b/i.test(h) && /학급당/.test(h)) meta.g1avg = Number(v) || meta.g1avg;
              if (/2\D*학년|\b2학년\b/i.test(h) && /학급당/.test(h)) meta.g2avg = Number(v) || meta.g2avg;
              if (/3\D*학년|\b3학년\b/i.test(h) && /학급당/.test(h)) meta.g3avg = Number(v) || meta.g3avg;

              // totals: 학급수계 / 학생수계
              if (/학급.*계|학급수계|총학급수|학급수\s*계|학급수$/i.test(h)) meta.totalClasses = Number(v) || meta.totalClasses;
              if (/학생.*계|학생수계|총학생수|학생수\s*계|학생수$/i.test(h)) meta.totalStudents = Number(v) || meta.totalStudents;
            }

            // As a last resort, if totals missing but per-grade present, compute totals (do not overwrite existing totals)
            try{
              if ((!meta.totalClasses || Number.isNaN(meta.totalClasses)) && (meta.g1c || meta.g2c || meta.g3c)){
                meta.totalClasses = (Number(meta.g1c)||0) + (Number(meta.g2c)||0) + (Number(meta.g3c)||0);
              }
              if ((!meta.totalStudents || Number.isNaN(meta.totalStudents)) && (meta.g1s || meta.g2s || meta.g3s)){
                meta.totalStudents = (Number(meta.g1s)||0) + (Number(meta.g2s)||0) + (Number(meta.g3s)||0);
              }
            }catch(e){}
          }catch(e){ console.warn('[Mapping] canonicalize meta keys failed', e); }
          
          return meta;
        } catch(e) {
          console.warn('[Mapping] CSV parse error:', e);
          return null;
        }
      }
    })();
  </script>
  <datalist id="publisherOptions">
    <option value="">출판사 선택</option>
    <option value="씨마스"></option>
    <option value="천재"></option>
    <option value="비상"></option>
    <option value="미래엔"></option>
    <option value="동아"></option>
    <option value="지학사"></option>
    <option value="금성"></option>
    <option value="창비"></option>
    <option value="해냄"></option>
    <option value="능률"></option>
    <option value="삼양"></option>
    <option value="이오북스"></option>
    <option value="YBM"></option>
    <option value="길벗"></option>
    <option value="미진사"></option>
    <option value="다락원"></option>
    <option value="타임"></option>
    <option value="채움"></option>
  </datalist>

  <!-- subject-block template for cloning -->
  <template id="subject-template">
    <div class="subject-block" style="margin-bottom:1rem;padding:1.1rem;background:#f9fafd;border-radius:.95rem;border:1px solid #e0e8f5;position:relative;display:flex;flex-direction:column;gap:0.9rem;">
      <div style="display:flex;flex-direction:column;gap:0.5rem;">
        <label style="font-weight:700;">과목</label>
        <input type="hidden" class="subject-name" name="subject" value="">
        <div class="subject-choice-group" role="group" aria-label="과목 선택">
          <button type="button" class="subject-choice-btn" data-subject="정보" style="border-radius:0.85rem;border:1px solid #d6dbe8;background:#fff;font-weight:700;color:#1e3c72;">정보</button>
          <button type="button" class="subject-choice-btn" data-subject="진로" style="border-radius:0.85rem;border:1px solid #d6dbe8;background:#fff;font-weight:700;color:#1e3c72;">진로</button>
          <button type="button" class="subject-choice-btn" data-subject="보건" style="border-radius:0.85rem;border:1px solid #d6dbe8;background:#fff;font-weight:700;color:#1e3c72;">보건</button>
          <button type="button" class="subject-choice-btn" data-subject="미술" style="border-radius:0.85rem;border:1px solid #d6dbe8;background:#fff;font-weight:700;color:#1e3c72;">미술</button>
          <button type="button" class="subject-choice-btn" data-subject="체육" style="border-radius:0.85rem;border:1px solid #d6dbe8;background:#fff;font-weight:700;color:#1e3c72;">체육</button>
          <button type="button" class="subject-choice-btn" data-subject="도서관사서" style="border-radius:0.85rem;border:1px solid #d6dbe8;background:#fff;font-weight:700;color:#1e3c72;">도서관사서</button>
          <button type="button" class="subject-choice-btn" data-subject="특성화" style="border-radius:0.85rem;border:1px solid #d6dbe8;background:#fff;font-weight:700;color:#1e3c72;">특성화</button>
          <button type="button" class="subject-choice-btn" data-subject="기타" style="border-radius:0.85rem;border:1px solid #d6dbe8;background:#fff;font-weight:700;color:#1e3c72;">기타</button>
        </div>
      </div>

      <div style="display:flex;flex-direction:column;gap:0.5rem;">
        <label style="font-weight:700;">선생님 이름</label>
        <input type="text" class="teacher-name" name="teacher" placeholder="선생님 이름을 입력하세요" style="padding:0.65rem;border-radius:0.85rem;border:1px solid #d6dbe8;background:#fff;" />
      </div>

      <div style="display:flex;flex-direction:column;gap:0.5rem;">
        <label style="font-weight:700;">출판사</label>
        <input type="text" class="publisher-name" name="publisher" placeholder="출판사를 입력하거나 선택하세요" list="publisherOptions" autocomplete="off" style="padding:0.65rem;border-radius:0.85rem;border:1px solid #d6dbe8;background:#fff;" />
      </div>

      <div class="contact-section" style="display:flex;flex-direction:column;gap:0.5rem;">
        <label style="font-weight:700;">연락처</label>
        <div style="display:flex;gap:.5rem;align-items:center;flex-wrap:wrap;">
          <span style="display:inline-block;padding:.55rem .7rem;border-radius:.6rem;background:#f2f4ff;border:1px solid #d6dbe8;color:#12325a;font-weight:700;">010</span>
          <input type="text" class="contact-suffix" placeholder="12345678" maxlength="8" inputmode="numeric" pattern="[0-9]*" aria-label="연락처 뒷자리 8자리 입력" autocomplete="off" style="width:120px;padding:.55rem .6rem;border-radius:.6rem;border:1px solid #d6dbe8;">
          <input type="email" class="contact-email" placeholder="email@example.com" autocomplete="off" spellcheck="false" style="width:220px;padding:.55rem .6rem;border-radius:.6rem;border:1px solid #d6dbe8;">
          <span class="contact-formatted" style="min-width:120px;margin-left:4px;color:#103254;font-weight:700;"></span>
          <button type="button" class="copy-contact" style="margin-left:6px;padding:.4rem .6rem;border-radius:.5rem;border:1px solid #d6dbe8;background:#fff;cursor:pointer;">복사</button>
        </div>
      </div>

      <!-- Friendliness (우호도) -->
      <div class="friendliness-section" style="display:flex;flex-direction:column;gap:0.5rem;margin-top:6px;">
        <label style="font-weight:700;">우호도</label>
  <div class="friend-btn-row">
    <input type="hidden" class="friendliness-input" name="friendliness" value="">
          <button type="button" class="friend-btn" data-value="좋음" style="border-radius:.6rem;border:1px solid #d6dbe8;background:#fff;font-weight:800;color:#1e3c72;cursor:pointer;">좋음</button>
          <button type="button" class="friend-btn" data-value="보통" style="border-radius:.6rem;border:1px solid #d6dbe8;background:#fff;font-weight:800;color:#1e3c72;cursor:pointer;">보통</button>
          <button type="button" class="friend-btn" data-value="나쁨" style="border-radius:.6rem;border:1px solid #d6dbe8;background:#fff;font-weight:800;color:#1e3c72;cursor:pointer;">나쁨</button>
        </div>
      </div>

      <div>
        <label style="font-weight:700;display:block;margin-bottom:6px;">영업활동</label>
        <div class="meeting-buttons main-meeting-buttons selector-grid">
          <button class="selector-btn meeting-btn" type="button"><span class="selector-label">명함인사</span></button>
          <button class="selector-btn meeting-btn" type="button"><span class="selector-label">티칭샘소개</span></button>
          <button class="selector-btn meeting-btn" type="button"><span class="selector-label">채팅방소개</span></button>
          <button class="selector-btn meeting-btn" type="button"><span class="selector-label">브로슈어</span></button>
          <button class="selector-btn meeting-btn" type="button"><span class="selector-label">미팅불가</span></button>
          <button class="selector-btn meeting-btn" type="button"><span class="selector-label">포스터</span></button>
        </div>
        <div class="meeting-buttons info-extra-buttons selector-grid" style="display:none;margin-top:0.6rem;">
          <button class="selector-btn meeting-btn" type="button"><span class="selector-label">가이드북</span></button>
          <button class="selector-btn meeting-btn" type="button"><span class="selector-label">구글클래스룸 사용</span></button>
          <button class="selector-btn meeting-btn" type="button"><span class="selector-label">패들렛 사용</span></button>
          <button class="selector-btn meeting-btn" type="button"><span class="selector-label">하이러닝 사용</span></button>
        </div>
      </div>

      <div>
        <label style="font-weight:700;display:block;margin-bottom:6px;">고객 요청사항</label>
        <textarea class="customer-request" name="customerRequest" rows="2" placeholder="고객 요청사항이 있으면 입력하세요" style="width:100%;padding:.65rem;border-radius:.65rem;border:1px solid #d6dbe8;background:#fff;margin-bottom:0.6rem;"></textarea>
      </div>

      <div>
        <label style="font-weight:700;display:block;margin-bottom:6px;">특이사항</label>
        <textarea class="conversation-detail" name="specialNote" rows="2" placeholder="특이사항을 입력하세요" style="width:100%;padding:.65rem;border-radius:.65rem;border:1px solid #d6dbe8;background:#fff;"></textarea>
      </div>

      <div>
        <label style="font-weight:700;display:block;margin-bottom:6px;">납품사항</label>
        <textarea class="delivery-items" name="deliveryItems" rows="2" placeholder="납품 관련 내용을 입력하세요" style="width:100%;padding:.65rem;border-radius:.65rem;border:1px solid #d6dbe8;background:#fff;margin-bottom:0.6rem;"></textarea>
      </div>

      <div>
        <label style="font-weight:700;display:block;margin-bottom:6px;">후속조치</label>
        <select class="followUpSelect" name="followUp" style="width:100%;padding:.6rem;border-radius:.6rem;border:1px solid #d6dbe8;background:#fff;">
          <option value="">선택하세요</option>
          <option>완료</option>
          <option>고객 요청사항 해소예정</option>
          <option>중요고객 재방문예정</option>
          <option>선정 시기 연락 대기</option>
          <option>워크북 무상지원 제안</option>
          <option>AIDT교육자료 체험계정 제공예정</option>
        </select>
      </div>

      <div style="display:flex;justify-content:flex-end;">
        <button type="button" class="removeSubjectBtn" style="margin:0.3rem 0 0 0;padding:0.55rem 1.2rem;font-size:0.95rem;border-radius:0.7rem;background:#ff9800;color:#fff;border:none;cursor:pointer;">삭제</button>
      </div>
    </div>
  </template>
      <script>
        function updateSubjectChoiceButtons(block, value){
          try{
            if (!block) return;
            const buttons = block.querySelectorAll('.subject-choice-btn');
            buttons.forEach(function(btn){
              const target = btn.dataset ? (btn.dataset.subject || '') : '';
              const isActive = target === value;
              btn.classList.toggle('is-active', isActive);
              btn.setAttribute('aria-pressed', isActive ? 'true' : 'false');
              btn.style.background = isActive ? '#1e3c72' : '#fff';
              btn.style.color = isActive ? '#fff' : '#1e3c72';
              btn.style.borderColor = isActive ? '#1e3c72' : '#d6dbe8';
            });
          }catch(e){ console.warn('updateSubjectChoiceButtons failed', e); }
        }

        function setupSubjectChoiceBlock(block){
          try{
            if (!block || block.dataset.subjectChoiceInit === '1') return;
            block.dataset.subjectChoiceInit = '1';
            const hidden = block.querySelector('.subject-name');
            if (!hidden) return;
            hidden.addEventListener('change', function(){ updateSubjectChoiceButtons(block, hidden.value || ''); });

            const buttons = block.querySelectorAll('.subject-choice-btn');
            buttons.forEach(function(btn){
              btn.addEventListener('click', function(){
                const btnValue = (btn.dataset && btn.dataset.subject) ? btn.dataset.subject : '';
                const current = hidden.value || '';
                const nextValue = current === btnValue ? '' : btnValue;
                if (hidden.value !== nextValue) hidden.value = nextValue;
                updateSubjectChoiceButtons(block, nextValue);
                const changeEvent = new Event('change', { bubbles: true });
                hidden.dispatchEvent(changeEvent);
                try{ if (typeof updateInfoButtons === 'function') updateInfoButtons(); }catch(er){ console.warn('updateInfoButtons failed', er); }
                try{ if (typeof updateSpecialMeetingButtons === 'function') updateSpecialMeetingButtons(); }catch(er){ console.warn('updateSpecialMeetingButtons failed', er); }
              });
            });

            updateSubjectChoiceButtons(block, hidden.value || '');

            // --- Friendliness (우호도) per-block wiring ---
            try{
              const friendInput = block.querySelector('input[name="friendliness"]');
              const friendBtns = Array.from(block.querySelectorAll('.friend-btn')) || [];
              function setFriendLocal(value){
                try{
                  if(friendInput) friendInput.value = value || '';
                  friendBtns.forEach(b=>{
                    try{
                      if(b.dataset && b.dataset.value === value){
                        b.classList.add('is-active');
                        b.style.background = 'linear-gradient(135deg,#1e3c72,#274b9f)';
                        b.style.color = '#fff';
                        b.style.border = '1px solid #1e3c72';
                      } else {
                        b.classList.remove('is-active');
                        b.style.background = '#fff';
                        b.style.color = '#1e3c72';
                        b.style.border = '1px solid #d6dbe8';
                      }
                    }catch(e){}
                  });
                }catch(e){}
              }
              friendBtns.forEach(b=> b.addEventListener('click', function(){ try{ setFriendLocal(this.dataset?.value || ''); }catch(e){} }));
              // initialize from existing hidden value if any
              try{ const initVal = friendInput ? (friendInput.value || '') : ''; if(initVal) setFriendLocal(initVal); }catch(e){}
            }catch(e){ /* ignore friend wiring errors */ }
          }catch(e){ console.warn('setupSubjectChoiceBlock failed', e); }
        }

        // Show/hide additional meeting buttons (info-extra-buttons) for certain subjects
        function updateInfoButtons(){
          try{
            const blocks = Array.from(document.querySelectorAll('.subject-block'));
            blocks.forEach(block => {
              try{
                const subject = (block.querySelector('.subject-name')?.value || '').trim();
                const extra = block.querySelector('.info-extra-buttons');
                if (!extra) return;
                // Show extra buttons for subjects that need them
                const showFor = ['정보','진로'];
                if (subject && showFor.includes(subject)) {
                  extra.style.display = '';
                } else {
                  extra.style.display = 'none';
                }
              }catch(e){}
            });
          }catch(e){ console.warn('updateInfoButtons error', e); }
        }

        // Placeholder for future special meeting button logic; keep no-op to avoid console errors
        function updateSpecialMeetingButtons(){ /* intentionally empty */ }

        // Add Subject Button handler
        (function setupAddSubjectBtn(){
          try{
            const btn = document.getElementById('addSubjectBtn');
            if (!btn) { console.warn('addSubjectBtn not found'); return; }
            btn.addEventListener('click', function(){
              const container = document.getElementById('subjectsBlock');
              const tpl = document.getElementById('subject-template');
              if (!container || !tpl || !tpl.content) { console.warn('subjectsBlock or template missing'); return; }
              const proto = tpl.content.querySelector('.subject-block');
              if (!proto) { console.warn('subject-block prototype not found'); return; }
              const clone = proto.cloneNode(true);
              container.appendChild(clone);
              setupSubjectChoiceBlock(clone);
              if (typeof renumberSubjectBlocks === 'function') renumberSubjectBlocks();
              if (typeof updateInfoButtons === 'function') updateInfoButtons();
              if (typeof updateSpecialMeetingButtons === 'function') updateSpecialMeetingButtons();
            });
          }catch(e){ console.warn('setupAddSubjectBtn failed', e); }
        })();

        // Ensure an initial subject-block exists by cloning the canonical template when the page is parsed.
        (function ensureInitialSubjectBlock(){
          try{
            const container = document.getElementById('subjectsBlock');
            if (!container) return;
            if ((container.querySelectorAll('.subject-block') || []).length === 0) {
              const tpl = document.getElementById('subject-template');
              if (tpl && tpl.content) {
                const proto = tpl.content.querySelector('.subject-block');
                if (proto) {
                  const clone = proto.cloneNode(true);
                  container.appendChild(clone);
                  setupSubjectChoiceBlock(clone);
                  if (typeof renumberSubjectBlocks === 'function') renumberSubjectBlocks();
                  if (typeof updateInfoButtons === 'function') updateInfoButtons();
                  if (typeof updateSpecialMeetingButtons === 'function') updateSpecialMeetingButtons();
                }
              }
            }
          }catch(e){ console.warn('ensureInitialSubjectBlock failed', e); }
        })();
  </script>
  <div class="step2-only">
        <div style="display:flex;gap:.5rem;margin-bottom:.5rem;align-items:center;">
          <div id="tagOptions" style="display:none;"> <!-- hidden: default/basic behavior applied -->
            <label style="font-size:13px;display:flex;align-items:center;gap:.4rem;"><input type="checkbox" id="optHumanLine" checked>한글 라인</label>
            <label style="font-size:13px;display:flex;align-items:center;gap:.4rem;"><input type="checkbox" id="optHashtags">해시태그 포함</label>
            <label style="font-size:13px;display:flex;align-items:center;gap:.4rem;">최대태그수 <input id="optMaxTags" type="number" min="1" max="20" value="8" style="width:56px;padding:.2rem .4rem;border-radius:.4rem;border:1px solid #d6dbe8;margin-left:.4rem;"></label>
          </div>
          <button type="button" id="copyKakaoBtn" style="flex:1;padding:.75rem;border-radius:1rem;border:1px solid #ffd9b3;background:#fff;color:#b25700;font-weight:800;">카톡으로 복사</button>
        </div>
        <div style="display:flex;gap:.5rem;margin-bottom:.5rem;">
          <button type="button" id="saveToServerBtn" style="flex:1;min-width:0;padding:.75rem;border-radius:1rem;border:1px solid #cfe8ff;background:#e9f4ff;color:#0b3a72;font-weight:800;">서버에 저장</button>
        </div>
        <div style="display:flex;gap:.5rem;align-items:center;margin-top:.6rem;">
          <button type="button" id="generateSummaryBtn" style="flex:1;min-width:0;padding:.6rem;border-radius:.6rem;border:1px solid #4CAF50;background:#4CAF50;color:#fff;font-weight:800;">요약 생성</button>
          <button type="button" id="summaryEditToggleBtn" style="display:none;flex:1;min-width:0;padding:.6rem;border-radius:.6rem;border:1px solid #cfe8ff;background:#fff;color:#0b3a72;font-weight:800;">수정</button>
          <button type="button" id="summaryRegenerateBtn" style="flex:1;min-width:0;padding:.6rem;border-radius:.6rem;border:1px solid #e6eefc;background:#f8fbff;color:#0b3a72;font-weight:700;">내용 전체지우기</button>
        </div>
        <div style="display:flex;flex-direction:column;gap:.5rem;">
            <div style="display:flex;align-items:center;gap:.6rem;flex-wrap:wrap;">
            <button type="button" id="chooseCollectTimeBtn" style="padding:.5rem .8rem;border-radius:.6rem;border:1px solid #d6dbe8;background:#fff;color:#0b3a72;font-weight:700;">퇴근보고 시간 설정</button>
            <div id="collectTimeDisplay" style="font-size:13px;color:#3b4b63">기본: 퇴근 시각 기준 + 30분</div>
            <!-- Draft controls removed for multi-school workflow -->
          </div>
          <input type="hidden" id="customCollectStart" value="">
          <input type="hidden" id="customCollectMinutes" value="30">
          <textarea id="generatedSummary" rows="10" readonly style="width:100%;margin-top:.6rem;padding:.8rem;border-radius:.8rem;border:1px solid #d6dbe8;display:block;">요약이 여기에 생성됩니다.</textarea>
          </div>
      <!-- follow-up select is now per subject-block -->
      </div>
    </form>
  </div>

  <script>
    // Button handlers: Copy to Kakao, Generate Summary, Form Submit
    (function(){
      'use strict';

      // Collect all form data
      function collectFormData() {
        try {
          const visitDate = document.getElementById('visitDate')?.value || '';
          const region = window.selectedRegion || '';
          const school = window.selectedSchool || '';
          const staff = window._cmass_staffParam || '';
          
          const visitStartHour = document.getElementById('visitStartHour')?.value || '';
          const visitStartMinute = document.getElementById('visitStartMinute')?.value || '';
          const visitDuration = document.getElementById('visitDurationInput')?.value || '';
          const visitEndTime = document.getElementById('visitEndTime')?.value || '';
          
          // Collect all subject blocks
          const subjects = [];
          const subjectBlocks = document.querySelectorAll('.subject-block');
          
          subjectBlocks.forEach(block => {
            const subject = block.querySelector('.subject-name')?.value || '';
            const teacher = block.querySelector('.teacher-name')?.value || '';
            const publisher = block.querySelector('.publisher-name')?.value || '';
            const contactSuffix = block.querySelector('.contact-suffix')?.value || '';
            const contactEmail = block.querySelector('.contact-email')?.value || '';
            const contactFormatted = contactSuffix ? `010-${contactSuffix}` : '';
            const friendliness = block.querySelector('.friendliness-input')?.value || '';
            
            // Collect active meeting buttons
            const meetings = [];
            const activeMeetingBtns = block.querySelectorAll('.meeting-btn.is-active');
            activeMeetingBtns.forEach(btn => {
              const label = btn.querySelector('.selector-label')?.textContent || btn.textContent;
              if (label) meetings.push(label.trim());
            });
            
            const customerRequest = block.querySelector('.customer-request')?.value || '';
            const conversation = block.querySelector('.conversation-detail')?.value || '';
            const delivery = block.querySelector('.delivery-items')?.value || '';
            const followUp = block.querySelector('.followUpSelect')?.value || '';
            
            if (subject || teacher) {
              subjects.push({
                subject,
                teacher,
                publisher,
                contactSuffix,
                contactEmail,
                contactFormatted,
                friendliness,
                meetings,
                customerRequest,
                conversation,
                delivery,
                followUp
              });
            }
          });
          
          return {
            visitDate,
            region,
            school,
            staff,
            visitStartHour,
            visitStartMinute,
            visitDuration,
            visitEndTime,
            subjects
          };
        } catch (error) {
          console.error('[collectFormData] Error:', error);
          return null;
        }
      }

      // Generate summary text
      function generateSummary() {
        // Use accumulated visit list instead of single form data
        const visitList = window._cmass_visitList || [];
        
        if (visitList.length === 0) {
          console.warn('[Summary] No accumulated visits');
          return '';
        }

        // Use first visit for date and staff info
        const firstVisit = visitList[0];
        const staff = firstVisit.staff || '영업사원';
        const visitDate = firstVisit.visitDate || '-';

        // Calculate total stats across all visits
        let totalMeetings = 0;
        let totalContactCount = 0;
        let earliestStartMinutes = Infinity;
        let latestEndMinutes = 0;

        visitList.forEach(visit => {
          totalMeetings += visit.subjects.reduce((sum, subj) => sum + (subj.meetings?.length || 0), 0);
          totalContactCount += visit.subjects.filter(subj => subj.contactFormatted || subj.contactSuffix).length;
          
          const startHour = parseInt(visit.visitStartHour) || 0;
          const startMinute = parseInt(visit.visitStartMinute) || 0;
          const startTotal = startHour * 60 + startMinute;
          const durationMinutes = parseInt(visit.visitDuration) || 0;
          const endTotal = startTotal + durationMinutes;
          
          if (startTotal < earliestStartMinutes) earliestStartMinutes = startTotal;
          if (endTotal > latestEndMinutes) latestEndMinutes = endTotal;
        });

        const startHour = Math.floor(earliestStartMinutes / 60);
        const startMinute = earliestStartMinutes % 60;
        const endHour = Math.floor(latestEndMinutes / 60);
        const endMinute = latestEndMinutes % 60;
        const totalDurationMinutes = latestEndMinutes - earliestStartMinutes;
        const durationHours = Math.floor(totalDurationMinutes / 60);
        const remainMinutes = totalDurationMinutes % 60;

        // Build header
        let summary = `(${staff} 부장 퇴근보고)\n`;
        summary += `방문일: ${visitDate}\n`;
        summary += `총 방문 학교: ${visitList.length}개 · 총 미팅수: ${totalMeetings}건 · 연락처 확보: ${totalContactCount}건 · 추가선정 확인: 0건\n\n`;

        // 1. Commute time
        summary += `1. 출근: ${String(startHour).padStart(2,'0')}:${String(startMinute).padStart(2,'0')} · `;
        summary += `퇴근: ${String(endHour).padStart(2,'0')}:${String(endMinute).padStart(2,'0')} `;
        summary += `(${durationHours}시간 ${remainMinutes}분)\n\n`;

        // 2. Detailed work
        summary += `2. 세부업무\n\n`;

        // Iterate through each school visit
        const schoolLabels = ['가', '나', '다', '라', '마', '바', '사', '아', '자', '차'];
        visitList.forEach((visit, schoolIdx) => {
          const label = schoolLabels[schoolIdx] || String.fromCharCode(0xAC00 + schoolIdx);
          
          const visitStartHour = parseInt(visit.visitStartHour) || 0;
          const visitStartMinute = parseInt(visit.visitStartMinute) || 0;
          const visitDuration = parseInt(visit.visitDuration) || 0;
          const visitEndHour = Math.floor((visitStartHour * 60 + visitStartMinute + visitDuration) / 60);
          const visitEndMinute = (visitStartHour * 60 + visitStartMinute + visitDuration) % 60;

          const schoolMeta = visit.schoolMeta || {};
          const establishType = schoolMeta.설립구분 || '';
          const studentCount = schoolMeta.학생수계 || '';
          const schoolType = schoolMeta.학교급 || '';

          summary += `${label}. ${visit.school || '-'} (${establishType}, ${studentCount}명, ${schoolType})\n`;
          summary += ` ${String(visitStartHour).padStart(2,'0')}:${String(visitStartMinute).padStart(2,'0')}~${String(visitEndHour).padStart(2,'0')}:${String(visitEndMinute).padStart(2,'0')} (${visitDuration}분)\n\n`;

          // Subject details
          visit.subjects.forEach((subj, subjIdx) => {
            summary += `-${label}${subjIdx+1}. ${subj.subject || '-'} ${subj.teacher || '-'}`;
            if (subj.contactFormatted) summary += ` (${subj.contactFormatted})`;
            if (subj.meetings && subj.meetings.length > 0) {
              summary += ` · ${subj.meetings.join(' · ')}`;
            }
            if (subj.delivery) summary += ` · ${subj.delivery}`;
            summary += `\n`;
          });
          
          summary += `\n`;
        });

        summary += `3. 퇴근보고 자료 정리 (${String(endHour).padStart(2,'0')}:${String(endMinute).padStart(2,'0')}~${String(endHour).padStart(2,'0')}:${String(endMinute + 30).padStart(2,'0')}) (30분)\n\n`;
        summary += `- 끝.\n\n`;

        // Auto tags - aggregate all subjects
        const subjectCounts = {};
        const schoolNames = [];
        visitList.forEach(visit => {
          if (visit.school) schoolNames.push(visit.school);
          visit.subjects.forEach(subj => {
            if (subj.subject) {
              subjectCounts[subj.subject] = (subjectCounts[subj.subject] || 0) + 1;
            }
          });
        });
        
        const majorSubjects = Object.entries(subjectCounts)
          .map(([subj, count]) => `${subj}(${count}회)`)
          .join(', ');
        
        summary += `자동 태그: 주요과목: ${majorSubjects || '없음'}`;
        if (schoolNames.length > 0) summary += `, 재방문: ${schoolNames.join(', ')}`;

        return summary.trim();
      }

      // Copy to clipboard for KakaoTalk
      function copyToKakao() {
        const summary = generateSummary();
        if (!summary) {
          alert('입력된 데이터가 없습니다.');
          return;
        }
        
        navigator.clipboard.writeText(summary).then(() => {
          alert('✅ 카카오톡에 붙여넣기 할 수 있습니다!');
        }).catch(err => {
          console.error('복사 실패:', err);
          alert('❌ 복사 실패. 다시 시도해주세요.');
        });
      }

      // Initialize button handlers
      document.addEventListener('DOMContentLoaded', function() {
        // Initialize visit accumulation list
        if (!window._cmass_visitList) {
          window._cmass_visitList = [];
        }
        
        // Check if returning from input-next.html with new visit data
        try {
          const newVisitData = sessionStorage.getItem('cmass_newVisit');
          if (newVisitData) {
            const visit = JSON.parse(newVisitData);
            // Add school metadata if available
            visit.schoolMeta = window._cmass_lastFoundMeta || {};
            window._cmass_visitList.push(visit);
            sessionStorage.removeItem('cmass_newVisit');
            console.log('[Init] Added visit from input-next:', visit);
          }
        } catch(e) {
          console.warn('[Init] Failed to load visit from session:', e);
        }
        
        // Update visit accumulation status
        function updateVisitAccumStatus() {
          const statusEl = document.getElementById('visitAccumStatus');
          if (statusEl) {
            const count = (window._cmass_visitList || []).length;
            statusEl.textContent = `누적: ${count}개 학교`;
            statusEl.style.background = count > 0 ? '#e8f5e9' : '#f0f7ff';
            statusEl.style.color = count > 0 ? '#2e7d32' : '#1e3c72';
          }
        }
        
        // Reset visit list button
        const resetBtn = document.getElementById('resetVisitListBtn');
        if (resetBtn) {
          resetBtn.addEventListener('click', function() {
            if (confirm('누적된 모든 방문 기록을 초기화하시겠습니까?')) {
              window._cmass_visitList = [];
              updateVisitAccumStatus();
              console.log('[Reset] Visit list cleared');
              alert('새 보고서가 시작되었습니다.');
            }
          });
        }
        
        // Initial status update
        updateVisitAccumStatus();
        
        // Expose update function globally
        window.updateVisitAccumStatus = updateVisitAccumStatus;
        
        // Step1 action buttons
        const copyKakaoBtn_step1 = document.getElementById('copyKakaoBtn_step1');
        if (copyKakaoBtn_step1) {
          copyKakaoBtn_step1.addEventListener('click', function() {
            const summary = document.getElementById('generatedSummary_step1').value;
            if (!summary || summary === '요약이 여기에 생성됩니다.') {
              alert('먼저 요약을 생성해주세요.');
              return;
            }
            navigator.clipboard.writeText(summary).then(() => {
              alert('✅ 카카오톡에 붙여넣기 할 수 있습니다!');
            }).catch(err => {
              console.error('복사 실패:', err);
              alert('❌ 복사 실패. 다시 시도해주세요.');
            });
          });
        }
        
        const saveToServerBtn_step1 = document.getElementById('saveToServerBtn_step1');
        if (saveToServerBtn_step1) {
          saveToServerBtn_step1.addEventListener('click', function() {
            alert('서버 저장 기능은 추후 구현 예정입니다.');
          });
        }
        
        const generateSummaryBtn_step1 = document.getElementById('generateSummaryBtn_step1');
        if (generateSummaryBtn_step1) {
          generateSummaryBtn_step1.addEventListener('click', function() {
            const summary = generateSummary();
            document.getElementById('generatedSummary_step1').value = summary || '누적된 방문 기록이 없습니다.';
          });
        }
        
        const clearSummaryBtn_step1 = document.getElementById('clearSummaryBtn_step1');
        if (clearSummaryBtn_step1) {
          clearSummaryBtn_step1.addEventListener('click', function() {
            if (confirm('요약 내용을 모두 지우시겠습니까?')) {
              document.getElementById('generatedSummary_step1').value = '요약이 여기에 생성됩니다.';
            }
          });
        }
        
        // Copy to KakaoTalk button (Step2)
        const copyKakaoBtn = document.getElementById('copyKakaoBtn');
        if (copyKakaoBtn) {
          copyKakaoBtn.addEventListener('click', copyToKakao);
          console.log('[Buttons] copyKakaoBtn handler attached');
        }
        
        // Generate summary button
        const generateSummaryBtn = document.getElementById('generateSummaryBtn');
        const summaryTextarea = document.getElementById('generatedSummary');
        
        if (generateSummaryBtn && summaryTextarea) {
          generateSummaryBtn.addEventListener('click', function() {
            const summary = generateSummary();
            summaryTextarea.value = summary || '요약할 데이터가 없습니다.';
            summaryTextarea.readOnly = false;
          });
          console.log('[Buttons] generateSummaryBtn handler attached');
        }
        
        // Summary regenerate button
        const summaryRegenerateBtn = document.getElementById('summaryRegenerateBtn');
        if (summaryRegenerateBtn && summaryTextarea) {
          summaryRegenerateBtn.addEventListener('click', function() {
            if (confirm('요약 내용을 모두 지우시겠습니까?')) {
              summaryTextarea.value = '요약이 여기에 생성됩니다.';
              summaryTextarea.readOnly = true;
            }
          });
          console.log('[Buttons] summaryRegenerateBtn handler attached');
        }
        
        // Form submit button
        const salesForm = document.getElementById('salesForm');
        if (salesForm) {
          salesForm.addEventListener('submit', function(e) {
            e.preventDefault();
            const data = collectFormData();
            console.log('[Form Submit] Data:', data);
            
            // Initialize visit list if needed
            if (!window._cmass_visitList) {
              window._cmass_visitList = [];
            }
            
            // Add current school metadata to the visit data
            data.schoolMeta = window._cmass_lastFoundMeta || {};
            
            // Add to accumulated visits
            window._cmass_visitList.push(data);
            console.log('[Form Submit] Added to visit list. Total schools:', window._cmass_visitList.length);
            
            // Update accumulation status
            if (typeof window.updateVisitAccumStatus === 'function') {
              window.updateVisitAccumStatus();
            }
            
            // Show confirmation
            alert(`입력 완료! (${window._cmass_visitList.length}개 학교)`);
            
            // Return to Step1 for next school entry
            const step1 = document.getElementById('step1');
            const step2 = document.getElementById('step2');
            if (step1) step1.style.display = 'block';
            if (step2) step2.style.display = 'none';
            document.body.classList.remove('cmass-step2');
            window._isStep2Active = false;
            
            // Clear draft timer
            if (window.draftTimer) {
              clearTimeout(window.draftTimer);
              window.draftTimer = null;
            }
            
            // Reset form for next school
            const subjectsBlock = document.getElementById('subjectsBlock');
            if (subjectsBlock) subjectsBlock.innerHTML = '';
            
            // Reset selection state
            window.selectedRegion = null;
            window.selectedSchool = null;
            window._cmass_lastFoundMeta = null;
            
            // Scroll to top
            window.scrollTo(0, 0);
          });
          console.log('[Buttons] Form submit handler attached');
        }
      });

      // Expose functions globally
      window.collectFormData = collectFormData;
      window.generateSummary = generateSummary;
      window.copyToKakao = copyToKakao;

      // Draft functionality DISABLED for multi-school workflow
      // (Previously caused confusion when switching between schools)
      function draftKeyFor(data){ return null; }
      function updateDraftStatus(){ /* disabled */ }
      function saveDraft(){ return false; }
      function clearLocalDraft(){ return false; }
      function loadDraft(){ return false; }

      // Draft functionality disabled for multi-school workflow
      // (Auto-save removed to prevent confusion when entering multiple schools)
    })();
  </script>

  <script>
    (function(){
      'use strict';
      
      // Wait for Firebase to be initialized
      function waitForFirebase() {
        return new Promise((resolve, reject) => {
          if (window.firebaseDb) {
            resolve();
            return;
          }
          let attempts = 0;
          const interval = setInterval(() => {
            attempts++;
            if (window.firebaseDb) {
              clearInterval(interval);
              resolve();
            } else if (attempts > 50) {
              clearInterval(interval);
              reject(new Error('Firebase initialization timeout'));
            }
          }, 100);
        });
      }

      // Convert form data to Firestore format (matching existing structure)
      function convertToFirestoreFormat(formData) {
        const visit = {
          meta: {
            visitDate: formData.visitDate || '',
            visitStartTime: formData.visitStartHour && formData.visitStartMinute 
              ? `${formData.visitStartHour}:${formData.visitStartMinute}` 
              : '',
            visitDuration: formData.visitDuration || '',
            visitEndTime: formData.visitEndTime || '',
            region: formData.region || '',
            school: formData.school || '',
            staff: formData.staff || ''
          },
          summary: formData.summary || '',
          subjects: formData.subjects.map(subj => ({
            subject: subj.subject || '',
            teacher: subj.teacher || '',
            publisher: subj.publisher || '',
            contact: subj.contactFormatted || (subj.contactSuffix ? `010-${subj.contactSuffix}` : ''),
            email: subj.contactEmail || '',
            friendliness: subj.friendliness || '',
            meetings: subj.meetings || [],
            customerRequest: subj.customerRequest || '',
            conversation: subj.conversation || '',
            deliveryItems: subj.delivery || '',
            followUp: subj.followUp || ''
          }))
        };

        return {
          createdAt: window.firestoreServerTimestamp(),
          staff: formData.staff || '',
          visits: [visit]
        };
      }

      // Save to Firestore
      async function saveToFirestore() {
        try {
          // Show loading state
          const btn = document.getElementById('saveToServerBtn');
          if (btn) {
            btn.disabled = true;
            btn.textContent = '저장 중...';
          }

          // Wait for Firebase
          await waitForFirebase();

          // Collect form data
          const formData = typeof collectFormData === 'function' ? collectFormData() : null;
          if (!formData) {
            throw new Error('폼 데이터를 수집할 수 없습니다.');
          }

          // Validate required fields
          if (!formData.visitDate) {
            throw new Error('방문일을 입력해주세요.');
          }
          if (!formData.region || !formData.school) {
            throw new Error('지역과 학교를 선택해주세요.');
          }
          if (!formData.subjects || formData.subjects.length === 0) {
            throw new Error('최소 하나의 과목 정보를 입력해주세요.');
          }

          // Convert to Firestore format
          const firestoreData = convertToFirestoreFormat(formData);

          // Check if document with same staff-visitDate-region-school already exists
          const visitsRef = window.firestoreCollection(window.firebaseDb, 'visits');
          const q = window.firestoreQuery(
            visitsRef,
            window.firestoreWhere('staff', '==', formData.staff),
            window.firestoreWhere('visits', 'array-contains', null) // will search manually
          );

          // Since Firestore doesn't support deep array queries easily, we fetch all matching staff docs
          const querySnapshot = await window.firestoreGetDocs(
            window.firestoreQuery(
              visitsRef,
              window.firestoreWhere('staff', '==', formData.staff)
            )
          );

          let existingDocId = null;
          querySnapshot.forEach((doc) => {
            const data = doc.data();
            if (data.visits && data.visits.length > 0) {
              const visit = data.visits[0];
              if (visit.meta &&
                  visit.meta.visitDate === formData.visitDate &&
                  visit.meta.region === formData.region &&
                  visit.meta.school === formData.school) {
                existingDocId = doc.id;
              }
            }
          });

          // Save to Firestore (update if exists, create if new)
          if (existingDocId) {
            await window.firestoreUpdateDoc(
              window.firestoreDoc(window.firebaseDb, 'visits', existingDocId),
              firestoreData
            );
            console.log('[Firestore] Document updated with ID:', existingDocId);
          } else {
            const docRef = await window.firestoreAddDoc(visitsRef, firestoreData);
            console.log('[Firestore] Document created with ID:', docRef.id);
          }

          // Show success message
          if (typeof showToast === 'function') {
            showToast('✅ 서버에 저장되었습니다!', 2000);
          } else {
            alert('✅ 서버에 저장되었습니다!');
          }

          // Reset button
          if (btn) {
            btn.disabled = false;
            btn.textContent = '서버에 저장';
          }

        } catch (error) {
          console.error('[Firestore] Save error:', error);
          
          // Show error message
          const errorMsg = error.message || '저장 중 오류가 발생했습니다.';
          if (typeof showToast === 'function') {
            showToast('❌ ' + errorMsg, 3000);
          } else {
            alert('❌ ' + errorMsg);
          }

          // Reset button
          const btn = document.getElementById('saveToServerBtn');
          if (btn) {
            btn.disabled = false;
            btn.textContent = '서버에 저장';
          }
        }
      }

      // Attach event listener when DOM is ready
      document.addEventListener('DOMContentLoaded', function() {
        const saveBtn = document.getElementById('saveToServerBtn');
        if (saveBtn) {
          saveBtn.addEventListener('click', saveToFirestore);
          console.log('[Firestore] Save button handler attached');
        } else {
          console.warn('[Firestore] Save button not found');
        }
      });

    })();
  </script>

  <!-- Debug block removed -->
<!-- Portrait-lock overlay styles and element (moved to body end to avoid parsing order issues) -->
  <style id="cmass-landscape-style">
    #cmass-landscape-overlay { position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(8,12,30,0.92); color:#fff; z-index:99999; text-align:center; padding:2rem; -webkit-user-select:none; user-select:none; }
    #cmass-landscape-overlay .card { max-width:420px; background:transparent; }
    #cmass-landscape-overlay h3 { font-size:1.4rem; margin-bottom:0.6rem }
    #cmass-landscape-overlay p { opacity:0.95; line-height:1.4 }
  </style>
  <div id="cmass-landscape-overlay" aria-hidden="true">
    <div class="card">
      <h3>세로 모드에서만 사용하세요</h3>
      <p>기기를 세로로 돌려주세요. 화면을 가로로 돌리는 동안 입력이 사라지는 문제를 막기 위해 잠시 사용을 제한합니다.</p>
      <div style="margin-top:12px;text-align:center">
        <button id="cmass-overlay-lock-btn" class="alt-btn" style="padding:10px 14px;border-radius:10px;margin-right:8px">세로로 전환</button>
        <button id="cmass-overlay-retry-btn" class="alt-btn" style="padding:10px 14px;border-radius:10px">다시 시도</button>
        <div style="margin-top:8px;font-size:12px;opacity:0.95;color:#eef">(버튼을 누르면 가능하면 화면을 세로로 고정합니다)</div>
        <div id="cmass-overlay-ios-help" style="margin-top:8px;font-size:13px;opacity:0.95;color:#eef;display:none">
          iOS/Safari에서는 자동 고정이 지원되지 않을 수 있습니다. 기기를 직접 세로로 돌려주시거나, 아래 '다시 시도'를 눌러보세요.
        </div>
      </div>
    </div>
  </div>
  <script>
    (function(){
      // Only show the portrait-lock overlay on mobile-like devices.
      // Desktop users (large screens / non-mobile UA) should not see this overlay.
      function isMobileDevice(){
        try{
          const ua = navigator.userAgent || '';
          const mobileUA = /Mobi|Android|iPhone|iPad|iPod|Windows Phone/i;
          const hasTouch = (navigator.maxTouchPoints && navigator.maxTouchPoints > 0) || ('ontouchstart' in window);
          const narrowScreen = (typeof screen !== 'undefined' && screen.width) ? screen.width <= 1024 : false;
          return mobileUA.test(ua) || (hasTouch && narrowScreen);
        }catch(e){ return false; }
      }
      function updatePortraitOverlay(){
        try{
          const overlay = document.getElementById('cmass-landscape-overlay');
          try{ if (sessionStorage && sessionStorage.getItem && sessionStorage.getItem('cmass_overlay_dismissed')){ if (overlay) overlay.style.display = 'none'; return; } }catch(e){}
          const mobile = isMobileDevice();
          // Determine landscape using reliable sources (prefer matchMedia / screen.orientation)
          let isLandscape = false;
          try{
            if (window.matchMedia && window.matchMedia('(orientation: landscape)').matches) isLandscape = true;
            else if (screen && screen.orientation && typeof screen.orientation.type === 'string') isLandscape = screen.orientation.type.indexOf('landscape') === 0;
            else if (typeof screen !== 'undefined' && screen.width && screen.height) isLandscape = screen.width > screen.height;
          }catch(e){ /* fallback below */ }

          if (mobile && isLandscape) {
            if (overlay) overlay.style.display = 'flex';
            try{ document.documentElement.style.overflow = 'hidden'; }catch(e){}
            try{ if (screen.orientation && screen.orientation.lock) screen.orientation.lock('portrait').catch(()=>{}); }catch(e){}
          } else {
            if (overlay) overlay.style.display = 'none';
            try{ document.documentElement.style.overflow = 'auto'; }catch(e){}
          }
        }catch(e){/* ignore */}
      }
      window.addEventListener('resize', updatePortraitOverlay);
      window.addEventListener('orientationchange', updatePortraitOverlay);
      document.addEventListener('DOMContentLoaded', function(){
          updatePortraitOverlay();
          // show iOS help text when appropriate
          try{
            const isiOS = /iP(hone|od|ad)/i.test(navigator.userAgent || '');
            const help = document.getElementById('cmass-overlay-ios-help');
            if (isiOS && help) help.style.display = '';
          }catch(e){}
        // wire up the manual lock/dismiss button
        try{
          const btn = document.getElementById('cmass-overlay-lock-btn');
          if (btn) btn.addEventListener('click', async function(){
            const overlay = document.getElementById('cmass-landscape-overlay');
            try{
              if (screen && screen.orientation && typeof screen.orientation.lock === 'function'){
                await screen.orientation.lock('portrait');
              }
            }catch(e){ /* locking may fail in some browsers, ignore */ }
            try{ if (overlay) overlay.style.display = 'none'; }catch(e){}
            try{ document.documentElement.style.overflow = 'auto'; }catch(e){}
            try{ sessionStorage.setItem('cmass_overlay_dismissed','1'); }catch(e){}
          });
          // retry button: useful for iOS/Safari where lock may fail; hide overlay and prompt user
          const retryBtn = document.getElementById('cmass-overlay-retry-btn');
          if (retryBtn) retryBtn.addEventListener('click', async function(){
            const overlay = document.getElementById('cmass-landscape-overlay');
            try{
              if (screen && screen.orientation && typeof screen.orientation.lock === 'function'){
                await screen.orientation.lock('portrait');
              } else {
                // show a brief guidance toast/alert for iOS users
                try{ alert('이 브라우저에서는 자동 고정이 지원되지 않을 수 있습니다. 기기를 직접 세로로 돌려주세요.'); }catch(e){}
              }
            }catch(e){ try{ alert('세로 고정 시도에 실패했습니다. 기기를 직접 세로로 돌려주세요.'); }catch(er){} }
            try{ if (overlay) overlay.style.display = 'none'; }catch(e){}
            try{ document.documentElement.style.overflow = 'auto'; }catch(e){}
            try{ sessionStorage.setItem('cmass_overlay_dismissed','1'); }catch(e){}
          });
          // hide overlay automatically while typing: when any focusable text input is focused, hide overlay
          document.addEventListener('focusin', function(ev){
            try{
              const t = ev.target;
              if (!t) return;
              const tag = (t.tagName || '').toLowerCase();
              const type = (t.type || '').toLowerCase();
              const isTextInput = tag === 'input' && (type === 'text' || type === 'search' || type === 'tel' || type === 'email' || type === 'number' || type === 'password') || tag === 'textarea' || (t.isContentEditable);
              if (isTextInput){ const overlay = document.getElementById('cmass-landscape-overlay'); if (overlay) overlay.style.display = 'none'; }
            }catch(e){}
          });
          // when input blur, re-evaluate overlay after short delay
          document.addEventListener('focusout', function(){ setTimeout(updatePortraitOverlay, 300); });
        }catch(e){}
      });
    })();
  </script>

  <!-- Firestore Save Functionality -->
  <!-- Firestore Save Functionality -->
  <script>
    (function(){
      'use strict';
      
      // Wait for Firebase to be initialized
      function waitForFirebase() {
        return new Promise((resolve, reject) => {
          if (window.firebaseDb) {
            resolve();
            return;
          }
          let attempts = 0;
          const interval = setInterval(() => {
            attempts++;
            if (window.firebaseDb) {
              clearInterval(interval);
              resolve();
            } else if (attempts > 50) {
              clearInterval(interval);
              reject(new Error('Firebase initialization timeout'));
            }
          }, 100);
        });
      }

      // Convert form data to Firestore format (matching existing structure)
      function convertToFirestoreFormat(formData) {
        const visit = {
          meta: {
            visitDate: formData.visitDate || '',
            visitStartTime: formData.visitStartHour && formData.visitStartMinute 
              ? `${formData.visitStartHour}:${formData.visitStartMinute}` 
              : '',
            visitDuration: formData.visitDuration || '',
            visitEndTime: formData.visitEndTime || '',
            region: formData.region || '',
            school: formData.school || '',
            staff: formData.staff || ''
          },
          summary: formData.summary || '',
          subjects: formData.subjects.map(subj => ({
            subject: subj.subject || '',
            teacher: subj.teacher || '',
            publisher: subj.publisher || '',
            contact: subj.contactFormatted || (subj.contactSuffix ? `010-${subj.contactSuffix}` : ''),
            email: subj.contactEmail || '',
            friendliness: subj.friendliness || '',
            meetings: subj.meetings || [],
            customerRequest: subj.customerRequest || '',
            conversation: subj.conversation || '',
            deliveryItems: subj.delivery || '',
            followUp: subj.followUp || ''
          }))
        };

        return {
          createdAt: window.firestoreServerTimestamp(),
          staff: formData.staff || '',
          visits: [visit]
        };
      }

      // Save to Firestore
      async function saveToFirestore() {
        try {
          // Show loading state
          const btn = document.getElementById('saveToServerBtn');
          if (btn) {
            btn.disabled = true;
            btn.textContent = '저장 중...';
          }

          // Wait for Firebase
          await waitForFirebase();

          // Collect form data
          const formData = typeof collectFormData === 'function' ? collectFormData() : null;
          if (!formData) {
            throw new Error('폼 데이터를 수집할 수 없습니다.');
          }

          // Validate required fields
          if (!formData.visitDate) {
            throw new Error('방문일을 입력해주세요.');
          }
          if (!formData.region || !formData.school) {
            throw new Error('지역과 학교를 선택해주세요.');
          }
          if (!formData.subjects || formData.subjects.length === 0) {
            throw new Error('최소 하나의 과목 정보를 입력해주세요.');
          }

          // Convert to Firestore format
          const firestoreData = convertToFirestoreFormat(formData);

          // Check if document with same staff-visitDate-region-school already exists
          const visitsRef = window.firestoreCollection(window.firebaseDb, 'visits');
          const q = window.firestoreQuery(
            visitsRef,
            window.firestoreWhere('staff', '==', formData.staff),
            window.firestoreWhere('visits', 'array-contains', null) // will search manually
          );

          // Since Firestore doesn't support deep array queries easily, we fetch all matching staff docs
          const querySnapshot = await window.firestoreGetDocs(
            window.firestoreQuery(
              visitsRef,
              window.firestoreWhere('staff', '==', formData.staff)
            )
          );

          let existingDocId = null;
          querySnapshot.forEach((doc) => {
            const data = doc.data();
            if (data.visits && data.visits.length > 0) {
              const visit = data.visits[0];
              if (visit.meta &&
                  visit.meta.visitDate === formData.visitDate &&
                  visit.meta.region === formData.region &&
                  visit.meta.school === formData.school) {
                existingDocId = doc.id;
              }
            }
          });

          // Save to Firestore (update if exists, create if new)
          if (existingDocId) {
            await window.firestoreUpdateDoc(
              window.firestoreDoc(window.firebaseDb, 'visits', existingDocId),
              firestoreData
            );
            console.log('[Firestore] Document updated with ID:', existingDocId);
          } else {
            const docRef = await window.firestoreAddDoc(visitsRef, firestoreData);
            console.log('[Firestore] Document created with ID:', docRef.id);
          }

          // Show success message
          if (typeof showToast === 'function') {
            showToast('✅ 서버에 저장되었습니다!', 2000);
          } else {
            alert('✅ 서버에 저장되었습니다!');
          }

          // Reset button
          if (btn) {
            btn.disabled = false;
            btn.textContent = '서버에 저장';
          }

        } catch (error) {
          console.error('[Firestore] Save error:', error);
          
          // Show error message
          const errorMsg = error.message || '저장 중 오류가 발생했습니다.';
          if (typeof showToast === 'function') {
            showToast('❌ ' + errorMsg, 3000);
          } else {
            alert('❌ ' + errorMsg);
          }

          // Reset button
          const btn = document.getElementById('saveToServerBtn');
          if (btn) {
            btn.disabled = false;
            btn.textContent = '서버에 저장';
          }
        }
      }

      // Attach event listener when DOM is ready
      document.addEventListener('DOMContentLoaded', function() {
        const saveBtn = document.getElementById('saveToServerBtn');
        if (saveBtn) {
          saveBtn.addEventListener('click', saveToFirestore);
          console.log('[Firestore] Save button handler attached');
        } else {
          console.warn('[Firestore] Save button not found');
        }
      });

    })();
  </script>

  <!-- Debug block removed -->
<!-- Portrait-lock overlay styles and element (moved to body end to avoid parsing order issues) -->
  <style id="cmass-landscape-style">
    #cmass-landscape-overlay { position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(8,12,30,0.92); color:#fff; z-index:99999; text-align:center; padding:2rem; -webkit-user-select:none; user-select:none; }
    #cmass-landscape-overlay .card { max-width:420px; background:transparent; }
    #cmass-landscape-overlay h3 { font-size:1.4rem; margin-bottom:0.6rem }
    #cmass-landscape-overlay p { opacity:0.95; line-height:1.4 }
  </style>
  <div id="cmass-landscape-overlay" aria-hidden="true">
    <div class="card">
      <h3>세로 모드에서만 사용하세요</h3>
      <p>기기를 세로로 돌려주세요. 화면을 가로로 돌리는 동안 입력이 사라지는 문제를 막기 위해 잠시 사용을 제한합니다.</p>
      <div style="margin-top:12px;text-align:center">
        <button id="cmass-overlay-lock-btn" class="alt-btn" style="padding:10px 14px;border-radius:10px;margin-right:8px">세로로 전환</button>
        <button id="cmass-overlay-retry-btn" class="alt-btn" style="padding:10px 14px;border-radius:10px">다시 시도</button>
        <div style="margin-top:8px;font-size:12px;opacity:0.95;color:#eef">(버튼을 누르면 가능하면 화면을 세로로 고정합니다)</div>
        <div id="cmass-overlay-ios-help" style="margin-top:8px;font-size:13px;opacity:0.95;color:#eef;display:none">
          iOS/Safari에서는 자동 고정이 지원되지 않을 수 있습니다. 기기를 직접 세로로 돌려주시거나, 아래 '다시 시도'를 눌러보세요.
        </div>
      </div>
    </div>
  </div>
  <script>
    (function(){
      // Only show the portrait-lock overlay on mobile-like devices.
      // Desktop users (large screens / non-mobile UA) should not see this overlay.
      function isMobileDevice(){
        try{
          const ua = navigator.userAgent || '';
          const mobileUA = /Mobi|Android|iPhone|iPad|iPod|Windows Phone/i;
          const hasTouch = (navigator.maxTouchPoints && navigator.maxTouchPoints > 0) || ('ontouchstart' in window);
          const narrowScreen = (typeof screen !== 'undefined' && screen.width) ? screen.width <= 1024 : false;
          return mobileUA.test(ua) || (hasTouch && narrowScreen);
        }catch(e){ return false; }
      }
      function updatePortraitOverlay(){
        try{
          const overlay = document.getElementById('cmass-landscape-overlay');
          try{ if (sessionStorage && sessionStorage.getItem && sessionStorage.getItem('cmass_overlay_dismissed')){ if (overlay) overlay.style.display = 'none'; return; } }catch(e){}
          const mobile = isMobileDevice();
          // Determine landscape using reliable sources (prefer matchMedia / screen.orientation)
          let isLandscape = false;
          try{
            if (window.matchMedia && window.matchMedia('(orientation: landscape)').matches) isLandscape = true;
            else if (screen && screen.orientation && typeof screen.orientation.type === 'string') isLandscape = screen.orientation.type.indexOf('landscape') === 0;
            else if (typeof screen !== 'undefined' && screen.width && screen.height) isLandscape = screen.width > screen.height;
          }catch(e){ /* fallback below */ }

          if (mobile && isLandscape) {
            if (overlay) overlay.style.display = 'flex';
            try{ document.documentElement.style.overflow = 'hidden'; }catch(e){}
            try{ if (screen.orientation && screen.orientation.lock) screen.orientation.lock('portrait').catch(()=>{}); }catch(e){}
          } else {
            if (overlay) overlay.style.display = 'none';
            try{ document.documentElement.style.overflow = 'auto'; }catch(e){}
          }
        }catch(e){/* ignore */}
      }
      window.addEventListener('resize', updatePortraitOverlay);
      window.addEventListener('orientationchange', updatePortraitOverlay);
      document.addEventListener('DOMContentLoaded', function(){
          updatePortraitOverlay();
          // show iOS help text when appropriate
          try{
            const isiOS = /iP(hone|od|ad)/i.test(navigator.userAgent || '');
            const help = document.getElementById('cmass-overlay-ios-help');
            if (isiOS && help) help.style.display = '';
          }catch(e){}
        // wire up the manual lock/dismiss button
        try{
          const btn = document.getElementById('cmass-overlay-lock-btn');
          if (btn) btn.addEventListener('click', async function(){
            const overlay = document.getElementById('cmass-landscape-overlay');
            try{
              if (screen && screen.orientation && typeof screen.orientation.lock === 'function'){
                await screen.orientation.lock('portrait');
              }
            }catch(e){ /* locking may fail in some browsers, ignore */ }
            try{ if (overlay) overlay.style.display = 'none'; }catch(e){}
            try{ document.documentElement.style.overflow = 'auto'; }catch(e){}
            try{ sessionStorage.setItem('cmass_overlay_dismissed','1'); }catch(e){}
          });
          // retry button: useful for iOS/Safari where lock may fail; hide overlay and prompt user
          const retryBtn = document.getElementById('cmass-overlay-retry-btn');
          if (retryBtn) retryBtn.addEventListener('click', async function(){
            const overlay = document.getElementById('cmass-landscape-overlay');
            try{
              if (screen && screen.orientation && typeof screen.orientation.lock === 'function'){
                await screen.orientation.lock('portrait');
              } else {
                // show a brief guidance toast/alert for iOS users
                try{ alert('이 브라우저에서는 자동 고정이 지원되지 않을 수 있습니다. 기기를 직접 세로로 돌려주세요.'); }catch(e){}
              }
            }catch(e){ try{ alert('세로 고정 시도에 실패했습니다. 기기를 직접 세로로 돌려주세요.'); }catch(er){} }
            try{ if (overlay) overlay.style.display = 'none'; }catch(e){}
            try{ document.documentElement.style.overflow = 'auto'; }catch(e){}
            try{ sessionStorage.setItem('cmass_overlay_dismissed','1'); }catch(e){}
          });
          // hide overlay automatically while typing: when any focusable text input is focused, hide overlay
          document.addEventListener('focusin', function(ev){
            try{
              const t = ev.target;
              if (!t) return;
              const tag = (t.tagName || '').toLowerCase();
              const type = (t.type || '').toLowerCase();
              const isTextInput = tag === 'input' && (type === 'text' || type === 'search' || type === 'tel' || type === 'email' || type === 'number' || type === 'password') || tag === 'textarea' || (t.isContentEditable);
              if (isTextInput){ const overlay = document.getElementById('cmass-landscape-overlay'); if (overlay) overlay.style.display = 'none'; }
            }catch(e){}
          });
          // when input blur, re-evaluate overlay after short delay
          document.addEventListener('focusout', function(){ setTimeout(updatePortraitOverlay, 300); });
        }catch(e){}
      });
    })();
  </script>


  <!-- Debug block removed -->
<!-- Portrait-lock overlay styles and element (moved to body end to avoid parsing order issues) -->
  <style id="cmass-landscape-style">
    #cmass-landscape-overlay { position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(8,12,30,0.92); color:#fff; z-index:99999; text-align:center; padding:2rem; -webkit-user-select:none; user-select:none; }
    #cmass-landscape-overlay .card { max-width:420px; background:transparent; }
    #cmass-landscape-overlay h3 { font-size:1.4rem; margin-bottom:0.6rem }
    #cmass-landscape-overlay p { opacity:0.95; line-height:1.4 }
  </style>
  <div id="cmass-landscape-overlay" aria-hidden="true">
    <div class="card">
      <h3>세로 모드에서만 사용하세요</h3>
      <p>기기를 세로로 돌려주세요. 화면을 가로로 돌리는 동안 입력이 사라지는 문제를 막기 위해 잠시 사용을 제한합니다.</p>
      <div style="margin-top:12px;text-align:center">
        <button id="cmass-overlay-lock-btn" class="alt-btn" style="padding:10px 14px;border-radius:10px;margin-right:8px">세로로 전환</button>
        <button id="cmass-overlay-retry-btn" class="alt-btn" style="padding:10px 14px;border-radius:10px">다시 시도</button>
        <div style="margin-top:8px;font-size:12px;opacity:0.95;color:#eef">(버튼을 누르면 가능하면 화면을 세로로 고정합니다)</div>
        <div id="cmass-overlay-ios-help" style="margin-top:8px;font-size:13px;opacity:0.95;color:#eef;display:none">
          iOS/Safari에서는 자동 고정이 지원되지 않을 수 있습니다. 기기를 직접 세로로 돌려주시거나, 아래 '다시 시도'를 눌러보세요.
        </div>
      </div>
    </div>
  </div>
  <script>
    (function(){
      // Only show the portrait-lock overlay on mobile-like devices.
      // Desktop users (large screens / non-mobile UA) should not see this overlay.
      function isMobileDevice(){
        try{
          const ua = navigator.userAgent || '';
          const mobileUA = /Mobi|Android|iPhone|iPad|iPod|Windows Phone/i;
          const hasTouch = (navigator.maxTouchPoints && navigator.maxTouchPoints > 0) || ('ontouchstart' in window);
          const narrowScreen = (typeof screen !== 'undefined' && screen.width) ? screen.width <= 1024 : false;
          return mobileUA.test(ua) || (hasTouch && narrowScreen);
        }catch(e){ return false; }
      }
      function updatePortraitOverlay(){
        try{
          const overlay = document.getElementById('cmass-landscape-overlay');
          try{ if (sessionStorage && sessionStorage.getItem && sessionStorage.getItem('cmass_overlay_dismissed')){ if (overlay) overlay.style.display = 'none'; return; } }catch(e){}
          const mobile = isMobileDevice();
          // Determine landscape using reliable sources (prefer matchMedia / screen.orientation)
          let isLandscape = false;
          try{
            if (window.matchMedia && window.matchMedia('(orientation: landscape)').matches) isLandscape = true;
            else if (screen && screen.orientation && typeof screen.orientation.type === 'string') isLandscape = screen.orientation.type.indexOf('landscape') === 0;
            else if (typeof screen !== 'undefined' && screen.width && screen.height) isLandscape = screen.width > screen.height;
          }catch(e){ /* fallback below */ }

          if (mobile && isLandscape) {
            if (overlay) overlay.style.display = 'flex';
            try{ document.documentElement.style.overflow = 'hidden'; }catch(e){}
            try{ if (screen.orientation && screen.orientation.lock) screen.orientation.lock('portrait').catch(()=>{}); }catch(e){}
          } else {
            if (overlay) overlay.style.display = 'none';
            try{ document.documentElement.style.overflow = 'auto'; }catch(e){}
          }
        }catch(e){/* ignore */}
      }
      window.addEventListener('resize', updatePortraitOverlay);
      window.addEventListener('orientationchange', updatePortraitOverlay);
      document.addEventListener('DOMContentLoaded', function(){
          updatePortraitOverlay();
          // show iOS help text when appropriate
          try{
            const isiOS = /iP(hone|od|ad)/i.test(navigator.userAgent || '');
            const help = document.getElementById('cmass-overlay-ios-help');
            if (isiOS && help) help.style.display = '';
          }catch(e){}
        // wire up the manual lock/dismiss button
        try{
          const btn = document.getElementById('cmass-overlay-lock-btn');
          if (btn) btn.addEventListener('click', async function(){
            const overlay = document.getElementById('cmass-landscape-overlay');
            try{
              if (screen && screen.orientation && typeof screen.orientation.lock === 'function'){
                await screen.orientation.lock('portrait');
              }
            }catch(e){ /* locking may fail in some browsers, ignore */ }
            try{ if (overlay) overlay.style.display = 'none'; }catch(e){}
            try{ document.documentElement.style.overflow = 'auto'; }catch(e){}
            try{ sessionStorage.setItem('cmass_overlay_dismissed','1'); }catch(e){}
          });
          // retry button: useful for iOS/Safari where lock may fail; hide overlay and prompt user
          const retryBtn = document.getElementById('cmass-overlay-retry-btn');
          if (retryBtn) retryBtn.addEventListener('click', async function(){
            const overlay = document.getElementById('cmass-landscape-overlay');
            try{
              if (screen && screen.orientation && typeof screen.orientation.lock === 'function'){
                await screen.orientation.lock('portrait');
              } else {
                // show a brief guidance toast/alert for iOS users
                try{ alert('이 브라우저에서는 자동 고정이 지원되지 않을 수 있습니다. 기기를 직접 세로로 돌려주세요.'); }catch(e){}
              }
            }catch(e){ try{ alert('세로 고정 시도에 실패했습니다. 기기를 직접 세로로 돌려주세요.'); }catch(er){} }
            try{ if (overlay) overlay.style.display = 'none'; }catch(e){}
            try{ document.documentElement.style.overflow = 'auto'; }catch(e){}
            try{ sessionStorage.setItem('cmass_overlay_dismissed','1'); }catch(e){}
          });
          // hide overlay automatically while typing: when any focusable text input is focused, hide overlay
          document.addEventListener('focusin', function(ev){
            try{
              const t = ev.target;
              if (!t) return;
              const tag = (t.tagName || '').toLowerCase();
              const type = (t.type || '').toLowerCase();
              const isTextInput = tag === 'input' && (type === 'text' || type === 'search' || type === 'tel' || type === 'email' || type === 'number' || type === 'password') || tag === 'textarea' || (t.isContentEditable);
              if (isTextInput){ const overlay = document.getElementById('cmass-landscape-overlay'); if (overlay) overlay.style.display = 'none'; }
            }catch(e){}
          });
          // when input blur, re-evaluate overlay after short delay
          document.addEventListener('focusout', function(){ setTimeout(updatePortraitOverlay, 300); });
        }catch(e){}
      });
    })();
  </script>


  <!-- Debug block removed -->
<!-- Portrait-lock overlay styles and element (moved to body end to avoid parsing order issues) -->
  <style id="cmass-landscape-style">
    #cmass-landscape-overlay { position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(8,12,30,0.92); color:#fff; z-index:99999; text-align:center; padding:2rem; -webkit-user-select:none; user-select:none; }
    #cmass-landscape-overlay .card { max-width:420px; background:transparent; }
    #cmass-landscape-overlay h3 { font-size:1.4rem; margin-bottom:0.6rem }
    #cmass-landscape-overlay p { opacity:0.95; line-height:1.4 }
  </style>
  <div id="cmass-landscape-overlay" aria-hidden="true">
    <div class="card">
      <h3>세로 모드에서만 사용하세요</h3>
      <p>기기를 세로로 돌려주세요. 화면을 가로로 돌리는 동안 입력이 사라지는 문제를 막기 위해 잠시 사용을 제한합니다.</p>
      <div style="margin-top:12px;text-align:center">
        <button id="cmass-overlay-lock-btn" class="alt-btn" style="padding:10px 14px;border-radius:10px;margin-right:8px">세로로 전환</button>
        <button id="cmass-overlay-retry-btn" class="alt-btn" style="padding:10px 14px;border-radius:10px">다시 시도</button>
        <div style="margin-top:8px;font-size:12px;opacity:0.95;color:#eef">(버튼을 누르면 가능하면 화면을 세로로 고정합니다)</div>
        <div id="cmass-overlay-ios-help" style="margin-top:8px;font-size:13px;opacity:0.95;color:#eef;display:none">
          iOS/Safari에서는 자동 고정이 지원되지 않을 수 있습니다. 기기를 직접 세로로 돌려주시거나, 아래 '다시 시도'를 눌러보세요.
        </div>
      </div>
    </div>
  </div>
  <script>
    (function(){
      // Only show the portrait-lock overlay on mobile-like devices.
      // Desktop users (large screens / non-mobile UA) should not see this overlay.
      function isMobileDevice(){
        try{
          const ua = navigator.userAgent || '';
          const mobileUA = /Mobi|Android|iPhone|iPad|iPod|Windows Phone/i;
          const hasTouch = (navigator.maxTouchPoints && navigator.maxTouchPoints > 0) || ('ontouchstart' in window);
          const narrowScreen = (typeof screen !== 'undefined' && screen.width) ? screen.width <= 1024 : false;
          return mobileUA.test(ua) || (hasTouch && narrowScreen);
        }catch(e){ return false; }
      }
      function updatePortraitOverlay(){
        try{
          const overlay = document.getElementById('cmass-landscape-overlay');
          try{ if (sessionStorage && sessionStorage.getItem && sessionStorage.getItem('cmass_overlay_dismissed')){ if (overlay) overlay.style.display = 'none'; return; } }catch(e){}
          const mobile = isMobileDevice();
          // Determine landscape using reliable sources (prefer matchMedia / screen.orientation)
          let isLandscape = false;
          try{
            if (window.matchMedia && window.matchMedia('(orientation: landscape)').matches) isLandscape = true;
            else if (screen && screen.orientation && typeof screen.orientation.type === 'string') isLandscape = screen.orientation.type.indexOf('landscape') === 0;
            else if (typeof screen !== 'undefined' && screen.width && screen.height) isLandscape = screen.width > screen.height;
          }catch(e){ /* fallback below */ }

          if (mobile && isLandscape) {
            if (overlay) overlay.style.display = 'flex';
            try{ document.documentElement.style.overflow = 'hidden'; }catch(e){}
            try{ if (screen.orientation && screen.orientation.lock) screen.orientation.lock('portrait').catch(()=>{}); }catch(e){}
          } else {
            if (overlay) overlay.style.display = 'none';
            try{ document.documentElement.style.overflow = 'auto'; }catch(e){}
          }
        }catch(e){/* ignore */}
      }
      window.addEventListener('resize', updatePortraitOverlay);
      window.addEventListener('orientationchange', updatePortraitOverlay);
      document.addEventListener('DOMContentLoaded', function(){
          updatePortraitOverlay();
          // show iOS help text when appropriate
          try{
            const isiOS = /iP(hone|od|ad)/i.test(navigator.userAgent || '');
            const help = document.getElementById('cmass-overlay-ios-help');
            if (isiOS && help) help.style.display = '';
          }catch(e){}
        // wire up the manual lock/dismiss button
        try{
          const btn = document.getElementById('cmass-overlay-lock-btn');
          if (btn) btn.addEventListener('click', async function(){
            const overlay = document.getElementById('cmass-landscape-overlay');
            try{
              if (screen && screen.orientation && typeof screen.orientation.lock === 'function'){
                await screen.orientation.lock('portrait');
              }
            }catch(e){ /* locking may fail in some browsers, ignore */ }
            try{ if (overlay) overlay.style.display = 'none'; }catch(e){}
            try{ document.documentElement.style.overflow = 'auto'; }catch(e){}
            try{ sessionStorage.setItem('cmass_overlay_dismissed','1'); }catch(e){}
          });
          // retry button: useful for iOS/Safari where lock may fail; hide overlay and prompt user
          const retryBtn = document.getElementById('cmass-overlay-retry-btn');
          if (retryBtn) retryBtn.addEventListener('click', async function(){
            const overlay = document.getElementById('cmass-landscape-overlay');
            try{
              if (screen && screen.orientation && typeof screen.orientation.lock === 'function'){
                await screen.orientation.lock('portrait');
              } else {
                // show a brief guidance toast/alert for iOS users
                try{ alert('이 브라우저에서는 자동 고정이 지원되지 않을 수 있습니다. 기기를 직접 세로로 돌려주세요.'); }catch(e){}
              }
            }catch(e){ try{ alert('세로 고정 시도에 실패했습니다. 기기를 직접 세로로 돌려주세요.'); }catch(er){} }
            try{ if (overlay) overlay.style.display = 'none'; }catch(e){}
            try{ document.documentElement.style.overflow = 'auto'; }catch(e){}
            try{ sessionStorage.setItem('cmass_overlay_dismissed','1'); }catch(e){}
          });
          // hide overlay automatically while typing: when any focusable text input is focused, hide overlay
          document.addEventListener('focusin', function(ev){
            try{
              const t = ev.target;
              if (!t) return;
              const tag = (t.tagName || '').toLowerCase();
              const type = (t.type || '').toLowerCase();
              const isTextInput = tag === 'input' && (type === 'text' || type === 'search' || type === 'tel' || type === 'email' || type === 'number' || type === 'password') || tag === 'textarea' || (t.isContentEditable);
              if (isTextInput){ const overlay = document.getElementById('cmass-landscape-overlay'); if (overlay) overlay.style.display = 'none'; }
            }catch(e){}
          });
          // when input blur, re-evaluate overlay after short delay
          document.addEventListener('focusout', function(){ setTimeout(updatePortraitOverlay, 300); });
        }catch(e){}
      });
    })();
  </script>


  <!-- Debug block removed -->
<!-- Portrait-lock overlay styles and element (moved to body end to avoid parsing order issues) -->
  <style id="cmass-landscape-style">
    #cmass-landscape-overlay { position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(8,12,30,0.92); color:#fff; z-index:99999; text-align:center; padding:2rem; -webkit-user-select:none; user-select:none; }
    #cmass-landscape-overlay .card { max-width:420px; background:transparent; }
    #cmass-landscape-overlay h3 { font-size:1.4rem; margin-bottom:0.6rem }
    #cmass-landscape-overlay p { opacity:0.95; line-height:1.4 }
  </style>
  <div id="cmass-landscape-overlay" aria-hidden="true">
    <div class="card">
      <h3>세로 모드에서만 사용하세요</h3>
      <p>기기를 세로로 돌려주세요. 화면을 가로로 돌리는 동안 입력이 사라지는 문제를 막기 위해 잠시 사용을 제한합니다.</p>
      <div style="margin-top:12px;text-align:center">
        <button id="cmass-overlay-lock-btn" class="alt-btn" style="padding:10px 14px;border-radius:10px;margin-right:8px">세로로 전환</button>
        <button id="cmass-overlay-retry-btn" class="alt-btn" style="padding:10px 14px;border-radius:10px">다시 시도</button>
        <div style="margin-top:8px;font-size:12px;opacity:0.95;color:#eef">(버튼을 누르면 가능하면 화면을 세로로 고정합니다)</div>
        <div id="cmass-overlay-ios-help" style="margin-top:8px;font-size:13px;opacity:0.95;color:#eef;display:none">
          iOS/Safari에서는 자동 고정이 지원되지 않을 수 있습니다. 기기를 직접 세로로 돌려주시거나, 아래 '다시 시도'를 눌러보세요.
        </div>
      </div>
    </div>
  </div>
  <script>
    (function(){
      // Only show the portrait-lock overlay on mobile-like devices.
      // Desktop users (large screens / non-mobile UA) should not see this overlay.
      function isMobileDevice(){
        try{
          const ua = navigator.userAgent || '';
          const mobileUA = /Mobi|Android|iPhone|iPad|iPod|Windows Phone/i;
          const hasTouch = (navigator.maxTouchPoints && navigator.maxTouchPoints > 0) || ('ontouchstart' in window);
          const narrowScreen = (typeof screen !== 'undefined' && screen.width) ? screen.width <= 1024 : false;
          return mobileUA.test(ua) || (hasTouch && narrowScreen);
        }catch(e){ return false; }
      }
      function updatePortraitOverlay(){
        try{
          const overlay = document.getElementById('cmass-landscape-overlay');
          try{ if (sessionStorage && sessionStorage.getItem && sessionStorage.getItem('cmass_overlay_dismissed')){ if (overlay) overlay.style.display = 'none'; return; } }catch(e){}
          const mobile = isMobileDevice();
          // Determine landscape using reliable sources (prefer matchMedia / screen.orientation)
          let isLandscape = false;
          try{
            if (window.matchMedia && window.matchMedia('(orientation: landscape)').matches) isLandscape = true;
            else if (screen && screen.orientation && typeof screen.orientation.type === 'string') isLandscape = screen.orientation.type.indexOf('landscape') === 0;
            else if (typeof screen !== 'undefined' && screen.width && screen.height) isLandscape = screen.width > screen.height;
          }catch(e){ /* fallback below */ }

          if (mobile && isLandscape) {
            if (overlay) overlay.style.display = 'flex';
            try{ document.documentElement.style.overflow = 'hidden'; }catch(e){}
            try{ if (screen.orientation && screen.orientation.lock) screen.orientation.lock('portrait').catch(()=>{}); }catch(e){}
          } else {
            if (overlay) overlay.style.display = 'none';
            try{ document.documentElement.style.overflow = 'auto'; }catch(e){}
          }
        }catch(e){/* ignore */}
      }
      window.addEventListener('resize', updatePortraitOverlay);
      window.addEventListener('orientationchange', updatePortraitOverlay);
      document.addEventListener('DOMContentLoaded', function(){
          updatePortraitOverlay();
          // show iOS help text when appropriate
          try{
            const isiOS = /iP(hone|od|ad)/i.test(navigator.userAgent || '');
            const help = document.getElementById('cmass-overlay-ios-help');
            if (isiOS && help) help.style.display = '';
          }catch(e){}
        // wire up the manual lock/dismiss button
        try{
          const btn = document.getElementById('cmass-overlay-lock-btn');
          if (btn) btn.addEventListener('click', async function(){
            const overlay = document.getElementById('cmass-landscape-overlay');
            try{
              if (screen && screen.orientation && typeof screen.orientation.lock === 'function'){
                await screen.orientation.lock('portrait');
              }
            }catch(e){ /* locking may fail in some browsers, ignore */ }
            try{ if (overlay) overlay.style.display = 'none'; }catch(e){}
            try{ document.documentElement.style.overflow = 'auto'; }catch(e){}
            try{ sessionStorage.setItem('cmass_overlay_dismissed','1'); }catch(e){}
          });
          // retry button: useful for iOS/Safari where lock may fail; hide overlay and prompt user
          const retryBtn = document.getElementById('cmass-overlay-retry-btn');
          if (retryBtn) retryBtn.addEventListener('click', async function(){
            const overlay = document.getElementById('cmass-landscape-overlay');
            try{
              if (screen && screen.orientation && typeof screen.orientation.lock === 'function'){
                await screen.orientation.lock('portrait');
              } else {
                // show a brief guidance toast/alert for iOS users
                try{ alert('이 브라우저에서는 자동 고정이 지원되지 않을 수 있습니다. 기기를 직접 세로로 돌려주세요.'); }catch(e){}
              }
            }catch(e){ try{ alert('세로 고정 시도에 실패했습니다. 기기를 직접 세로로 돌려주세요.'); }catch(er){} }
            try{ if (overlay) overlay.style.display = 'none'; }catch(e){}
            try{ document.documentElement.style.overflow = 'auto'; }catch(e){}
            try{ sessionStorage.setItem('cmass_overlay_dismissed','1'); }catch(e){}
          });
          // hide overlay automatically while typing: when any focusable text input is focused, hide overlay
          document.addEventListener('focusin', function(ev){
            try{
              const t = ev.target;
              if (!t) return;
              const tag = (t.tagName || '').toLowerCase();
              const type = (t.type || '').toLowerCase();
              const isTextInput = tag === 'input' && (type === 'text' || type === 'search' || type === 'tel' || type === 'email' || type === 'number' || type === 'password') || tag === 'textarea' || (t.isContentEditable);
              if (isTextInput){ const overlay = document.getElementById('cmass-landscape-overlay'); if (overlay) overlay.style.display = 'none'; }
            }catch(e){}
          });
          // when input blur, re-evaluate overlay after short delay
          document.addEventListener('focusout', function(){ setTimeout(updatePortraitOverlay, 300); });
        }catch(e){}
      });
    })();
  </script>


  <!-- Debug block removed -->
<!-- Portrait-lock overlay styles and element (moved to body end to avoid parsing order issues) -->
  <style id="cmass-landscape-style">
    #cmass-landscape-overlay { position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(8,12,30,0.92); color:#fff; z-index:99999; text-align:center; padding:2rem; -webkit-user-select:none; user-select:none; }
    #cmass-landscape-overlay .card { max-width:420px; background:transparent; }
    #cmass-landscape-overlay h3 { font-size:1.4rem; margin-bottom:0.6rem }
    #cmass-landscape-overlay p { opacity:0.95; line-height:1.4 }
  </style>
  <div id="cmass-landscape-overlay" aria-hidden="true">
    <div class="card">
      <h3>세로 모드에서만 사용하세요</h3>
      <p>기기를 세로로 돌려주세요. 화면을 가로로 돌리는 동안 입력이 사라지는 문제를 막기 위해 잠시 사용을 제한합니다.</p>
      <div style="margin-top:12px;text-align:center">
        <button id="cmass-overlay-lock-btn" class="alt-btn" style="padding:10px 14px;border-radius:10px;margin-right:8px">세로로 전환</button>
        <button id="cmass-overlay-retry-btn" class="alt-btn" style="padding:10px 14px;border-radius:10px">다시 시도</button>
        <div style="margin-top:8px;font-size:12px;opacity:0.95;color:#eef">(버튼을 누르면 가능하면 화면을 세로로 고정합니다)</div>
        <div id="cmass-overlay-ios-help" style="margin-top:8px;font-size:13px;opacity:0.95;color:#eef;display:none">
          iOS/Safari에서는 자동 고정이 지원되지 않을 수 있습니다. 기기를 직접 세로로 돌려주시거나, 아래 '다시 시도'를 눌러보세요.
        </div>
      </div>
    </div>
  </div>
  <script>
    (function(){
      // Only show the portrait-lock overlay on mobile-like devices.
      // Desktop users (large screens / non-mobile UA) should not see this overlay.
      function isMobileDevice(){
        try{
          const ua = navigator.userAgent || '';
          const mobileUA = /Mobi|Android|iPhone|iPad|iPod|Windows Phone/i;
          const hasTouch = (navigator.maxTouchPoints && navigator.maxTouchPoints > 0) || ('ontouchstart' in window);
          const narrowScreen = (typeof screen !== 'undefined' && screen.width) ? screen.width <= 1024 : false;
          return mobileUA.test(ua) || (hasTouch && narrowScreen);
        }catch(e){ return false; }
      }
      function updatePortraitOverlay(){
        try{
          const overlay = document.getElementById('cmass-landscape-overlay');
          try{ if (sessionStorage && sessionStorage.getItem && sessionStorage.getItem('cmass_overlay_dismissed')){ if (overlay) overlay.style.display = 'none'; return; } }catch(e){}
          const mobile = isMobileDevice();
          // Determine landscape using reliable sources (prefer matchMedia / screen.orientation)
          let isLandscape = false;
          try{
            if (window.matchMedia && window.matchMedia('(orientation: landscape)').matches) isLandscape = true;
            else if (screen && screen.orientation && typeof screen.orientation.type === 'string') isLandscape = screen.orientation.type.indexOf('landscape') === 0;
            else if (typeof screen !== 'undefined' && screen.width && screen.height) isLandscape = screen.width > screen.height;
          }catch(e){ /* fallback below */ }

          if (mobile && isLandscape) {
            if (overlay) overlay.style.display = 'flex';
            try{ document.documentElement.style.overflow = 'hidden'; }catch(e){}
            try{ if (screen.orientation && screen.orientation.lock) screen.orientation.lock('portrait').catch(()=>{}); }catch(e){}
          } else {
            if (overlay) overlay.style.display = 'none';
            try{ document.documentElement.style.overflow = 'auto'; }catch(e){}
          }
        }catch(e){/* ignore */}
      }
      window.addEventListener('resize', updatePortraitOverlay);
      window.addEventListener('orientationchange', updatePortraitOverlay);
      document.addEventListener('DOMContentLoaded', function(){
          updatePortraitOverlay();
          // show iOS help text when appropriate
          try{
            const isiOS = /iP(hone|od|ad)/i.test(navigator.userAgent || '');
            const help = document.getElementById('cmass-overlay-ios-help');
            if (isiOS && help) help.style.display = '';
          }catch(e){}
        // wire up the manual lock/dismiss button
        try{
          const btn = document.getElementById('cmass-overlay-lock-btn');
          if (btn) btn.addEventListener('click', async function(){
            const overlay = document.getElementById('cmass-landscape-overlay');
            try{
              if (screen && screen.orientation && typeof screen.orientation.lock === 'function'){
                await screen.orientation.lock('portrait');
              }
            }catch(e){ /* locking may fail in some browsers, ignore */ }
            try{ if (overlay) overlay.style.display = 'none'; }catch(e){}
            try{ document.documentElement.style.overflow = 'auto'; }catch(e){}
            try{ sessionStorage.setItem('cmass_overlay_dismissed','1'); }catch(e){}
          });
          // retry button: useful for iOS/Safari where lock may fail; hide overlay and prompt user
          const retryBtn = document.getElementById('cmass-overlay-retry-btn');
          if (retryBtn) retryBtn.addEventListener('click', async function(){
            const overlay = document.getElementById('cmass-landscape-overlay');
            try{
              if (screen && screen.orientation && typeof screen.orientation.lock === 'function'){
                await screen.orientation.lock('portrait');
              } else {
                // show a brief guidance toast/alert for iOS users
                try{ alert('이 브라우저에서는 자동 고정이 지원되지 않을 수 있습니다. 기기를 직접 세로로 돌려주세요.'); }catch(e){}
              }
            }catch(e){ try{ alert('세로 고정 시도에 실패했습니다. 기기를 직접 세로로 돌려주세요.'); }catch(er){} }
            try{ if (overlay) overlay.style.display = 'none'; }catch(e){}
            try{ document.documentElement.style.overflow = 'auto'; }catch(e){}
            try{ sessionStorage.setItem('cmass_overlay_dismissed','1'); }catch(e){}
          });
          // hide overlay automatically while typing: when any focusable text input is focused, hide overlay
          document.addEventListener('focusin', function(ev){
            try{
              const t = ev.target;
              if (!t) return;
              const tag = (t.tagName || '').toLowerCase();
              const type = (t.type || '').toLowerCase();
              const isTextInput = tag === 'input' && (type === 'text' || type === 'search' || type === 'tel' || type === 'email' || type === 'number' || type === 'password') || tag === 'textarea' || (t.isContentEditable);
              if (isTextInput){ const overlay = document.getElementById('cmass-landscape-overlay'); if (overlay) overlay.style.display = 'none'; }
            }catch(e){}
          });
          // when input blur, re-evaluate overlay after short delay
          document.addEventListener('focusout', function(){ setTimeout(updatePortraitOverlay, 300); });
        }catch(e){}
      });
    })();
  </script>


  <!-- Debug block removed -->
<!-- Portrait-lock overlay styles and element (moved to body end to avoid parsing order issues) -->
  <style id="cmass-landscape-style">
    #cmass-landscape-overlay { position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(8,12,30,0.92); color:#fff; z-index:99999; text-align:center; padding:2rem; -webkit-user-select:none; user-select:none; }
    #cmass-landscape-overlay .card { max-width:420px; background:transparent; }
    #cmass-landscape-overlay h3 { font-size:1.4rem; margin-bottom:0.6rem }
    #cmass-landscape-overlay p { opacity:0.95; line-height:1.4 }
  </style>
  <div id="cmass-landscape-overlay" aria-hidden="true">
    <div class="card">
      <h3>세로 모드에서만 사용하세요</h3>
      <p>기기를 세로로 돌려주세요. 화면을 가로로 돌리는 동안 입력이 사라지는 문제를 막기 위해 잠시 사용을 제한합니다.</p>
      <div style="margin-top:12px;text-align:center">
        <button id="cmass-overlay-lock-btn" class="alt-btn" style="padding:10px 14px;border-radius:10px;margin-right:8px">세로로 전환</button>
        <button id="cmass-overlay-retry-btn" class="alt-btn" style="padding:10px 14px;border-radius:10px">다시 시도</button>
        <div style="margin-top:8px;font-size:12px;opacity:0.95;color:#eef">(버튼을 누르면 가능하면 화면을 세로로 고정합니다)</div>
        <div id="cmass-overlay-ios-help" style="margin-top:8px;font-size:13px;opacity:0.95;color:#eef;display:none">
          iOS/Safari에서는 자동 고정이 지원되지 않을 수 있습니다. 기기를 직접 세로로 돌려주시거나, 아래 '다시 시도'를 눌러보세요.
        </div>
      </div>
    </div>
  </div>
  <script>
    (function(){
      // Only show the portrait-lock overlay on mobile-like devices.
      // Desktop users (large screens / non-mobile UA) should not see this overlay.
      function isMobileDevice(){
        try{
          const ua = navigator.userAgent || '';
          const mobileUA = /Mobi|Android|iPhone|iPad|iPod|Windows Phone/i;
          const hasTouch = (navigator.maxTouchPoints && navigator.maxTouchPoints > 0) || ('ontouchstart' in window);
          const narrowScreen = (typeof screen !== 'undefined' && screen.width) ? screen.width <= 1024 : false;
          return mobileUA.test(ua) || (hasTouch && narrowScreen);
        }catch(e){ return false; }
      }
      function updatePortraitOverlay(){
        try{
          const overlay = document.getElementById('cmass-landscape-overlay');
          try{ if (sessionStorage && sessionStorage.getItem && sessionStorage.getItem('cmass_overlay_dismissed')){ if (overlay) overlay.style.display = 'none'; return; } }catch(e){}
          const mobile = isMobileDevice();
          // Determine landscape using reliable sources (prefer matchMedia / screen.orientation)
          let isLandscape = false;
          try{
            if (window.matchMedia && window.matchMedia('(orientation: landscape)').matches) isLandscape = true;
            else if (screen && screen.orientation && typeof screen.orientation.type === 'string') isLandscape = screen.orientation.type.indexOf('landscape') === 0;
            else if (typeof screen !== 'undefined' && screen.width && screen.height) isLandscape = screen.width > screen.height;
          }catch(e){ /* fallback below */ }

          if (mobile && isLandscape) {
            if (overlay) overlay.style.display = 'flex';
            try{ document.documentElement.style.overflow = 'hidden'; }catch(e){}
            try{ if (screen.orientation && screen.orientation.lock) screen.orientation.lock('portrait').catch(()=>{}); }catch(e){}
          } else {
            if (overlay) overlay.style.display = 'none';
            try{ document.documentElement.style.overflow = 'auto'; }catch(e){}
          }
        }catch(e){/* ignore */}
      }
      window.addEventListener('resize', updatePortraitOverlay);
      window.addEventListener('orientationchange', updatePortraitOverlay);
      document.addEventListener('DOMContentLoaded', function(){
          updatePortraitOverlay();
          // show iOS help text when appropriate
          try{
            const isiOS = /iP(hone|od|ad)/i.test(navigator.userAgent || '');
            const help = document.getElementById('cmass-overlay-ios-help');
            if (isiOS && help) help.style.display = '';
          }catch(e){}
        // wire up the manual lock/dismiss button
        try{
          const btn = document.getElementById('cmass-overlay-lock-btn');
          if (btn) btn.addEventListener('click', async function(){
            const overlay = document.getElementById('cmass-landscape-overlay');
            try{
              if (screen && screen.orientation && typeof screen.orientation.lock === 'function'){
                await screen.orientation.lock('portrait');
              }
            }catch(e){ /* locking may fail in some browsers, ignore */ }
            try{ if (overlay) overlay.style.display = 'none'; }catch(e){}
            try{ document.documentElement.style.overflow = 'auto'; }catch(e){}
            try{ sessionStorage.setItem('cmass_overlay_dismissed','1'); }catch(e){}
          });
          // retry button: useful for iOS/Safari where lock may fail; hide overlay and prompt user
          const retryBtn = document.getElementById('cmass-overlay-retry-btn');
          if (retryBtn) retryBtn.addEventListener('click', async function(){
            const overlay = document.getElementById('cmass-landscape-overlay');
            try{
              if (screen && screen.orientation && typeof screen.orientation.lock === 'function'){
                await screen.orientation.lock('portrait');
              } else {
                // show a brief guidance toast/alert for iOS users
                try{ alert('이 브라우저에서는 자동 고정이 지원되지 않을 수 있습니다. 기기를 직접 세로로 돌려주세요.'); }catch(e){}
              }
            }catch(e){ try{ alert('세로 고정 시도에 실패했습니다. 기기를 직접 세로로 돌려주세요.'); }catch(er){} }
            try{ if (overlay) overlay.style.display = 'none'; }catch(e){}
            try{ document.documentElement.style.overflow = 'auto'; }catch(e){}
            try{ sessionStorage.setItem('cmass_overlay_dismissed','1'); }catch(e){}
          });
          // hide overlay automatically while typing: when any focusable text input is focused, hide overlay
          document.addEventListener('focusin', function(ev){
            try{
              const t = ev.target;
              if (!t) return;
              const tag = (t.tagName || '').toLowerCase();
              const type = (t.type || '').toLowerCase();
              const isTextInput = tag === 'input' && (type === 'text' || type === 'search' || type === 'tel' || type === 'email' || type === 'number' || type === 'password') || tag === 'textarea' || (t.isContentEditable);
              if (isTextInput){ const overlay = document.getElementById('cmass-landscape-overlay'); if (overlay) overlay.style.display = 'none'; }
            }catch(e){}
          });
          // when input blur, re-evaluate overlay after short delay
          document.addEventListener('focusout', function(){ setTimeout(updatePortraitOverlay, 300); });
        }catch(e){}
      });
    })();
  </script>


  <script>
    // Ensure visitDate defaults to today (local timezone) when user opens the page
    (function(){
      try{
        document.addEventListener('DOMContentLoaded', function(){
          try{
            const el = document.getElementById('visitDate');
            if (!el) return;
            // Only set default if empty
            if (!el.value) {
              const t = new Date();
              const yyyy = t.getFullYear();
              const mm = String(t.getMonth() + 1).padStart(2, '0');
              const dd = String(t.getDate()).padStart(2, '0');
              el.value = `${yyyy}-${mm}-${dd}`;
              // trigger change handlers that may update topline / timetable
              try{ el.dispatchEvent(new Event('change', { bubbles: true })); }catch(e){}
              try{ if (typeof updateTopline === 'function') updateTopline(); }catch(e){}
            }
          }catch(e){}
        });
      }catch(e){}
    })();
  </script>

  <script>
    // Clear CMASS local drafts / caches on user request
    (function(){
      async function clearCmassLocalData(){
        try{
          const removed = [];
          for (let i = localStorage.length - 1; i >= 0; i--) {
            const k = localStorage.key(i);
            if (!k) continue;
            if (k.indexOf('cmass_') === 0 || k.indexOf('cmass') === 0) {
              try{ localStorage.removeItem(k); removed.push(k); }catch(e){}
            }
          }
          // unregister service workers
          if ('serviceWorker' in navigator) {
            try{
              const regs = await navigator.serviceWorker.getRegistrations().catch(()=>[]);
              for (const r of (regs||[])) { try{ await r.unregister(); }catch(e){} }
            }catch(e){}
          }
          // clear caches
          if (window.caches && caches.keys) {
            try{
              const keys = await caches.keys().catch(()=>[]);
              await Promise.all((keys||[]).map(k => caches.delete(k))).catch(()=>{});
            }catch(e){}
          }
          try{ if (typeof showToast === 'function') showToast('로컬 임시본이 삭제되었습니다. 새로고침하세요.', 3000); else alert('로컬 임시본이 삭제되었습니다. 새로고침하세요.'); }catch(e){}
          try{ if (typeof updateDraftStatus === 'function') updateDraftStatus(); }catch(e){}
        }catch(err){ console.error('clearCmassLocalData failed', err); alert('임시본 삭제 중 오류가 발생했습니다. 콘솔을 확인하세요.'); }
      }

      document.addEventListener('DOMContentLoaded', function(){
        const btn = document.getElementById('clearLocalDraftBtn');
        if (!btn) return;
        btn.addEventListener('click', async function(){
          try{
            const ok = await (typeof showConfirmModal === 'function' ? showConfirmModal('로컬에 저장된 모든 CMASS 임시본을 삭제합니다. 계속하시겠습니까?') : Promise.resolve(confirm('로컬에 저장된 모든 CMASS 임시본을 삭제합니다. 계속하시겠습니까?')));
            if (!ok) return;
            await clearCmassLocalData();
          }catch(e){ console.error('clear button handler failed', e); }
        });
      });
    })();
  </script>




</body>
</html>
